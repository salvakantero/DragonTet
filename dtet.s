* 6809 assembly program generated by cmoc 0.1.89


	SECTION	start


program_start	EXPORT
_main	IMPORT
INILIB	IMPORT
_exit	IMPORT
program_start	EQU	*
	LDD	#-1024		stack space in bytes
	LBSR	INILIB		initialize standard library and global variables
	LBSR	_main		call main()
	PSHS	B,A		send main() return value to exit()
	LBSR	_exit		use LBSR to respect calling convention


	ENDSECTION




	SECTION	code


_isCoCo3	IMPORT
_textScreenWidth	IMPORT
_textScreenHeight	IMPORT
_key	EXPORT
_numPlayers	EXPORT
_newScore	EXPORT
_gameOver	EXPORT
_dropRate	EXPORT
_startTime	EXPORT
_pit	EXPORT
_level	EXPORT
_lines	EXPORT
_pitLeft	EXPORT
_shape	EXPORT
_nextShape	EXPORT
_shapeAngle	EXPORT
_shapeX	EXPORT
_shapeY	EXPORT
_shapeMap	EXPORT
_nextShapeMap	EXPORT
_rotatedMap	EXPORT
_colourShift	EXPORT
_emptyBackground	EXPORT
_muted	EXPORT
_cancelled	EXPORT
_lastLines	EXPORT
_lastPoints	EXPORT
_backgroundChar	EXPORT
_backgroundCharList	EXPORT
_lastInputTime	EXPORT
_linesPiecesPlayed	EXPORT
_previousLevel	EXPORT
_names	EXPORT
_scores	EXPORT
_tune1Notes	EXPORT
_tune1Durations	EXPORT
_tune2Notes	EXPORT
_tune2Durations	EXPORT
_tune3Notes	EXPORT
_tune3Durations	EXPORT
___va_arg	IMPORT
_abs	IMPORT
_adddww	IMPORT
_atanf	IMPORT
_atoff	IMPORT
_atoi	IMPORT
_atol	IMPORT
_atoui	IMPORT
_atoul	IMPORT
_attr	IMPORT
_bsearch	IMPORT
_cls	IMPORT
_cmp	IMPORT
_cmpdww	IMPORT
_coldStart	IMPORT
_cosf	IMPORT
_delay	IMPORT
_divdwb	IMPORT
_divdww	IMPORT
_divmod16	IMPORT
_divmod8	IMPORT
_dwtoa	IMPORT
_enable_printf_float	IMPORT
_exit	IMPORT
_expf	IMPORT
_fabsf	IMPORT
_floorf	IMPORT
_ftoa	IMPORT
_getTextMode	IMPORT
_hscreen	IMPORT
_hset	IMPORT
_initCoCoSupport	IMPORT
_inkey	IMPORT
_isKeyPressed	IMPORT
_isalnum	IMPORT
_isalpha	IMPORT
_isdigit	IMPORT
_isspace	IMPORT
_itoa10	IMPORT
_labs	IMPORT
_locate	IMPORT
_logf	IMPORT
_ltoa10	IMPORT
_memchr	IMPORT
_memcmp	IMPORT
_memcpy	IMPORT
_memichr	IMPORT
_memicmp	IMPORT
_memmove	IMPORT
_memset	IMPORT
_memset16	IMPORT
_mulwb	IMPORT
_mulww	IMPORT
_palette	IMPORT
_paletteRGB	IMPORT
_pcls	IMPORT
_pmode	IMPORT
_printf	IMPORT
_putchar	IMPORT
_putstr	IMPORT
_qsort	IMPORT
_rand	IMPORT
_readJoystickButtons	IMPORT
_readJoystickPositions	IMPORT
_readline	IMPORT
_readword	IMPORT
_resetPalette	IMPORT
_rgb	IMPORT
_roundf	IMPORT
_sbrk	IMPORT
_sbrkmax	IMPORT
_screen	IMPORT
_setBorderColor	IMPORT
_setCaseFlag	IMPORT
_setConsoleOutHook	IMPORT
_setHighSpeed	IMPORT
_setOutputDevice	IMPORT
_setPmodeGraphicsAddressEx	IMPORT
_setSAMRegisters	IMPORT
_set_null_ptr_handler	IMPORT
_set_stack_overflow_handler	IMPORT
_showGraphicsAddress	IMPORT
_showLowResTextAddress	IMPORT
_showPmode4	IMPORT
_sinf	IMPORT
_sleep	IMPORT
_sound	IMPORT
_sprintf	IMPORT
_sqrt16	IMPORT
_sqrt32	IMPORT
_sqrtf	IMPORT
_srand	IMPORT
_strcat	IMPORT
_strchr	IMPORT
_strcmp	IMPORT
_strcpy	IMPORT
_strcspn	IMPORT
_stricmp	IMPORT
_strlen	IMPORT
_strlwr	IMPORT
_strncmp	IMPORT
_strncpy	IMPORT
_strpbrk	IMPORT
_strrchr	IMPORT
_strspn	IMPORT
_strstr	IMPORT
_strtof	IMPORT
_strtok	IMPORT
_strtol	IMPORT
_strtoul	IMPORT
_strupr	IMPORT
_subdww	IMPORT
_tanf	IMPORT
_tolower	IMPORT
_toupper	IMPORT
_truncf	IMPORT
_ultoa10	IMPORT
_utoa10	IMPORT
_vprintf	IMPORT
_vsprintf	IMPORT
_waitkey	IMPORT
_width	IMPORT
_zerodw	IMPORT
_playTune	EXPORT


*******************************************************************************

* FUNCTION playTune(): defined at dtet.c:130
_playTune	EQU	*
* Prototype: void playTune(const unsigned char *, const unsigned char *, unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-1,S
* Formal parameter(s):
*      4,U:    2 bytes: notes: const unsigned char *: line 130
*      6,U:    2 bytes: durations: const unsigned char *: line 130
*      9,U:    1 byte : numNotes: unsigned char: line 130
* Local non-static variable(s):
*     -1,U:    1 byte : i: unsigned char: line 133
* Line dtet.c:131: if
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:102
* optim: loadCmpZeroBeqOrBne
	BNE	L00124		 (optim: condBranchOverUncondBranch) (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00231 removed
* Line dtet.c:131
* optim: condBranchOverUncondBranch
* Useless label L00232 removed
* Useless label L00233 removed
* Line dtet.c:133: for init
* Line dtet.c:133: init of variable i
	CLR	-1,U		variable i
	BRA	L00235		jump to for condition
L00234	EQU	*
* Line dtet.c:133: for body
* Line dtet.c:134: if
* Line dtet.c:134: function call: inkey()
	LBSR	_inkey
	TSTB
	BNE	L00124		 (optim: condBranchOverUncondBranch) (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00238 removed
* Line dtet.c:134
* optim: condBranchOverUncondBranch
* Useless label L00239 removed
* Useless label L00240 removed
* Line dtet.c:135: function call: sound()
	LDB	-1,U		variable i
	LDX	6,U		pointer durations
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of sound(): const unsigned char
	LDB	-1,U		variable i
	LDX	4,U		pointer notes
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of sound(): const unsigned char
	LBSR	_sound
	LEAS	4,S
* Line dtet.c:136: if
* Line dtet.c:136: function call: inkey()
	LBSR	_inkey
	TSTB
	BNE	L00124		 (optim: condBranchOverUncondBranch) (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00241 removed
* Line dtet.c:136
* optim: condBranchOverUncondBranch
* Useless label L00242 removed
* Useless label L00243 removed
* Useless label L00236 removed
* Line dtet.c:133: for increment(s)
	INC	-1,U
L00235	EQU	*
* Line dtet.c:133: for condition
	LDB	-1,U		variable i
	CMPB	9,U		variable numNotes
	BLO	L00234
* optim: branchToNextLocation
* Useless label L00237 removed
L00124	EQU	*		end of playTune()
	LEAS	,U
	PULS	U,PC
* END FUNCTION playTune(): defined at dtet.c:130
funcend_playTune	EQU *
funcsize_playTune	EQU	funcend_playTune-_playTune
_printBlock	EXPORT


*******************************************************************************

* FUNCTION printBlock(): defined at dtet.c:141
_printBlock	EQU	*
* Prototype: void printBlock(int, int, unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-2,S
* Formal parameter(s):
*      4,U:    2 bytes: x: int: line 141
*      6,U:    2 bytes: y: int: line 141
*      9,U:    1 byte : ch: unsigned char: line 141
* Local non-static variable(s):
*     -2,U:    2 bytes: screenPos: unsigned char *: line 143
* Line dtet.c:143: init of variable screenPos
	LDD	4,U		variable `x', declared at dtet.c:141
	PSHS	B,A
	LDX	6,U		left
* optim: removeClrAFromArrayIndexMul
	LDB	#$20		right
	LBSR	MUL168
	ADDD	#$0400		optim: pushDLoadAdd
* 
* 
	ADDD	,S++
* Emitted no code to cast `int' to `unsigned char *'
	STD	-2,U		variable screenPos
* Line dtet.c:144: assignment: =
	LDB	9,U		variable `ch', declared at dtet.c:141
* optim: stripExtraPushPullB
* optim: optimizeLdx
* optim: stripExtraPushPullB
	STB	[-2,U]		optim: optimizeLdx
* Useless label L00125 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION printBlock(): defined at dtet.c:141
funcend_printBlock	EQU *
funcsize_printBlock	EQU	funcend_printBlock-_printBlock
_drawBlock	EXPORT


*******************************************************************************

* FUNCTION drawBlock(): defined at dtet.c:148
_drawBlock	EQU	*
* Prototype: void drawBlock(unsigned char, unsigned char, char, unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-1,S
* Formal parameter(s):
*      5,U:    1 byte : x: unsigned char: line 148
*      7,U:    1 byte : y: unsigned char: line 148
*      9,U:    1 byte : blockColour: char: line 148
*     11,U:    1 byte : i: unsigned char: line 148
* Local non-static variable(s):
*     -1,U:    1 byte : colour: unsigned char: line 151
* Line dtet.c:151: init of variable colour
	LDB	9,U		variable blockColour
	ADDB	#$D0		208
	STB	-1,U		variable colour
* Line dtet.c:152: assignment: +=
	LDB	11,U		variable i
	LEAX	_pitLeft+0,PCR	address of array pitLeft
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	ADDB	5,U		optim: pushBLoadAdd
* 
* 
	STB	5,U
	CLRA
* Line dtet.c:153: if
	LDB	-1,U		variable `colour', declared at dtet.c:151
* optim: loadCmpZeroBeqOrBne
	BNE	L00245		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00244 removed
* Line dtet.c:153
* Line dtet.c:154: function call: printBlock()
* Line dtet.c:154: conditional expression
	LDB	_emptyBackground+0,PCR	variable `emptyBackground', declared at dtet.c:101
* optim: loadCmpZeroBeqOrBne
	BEQ	L00247		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00246 removed
	CLRA
	LDB	#$80		decimal 128 signed
	BRA	L00248		end of true expression of conditional
L00247	EQU	*
	LDB	11,U		variable i
	LEAX	_backgroundChar+0,PCR	address of array backgroundChar
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	CLRA			promote from byte (conditional expression)
L00248	EQU	*
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 3 of printBlock(): unsigned char
	LDB	7,U		variable `y', declared at dtet.c:148
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 2 of printBlock(): unsigned char
	LDB	5,U		variable `x', declared at dtet.c:148
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of printBlock(): unsigned char
	LBSR	_printBlock
	LEAS	6,S
	BRA	L00126		return (dtet.c:155)
L00245	EQU	*		else clause of if() started at dtet.c:153
* Useless label L00249 removed
* Line dtet.c:157: function call: printBlock()
	LDB	-1,U		variable colour
	ADDB	#$FF		255
	LSLB
	LSLB
	LSLB
	LSLB
	PSHS	B
	CLRA
	LDB	#$8F		decimal 143 signed
	ADDB	,S+
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 3 of printBlock(): unsigned char
	LDB	7,U		variable `y', declared at dtet.c:148
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 2 of printBlock(): unsigned char
	LDB	5,U		variable `x', declared at dtet.c:148
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of printBlock(): unsigned char
	LBSR	_printBlock
	LEAS	6,S
L00126	EQU	*		end of drawBlock()
	LEAS	,U
	PULS	U,PC
* END FUNCTION drawBlock(): defined at dtet.c:148
funcend_drawBlock	EQU *
funcsize_drawBlock	EQU	funcend_drawBlock-_drawBlock
_drawPit	EXPORT


*******************************************************************************

* FUNCTION drawPit(): defined at dtet.c:161
_drawPit	EQU	*
* Prototype: void drawPit(unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-3,S
* Formal parameter(s):
*      5,U:    1 byte : i: unsigned char: line 161
* Local non-static variable(s):
*     -3,U:    1 byte : x: unsigned char: line 162
*     -2,U:    1 byte : y: unsigned char: line 162
*     -1,U:    1 byte : rowOffset: unsigned char: line 162
* Line dtet.c:164: for init
* Line dtet.c:164: assignment: =
	CLRB
	STB	-2,U		variable y
	LBRA	L00251		jump to for condition
L00250	EQU	*
* Line dtet.c:164: for body
* Line dtet.c:165: assignment: =
	LDA	-2,U
	LDB	#$0A
	MUL			result of type byte in B
	STB	-1,U
* Line dtet.c:166: for init
* Line dtet.c:166: assignment: =
	CLRB
	STB	-3,U		variable x
	BRA	L00255		jump to for condition
L00254	EQU	*
* Line dtet.c:167: for body
* Line dtet.c:167: function call: drawBlock()
	LDB	5,U		variable `i', declared at dtet.c:161
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 4 of drawBlock(): unsigned char
	LDB	-3,U		variable x
	ADDB	-1,U		variable rowOffset
* optim: stripExtraClrA_B
	PSHS	B,A		preserve array index
	LDB	5,U		variable i
* optim: stripExtraClrA_B
	LDA	#160		size of array element
	MUL			get offset in bytes in D
	LEAX	_pit+0,PCR	address of array pit
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,X		get r-value
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 3 of drawBlock(): char
	LDB	-2,U		variable `y', declared at dtet.c:162
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawBlock(): unsigned char
	LDB	-3,U		variable `x', declared at dtet.c:162
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of drawBlock(): unsigned char
	LBSR	_drawBlock
	LEAS	8,S
* Useless label L00256 removed
* Line dtet.c:166: for increment(s)
	INC	-3,U
L00255	EQU	*
* Line dtet.c:166: for condition
	LDB	-3,U		variable x
	CMPB	#$0A
	BLO	L00254
* optim: branchToNextLocation
* Useless label L00257 removed
* Useless label L00252 removed
* Line dtet.c:164: for increment(s)
	INC	-2,U
L00251	EQU	*
* Line dtet.c:164: for condition
	LDB	-2,U		variable y
	CMPB	#$10
	LBLO	L00250
* optim: branchToNextLocation
* Useless label L00253 removed
* Useless label L00127 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION drawPit(): defined at dtet.c:161
funcend_drawPit	EQU *
funcsize_drawPit	EQU	funcend_drawPit-_drawPit
_shapeCanMove	EXPORT


*******************************************************************************

* FUNCTION shapeCanMove(): defined at dtet.c:173
_shapeCanMove	EQU	*
* Prototype: unsigned char shapeCanMove(char *, char, char, unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-8,S
* Formal parameter(s):
*      4,U:    2 bytes: map: char *: line 173
*      7,U:    1 byte : xDir: char: line 173
*      9,U:    1 byte : yDir: char: line 173
*     11,U:    1 byte : i: unsigned char: line 173
* Local non-static variable(s):
*     -8,U:    2 bytes: x: int: line 174
*     -6,U:    2 bytes: y: int: line 174
*     -4,U:    2 bytes: blockX: int: line 174
*     -2,U:    2 bytes: blockY: int: line 174
* Line dtet.c:176: for init
* Line dtet.c:176: assignment: =
	CLRA
	CLRB
	STD	-2,U
	LBRA	L00259		jump to for condition
L00258	EQU	*
* Line dtet.c:176: for body
* Line dtet.c:177: for init
* Line dtet.c:177: assignment: =
	CLRA
	CLRB
	STD	-4,U
	LBRA	L00263		jump to for condition
L00262	EQU	*
* Line dtet.c:177: for body
* Line dtet.c:178: if
	LDD	-4,U		variable `blockX', declared at dtet.c:174
	PSHS	B,A
	LDX	#$04		left
	LDD	-2,U		right
	LBSR	MUL16
	ADDD	,S++
	LDX	4,U		pointer map
* optimizeLoadDX
	LDB	D,X		get r-value
	CMPB	#48
	LBEQ	L00267		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00266 removed
* Line dtet.c:178
* Line dtet.c:180: assignment: =
	LDB	7,U		variable `xDir', declared at dtet.c:173
	SEX			promotion of binary operand
	PSHS	B,A
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDB	11,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_shapeX+0,PCR	address of array shapeX
* optimizeLoadDX
	LDD	D,X		get r-value
	ADDD	-4,U		optim: optimizeStackOperations4
	ADDD	,S++
	STD	-8,U
* Line dtet.c:181: assignment: =
	LDB	9,U		variable `yDir', declared at dtet.c:173
	SEX			promotion of binary operand
	PSHS	B,A
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDB	11,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_shapeY+0,PCR	address of array shapeY
* optimizeLoadDX
	LDD	D,X		get r-value
	ADDD	-2,U		optim: optimizeStackOperations4
	ADDD	,S++
	STD	-6,U
* Line dtet.c:183: if
* optim: storeLoad
	ADDD	#0
	BGE	L00269		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00268 removed
* Line dtet.c:184
* Line dtet.c:184: return with value
	LDB	7,U		variable xDir
* optim: loadCmpZeroBeqOrBne
	BEQ	L00270		if true
	CLRB
	LBRA	L00128		false
L00270	EQU	*
	LDB	#1
* Useless label L00271 removed
	LBRA	L00128		return (dtet.c:184)
L00269	EQU	*		else clause of if() started at dtet.c:183
* Useless label L00272 removed
* Line dtet.c:186: if
	LDD	-8,U		variable x
	ADDD	#0
	BLT	L00274		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00276 removed
	LDD	-8,U		variable x
	CMPD	#$0A
	BGE	L00274		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00275 removed
	LDD	-6,U		variable y
	CMPD	#$10
	BGE	L00274		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00273 removed
* Line dtet.c:186
* Line dtet.c:188: if
	LDD	-8,U		variable `x', declared at dtet.c:174
	PSHS	B,A
	LDD	-6,U		variable `y', declared at dtet.c:174
	LBSR	MUL16BY10
	ADDD	,S++
	PSHS	B,A		preserve array index
	LDB	11,U		variable i
* optim: stripOpToDeadReg
	LDA	#160		size of array element
	MUL			get offset in bytes in D
	LEAX	_pit+0,PCR	address of array pit
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,X		get r-value
	CMPB	#48
	BEQ	L00280		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00277 removed
* Line dtet.c:189
	CLRB
	BRA	L00128		return (dtet.c:189)
* Useless label L00278 removed
* Useless label L00279 removed
	BRA	L00280		jump over else clause
L00274	EQU	*		else clause of if() started at dtet.c:186
* Line dtet.c:192
	CLRB
	BRA	L00128		return (dtet.c:192)
L00280	EQU	*		end of if() started at dtet.c:186
L00267	EQU	*		else clause of if() started at dtet.c:178
* Useless label L00281 removed
* Useless label L00264 removed
* Line dtet.c:177: for increment(s)
	LDD	-4,U
	ADDD	#1
	STD	-4,U
L00263	EQU	*
* Line dtet.c:177: for condition
	LDD	-4,U		variable blockX
	CMPD	#$03
	LBLE	L00262
* optim: branchToNextLocation
* Useless label L00265 removed
* Useless label L00260 removed
* Line dtet.c:176: for increment(s)
	LDD	-2,U
	ADDD	#1
	STD	-2,U
L00259	EQU	*
* Line dtet.c:176: for condition
	LDD	-2,U		variable blockY
	CMPD	#$03
	LBLE	L00258
* optim: branchToNextLocation
* Useless label L00261 removed
	LDB	#1
* optim: branchToNextLocation
L00128	EQU	*		end of shapeCanMove()
	LEAS	,U
	PULS	U,PC
* END FUNCTION shapeCanMove(): defined at dtet.c:173
funcend_shapeCanMove	EQU *
funcsize_shapeCanMove	EQU	funcend_shapeCanMove-_shapeCanMove
_drawNextShape	EXPORT


*******************************************************************************

* FUNCTION drawNextShape(): defined at dtet.c:200
_drawNextShape	EQU	*
* Prototype: void drawNextShape(unsigned char, unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-3,S
* Formal parameter(s):
*      5,U:    1 byte : y: unsigned char: line 200
*      7,U:    1 byte : i: unsigned char: line 200
* Local non-static variable(s):
*     -3,U:    1 byte : blockX: unsigned char: line 201
*     -2,U:    1 byte : blockY: unsigned char: line 201
*     -1,U:    1 byte : blockColour: unsigned char: line 201
* Line dtet.c:203: for init
* Line dtet.c:203: assignment: =
	CLRB
	STB	-2,U		variable blockY
	LBRA	L00283		jump to for condition
L00282	EQU	*
* Line dtet.c:203: for body
* Line dtet.c:204: for init
* Line dtet.c:204: assignment: =
	CLRB
	STB	-3,U		variable blockX
	LBRA	L00287		jump to for condition
L00286	EQU	*
* Line dtet.c:204: for body
* Line dtet.c:205: assignment: =
* optim: optimize8BitStackOps
* optim: optimize8BitStackOps
	LDB	-2,U		to be multiplied by 4
	LSLB
	LSLB
	ADDB	-3,U		optim: optimize8BitStackOps
	CLRA			extend byte index expression
	PSHS	B,A		preserve array index
	LDB	7,U		variable i
* optim: stripExtraClrA_B
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LEAX	_nextShapeMap+0,PCR	address of array nextShapeMap
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,X		get r-value
	STB	-1,U
* Line dtet.c:206: if
* optim: storeLoad
	CMPB	#$30
	BNE	L00291		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00290 removed
* Line dtet.c:206
* Line dtet.c:206: assignment: =
	LDB	#$31
	STB	-1,U		variable blockColour
	BRA	L00292		jump over else clause
L00291	EQU	*		else clause of if() started at dtet.c:206
* Line dtet.c:209
* Line dtet.c:207: if
	LDB	-1,U		variable blockColour
	CMPB	#$31
	BNE	L00294		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00293 removed
* Line dtet.c:207
* Line dtet.c:207: assignment: =
	LDB	#$35
	STB	-1,U		variable blockColour
L00294	EQU	*		else clause of if() started at dtet.c:207
* Useless label L00295 removed
L00292	EQU	*		end of if() started at dtet.c:206
* Line dtet.c:209: if
	LDB	7,U		variable `i', declared at dtet.c:200
* optim: loadCmpZeroBeqOrBne
	BNE	L00297		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00296 removed
* Line dtet.c:209
* Line dtet.c:209: function call: drawBlock()
	LDB	7,U		variable `i', declared at dtet.c:200
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 4 of drawBlock(): unsigned char
	LDB	-1,U		variable `blockColour', declared at dtet.c:201
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 3 of drawBlock(): unsigned char
	LDB	-2,U		variable blockY
	ADDB	5,U		variable y
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 2 of drawBlock(): unsigned char
	LDB	-3,U		variable blockX
	ADDB	#$11		17
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of drawBlock(): unsigned char
	LBSR	_drawBlock
	LEAS	8,S
	BRA	L00298		jump over else clause
L00297	EQU	*		else clause of if() started at dtet.c:209
* Line dtet.c:210
* Line dtet.c:210: function call: drawBlock()
	LDB	7,U		variable `i', declared at dtet.c:200
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 4 of drawBlock(): unsigned char
	LDB	-1,U		variable `blockColour', declared at dtet.c:201
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 3 of drawBlock(): unsigned char
	LDB	-2,U		variable blockY
	ADDB	5,U		variable y
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 2 of drawBlock(): unsigned char
	LDB	-3,U		variable blockX
	ADDB	#$FB		251
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of drawBlock(): unsigned char
	LBSR	_drawBlock
	LEAS	8,S
L00298	EQU	*		end of if() started at dtet.c:209
* Useless label L00288 removed
* Line dtet.c:204: for increment(s)
	INC	-3,U
L00287	EQU	*
* Line dtet.c:204: for condition
	LDB	-3,U		variable blockX
	CMPB	#$03
	LBLS	L00286
* optim: branchToNextLocation
* Useless label L00289 removed
* Useless label L00284 removed
* Line dtet.c:203: for increment(s)
	INC	-2,U
L00283	EQU	*
* Line dtet.c:203: for condition
	LDB	-2,U		variable blockY
	CMPB	#$03
	LBLS	L00282
* optim: branchToNextLocation
* Useless label L00285 removed
* Useless label L00129 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION drawNextShape(): defined at dtet.c:200
funcend_drawNextShape	EQU *
funcsize_drawNextShape	EQU	funcend_drawNextShape-_drawNextShape
_drawHeader	EXPORT


*******************************************************************************

* FUNCTION drawHeader(): defined at dtet.c:216
_drawHeader	EQU	*
* Prototype: void drawHeader(unsigned char, unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-13,S
* Formal parameter(s):
*      5,U:    1 byte : ingame: unsigned char: line 216
*      7,U:    1 byte : shift: unsigned char: line 216
* Local non-static variable(s):
*    -13,U:    1 byte : pos: unsigned char: line 224
*    -12,U:    1 byte : colour: unsigned char: line 217
*    -11,U:    7 bytes: colours: const unsigned char[]: line 218
*     -4,U:    1 byte : colourCount: unsigned char: line 219
*     -3,U:    1 byte : x: unsigned char: line 220
*     -2,U:    1 byte : y: unsigned char: line 221
*     -1,U:    1 byte : width: unsigned char: line 222
* Line dtet.c:218: init of variable colours
	LDB	#$02		decimal 2 signed
	STB	-11,U		offset in variable colours
	LDB	#$03		decimal 3 signed
	STB	-10,U		offset in variable colours
	LDB	#$04		decimal 4 signed
	STB	-9,U		offset in variable colours
	LDB	#$05		decimal 5 signed
	STB	-8,U		offset in variable colours
	LDB	#$06		decimal 6 signed
	STB	-7,U		offset in variable colours
	LDB	#$07		decimal 7 signed
	STB	-6,U		offset in variable colours
	LDB	#$08		decimal 8 signed
	STB	-5,U		offset in variable colours
* Line dtet.c:219: init of variable colourCount
	LDB	#$07		7
	STB	-4,U		variable colourCount
* Line dtet.c:220: init of variable x
* Line dtet.c:220: conditional expression
	LDB	5,U		variable `ingame', declared at dtet.c:216
* optim: loadCmpZeroBeqOrBne
	BEQ	L00300		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00299 removed
	CLRA
	LDB	#$0B		decimal 11 signed
	BRA	L00301		end of true expression of conditional
L00300	EQU	*
	CLRA
	LDB	#$08		decimal 8 signed
L00301	EQU	*
	STB	-3,U		variable x
* Line dtet.c:221: init of variable y
* Line dtet.c:221: conditional expression
	LDB	5,U		variable `ingame', declared at dtet.c:216
* optim: loadCmpZeroBeqOrBne
	BEQ	L00303		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00302 removed
	CLRA
	LDB	#$02		decimal 2 signed
	BRA	L00304		end of true expression of conditional
L00303	EQU	*
	CLRA
	LDB	#$01		decimal 1 signed
L00304	EQU	*
	STB	-2,U		variable y
* Line dtet.c:222: init of variable width
* Line dtet.c:222: conditional expression
	LDB	5,U		variable `ingame', declared at dtet.c:216
* optim: loadCmpZeroBeqOrBne
	BEQ	L00306		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00305 removed
	CLRA
	LDB	#$0A		decimal 10 signed
	BRA	L00307		end of true expression of conditional
L00306	EQU	*
	CLRA
	LDB	#$11		decimal 17 signed
L00307	EQU	*
	STB	-1,U		variable width
* Line dtet.c:224: for init
* Line dtet.c:224: init of variable pos
	CLR	-13,U		variable pos
	LBRA	L00309		jump to for condition
L00308	EQU	*
* Line dtet.c:224: for body
* Line dtet.c:226: assignment: =
	LDB	-13,U		variable pos
	ADDB	7,U		variable shift
	TFR	B,A		dividend expected in A
	LDB	-4,U		divisor
	LBSR	DIV8
	TFR	A,B		resulting modulo in B
	LEAX	-11,U		address of array colours
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	STB	-12,U
* Line dtet.c:227: function call: printBlock()
* optim: storeLoad
	ADDB	#$FF		255
	LSLB
	LSLB
	LSLB
	LSLB
	PSHS	B
	CLRA
	LDB	#$8F		decimal 143 signed
	ADDB	,S+
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 3 of printBlock(): unsigned char
	LDB	-2,U		variable `y', declared at dtet.c:221
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 2 of printBlock(): unsigned char
	LDB	-3,U		variable x
	ADDB	-13,U		variable pos
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of printBlock(): unsigned char
	LBSR	_printBlock
	LEAS	6,S
* Line dtet.c:229: assignment: =
	LDB	7,U		variable `shift', declared at dtet.c:216
	PSHS	B
	LDB	-13,U		variable pos
	ADDB	-4,U		variable colourCount
	SUBB	,S+
	TFR	B,A		dividend expected in A
	LDB	-4,U		divisor
	LBSR	DIV8
	TFR	A,B		resulting modulo in B
	LEAX	-11,U		address of array colours
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	STB	-12,U
* Line dtet.c:230: function call: printBlock()
* optim: storeLoad
	ADDB	#$FF		255
	LSLB
	LSLB
	LSLB
	LSLB
	PSHS	B
	CLRA
	LDB	#$8F		decimal 143 signed
	ADDB	,S+
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 3 of printBlock(): unsigned char
	LDB	-2,U		variable y
	ADDB	#$02		2
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 2 of printBlock(): unsigned char
	LDB	-3,U		variable x
	ADDB	-13,U		variable pos
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of printBlock(): unsigned char
	LBSR	_printBlock
	LEAS	6,S
* Useless label L00310 removed
* Line dtet.c:224: for increment(s)
	INC	-13,U
L00309	EQU	*
* Line dtet.c:224: for condition
	LDB	-13,U		variable pos
	CMPB	-1,U		variable width
	LBLO	L00308
* optim: branchToNextLocation
* Useless label L00311 removed
* Line dtet.c:232: if
	LDB	5,U		variable `ingame', declared at dtet.c:216
* optim: loadCmpZeroBeqOrBne
	BEQ	L00313		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00312 removed
* Line dtet.c:232
* Line dtet.c:233: function call: locate()
	LDB	-2,U		variable y
	ADDB	#$01		1
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of locate(): unsigned char
	LDB	-3,U		variable `x', declared at dtet.c:220
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of locate(): unsigned char
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:233: function call: printf()
	LEAX	S00162,PCR	"DRAGONTET!"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
	BRA	L00314		jump over else clause
L00313	EQU	*		else clause of if() started at dtet.c:232
* Line dtet.c:235
* Line dtet.c:236: function call: locate()
	LDB	-2,U		variable y
	ADDB	#$01		1
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of locate(): unsigned char
	LDB	-3,U		variable `x', declared at dtet.c:220
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of locate(): unsigned char
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:236: function call: printf()
	LEAX	S00163,PCR	"D R A G O N T E T"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:237: function call: locate()
	CLRA
	LDB	#$05		decimal 5 signed
	PSHS	B,A		C function argument 2 of locate(): int
	LDB	-3,U		variable `x', declared at dtet.c:220
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of locate(): unsigned char
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:237: function call: printf()
	LEAX	S00164,PCR	"SALVAKANTERO 2025"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
L00314	EQU	*		end of if() started at dtet.c:232
* Useless label L00130 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION drawHeader(): defined at dtet.c:216
funcend_drawHeader	EQU *
funcsize_drawHeader	EQU	funcend_drawHeader-_drawHeader
_drawPlayerStatus	EXPORT


*******************************************************************************

* FUNCTION drawPlayerStatus(): defined at dtet.c:243
_drawPlayerStatus	EQU	*
* Prototype: void drawPlayerStatus(unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-1,S
* Formal parameter(s):
*      5,U:    1 byte : i: unsigned char: line 243
* Local non-static variable(s):
*     -1,U:    1 byte : yOffset: unsigned char: line 244
* Line dtet.c:244: init of variable yOffset
* Line dtet.c:244: conditional expression
	LDB	5,U		variable `i', declared at dtet.c:243
* optim: loadCmpZeroBeqOrBne
	BNE	L00316		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00315 removed
	CLRA
	CLRB
	BRA	L00317		end of true expression of conditional
L00316	EQU	*
	CLRA
	LDB	#$08		decimal 8 signed
L00317	EQU	*
	STB	-1,U		variable yOffset
* Line dtet.c:245: function call: locate()
* optim: storeLoad
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of locate(): unsigned char
	LDB	#$0C		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:245: function call: printf()
	LDB	5,U		variable i
	ADDB	#$01		1
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of printf(): unsigned char
	LEAX	S00165,PCR	"DRAGON %u"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	4,S
* Line dtet.c:246: function call: locate()
	LDB	-1,U		variable yOffset
	ADDB	#$01		1
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of locate(): unsigned char
	LDB	#$0B		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:246: function call: printf()
	LDB	5,U		variable i
	LEAX	_level+0,PCR	address of array level
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of printf(): unsigned char
	LEAX	S00166,PCR	"LEVEL:  %2u"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	4,S
* Line dtet.c:247: function call: locate()
	LDB	-1,U		variable yOffset
	ADDB	#$02		2
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of locate(): unsigned char
	LDB	#$0B		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:247: function call: printf()
	LDB	5,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_lines+0,PCR	address of array lines
* optimizeLoadDX
	LDD	D,X		get r-value
	PSHS	B,A		C function argument 2 of printf(): int
	LEAX	S00167,PCR	"LINES: %3d"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	4,S
* Line dtet.c:248: function call: locate()
	LDB	-1,U		variable yOffset
	ADDB	#$03		3
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of locate(): unsigned char
	LDB	#$0B		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:248: function call: printf()
	LDB	5,U		variable i
	ADDB	#$06		6
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_scores+0,PCR	address of array scores
* optimizeLoadDX
	LDD	D,X		get r-value
	PSHS	B,A		C function argument 2 of printf(): unsigned int
	LEAX	S00168,PCR	"SC: %6u"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	4,S
* Line dtet.c:249: function call: locate()
	LDB	-1,U		variable yOffset
	ADDB	#$04		4
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of locate(): unsigned char
	LDB	#$0B		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:249: function call: printf()
	LEAX	S00169,PCR	"NEXT:"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:250: function call: drawNextShape()
	LDB	5,U		variable `i', declared at dtet.c:243
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawNextShape(): unsigned char
* Line dtet.c:250: conditional expression
	LDB	5,U		variable `i', declared at dtet.c:243
* optim: loadCmpZeroBeqOrBne
	BNE	L00319		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00318 removed
	CLRA
	LDB	#$04		decimal 4 signed
	BRA	L00320		end of true expression of conditional
L00319	EQU	*
	LDB	#$0C		optim: lddToLDB
L00320	EQU	*
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 1 of drawNextShape(): char
	LBSR	_drawNextShape
	LEAS	4,S
* Useless label L00131 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION drawPlayerStatus(): defined at dtet.c:243
funcend_drawPlayerStatus	EQU *
funcsize_drawPlayerStatus	EQU	funcend_drawPlayerStatus-_drawPlayerStatus
_displayStatus	EXPORT


*******************************************************************************

* FUNCTION displayStatus(): defined at dtet.c:254
_displayStatus	EQU	*
* Prototype: void displayStatus(...)
* Calling convention: 0 (CMOC Default)
* Line dtet.c:256: if
	LDB	_numPlayers+0,PCR	variable `numPlayers', declared at dtet.c:84
* optim: loadCmpZeroBeqOrBne
	LBNE	L00322		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00321 removed
* Line dtet.c:256
* Line dtet.c:257: function call: drawHeader()
	INC	_colourShift+0,PCR
	LDB	_colourShift+0,PCR
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawHeader(): unsigned char
	LDB	#$01		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of drawHeader(): int
	LBSR	_drawHeader
	LEAS	4,S
* Line dtet.c:258: function call: locate()
	CLRA
	LDB	#$06		decimal 6 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$0B		decimal 11 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:258: function call: printf()
	LDB	_level+0,PCR	index 0 in array level[]
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of printf(): unsigned char
	LEAX	S00166,PCR	"LEVEL:  %2u"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	4,S
* Line dtet.c:259: function call: locate()
	CLRA
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$0B		decimal 11 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:259: function call: printf()
	LDD	_lines+0,PCR	index 0 in array lines[]
	PSHS	B,A		C function argument 2 of printf(): int
	LEAX	S00167,PCR	"LINES: %3d"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	4,S
* Line dtet.c:260: function call: locate()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$0B		decimal 11 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:260: function call: printf()
	LDD	_scores+12,PCR	index 6 in array scores[]
	PSHS	B,A		C function argument 2 of printf(): unsigned int
	LEAX	S00168,PCR	"SC: %6u"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	4,S
* Line dtet.c:261: function call: locate()
	CLRA
	LDB	#$09		decimal 9 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$0B		decimal 11 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:261: function call: printf()
	LDD	_scores+0,PCR	index 0 in array scores[]
	PSHS	B,A		C function argument 2 of printf(): unsigned int
	LEAX	S00170,PCR	"HI: %6u"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	4,S
* Line dtet.c:262: function call: locate()
	CLRA
	LDB	#$0B		decimal 11 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$0B		decimal 11 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:262: function call: printf()
	LEAX	S00169,PCR	"NEXT:"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:263: function call: drawNextShape()
	CLRA
	CLRB
	PSHS	B,A		C function argument 2 of drawNextShape(): int
	LDB	#$0A		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of drawNextShape(): int
	LBSR	_drawNextShape
	LEAS	4,S
* Line dtet.c:265: function call: locate()
	CLRA
	LDB	#$0E		decimal 14 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$0B		decimal 11 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:266: if
	LDB	_lastLines+0,PCR	variable lastLines
* optim: removeCMPZeroAfterLDIfBHI (BHI->BNE)
	BEQ	L00324		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00323 removed
* Line dtet.c:266
* Line dtet.c:266: function call: printf()
	LDD	_lastPoints+0,PCR	variable `lastPoints', declared at dtet.c:105
	PSHS	B,A		C function argument 3 of printf(): unsigned int
	LDB	_lastLines+0,PCR	variable `lastLines', declared at dtet.c:104
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of printf(): unsigned char
	LEAX	S00171,PCR	"%uLIN +%4u"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	6,S
	BRA	L00325		jump over else clause
L00324	EQU	*		else clause of if() started at dtet.c:266
* Line dtet.c:268
* Line dtet.c:267: if
	LDD	_lastPoints+0,PCR	variable lastPoints
* optim: removeCMPZeroAfterLDIfBHI (BHI->BNE)
	BEQ	L00327		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00326 removed
* Line dtet.c:267
* Line dtet.c:267: function call: printf()
	LDD	_lastPoints+0,PCR	variable `lastPoints', declared at dtet.c:105
	PSHS	B,A		C function argument 2 of printf(): unsigned int
	LEAX	S00172,PCR	"DROP   +%2u"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	4,S
	BRA	L00328		jump over else clause
L00327	EQU	*		else clause of if() started at dtet.c:267
* Line dtet.c:268
* Line dtet.c:268: function call: printf()
	LEAX	S00173,PCR	"          "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
L00328	EQU	*		end of if() started at dtet.c:267
L00325	EQU	*		end of if() started at dtet.c:266
* Line dtet.c:269: assignment: =
	CLR	_lastLines+0,PCR	variable lastLines
* Line dtet.c:270: assignment: =
	CLRA
	CLRB
	STD	_lastPoints+0,PCR
	BRA	L00329		jump over else clause
L00322	EQU	*		else clause of if() started at dtet.c:256
* Line dtet.c:272
* Line dtet.c:273: function call: drawPlayerStatus()
	CLRA
	CLRB
	PSHS	B,A		C function argument 1 of drawPlayerStatus(): int
	LBSR	_drawPlayerStatus
	LEAS	2,S
* Line dtet.c:274: function call: drawPlayerStatus()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of drawPlayerStatus(): int
	LBSR	_drawPlayerStatus
	LEAS	2,S
L00329	EQU	*		end of if() started at dtet.c:256
* Line dtet.c:276: function call: locate()
	CLRA
	LDB	#$0F		decimal 15 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$0E		decimal 14 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Useless label L00132 removed
	RTS
* END FUNCTION displayStatus(): defined at dtet.c:254
funcend_displayStatus	EQU *
funcsize_displayStatus	EQU	funcend_displayStatus-_displayStatus
_getShapeMap	EXPORT


*******************************************************************************

* FUNCTION getShapeMap(): defined at dtet.c:280
_getShapeMap	EQU	*
* Prototype: const char *getShapeMap(unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
* Formal parameter(s):
*      5,U:    1 byte : shape: unsigned char: line 280
	TST	.local.static.getShapeMap.shapeMaps.initialized	has `shapeMaps' been initialized?
	BNE	L00330		if yes, skip init code
* Line dtet.c:281: init of variable shapeMaps
	LEAX	S00174,PCR	"0000444400000000"
	STX	.local.static.getShapeMap.shapeMaps+0,PCR	offset in variable shapeMaps
	LEAX	S00175,PCR	"0000222000200000"
	STX	.local.static.getShapeMap.shapeMaps+2,PCR	offset in variable shapeMaps
	LEAX	S00176,PCR	"0000777070000000"
	STX	.local.static.getShapeMap.shapeMaps+4,PCR	offset in variable shapeMaps
	LEAX	S00177,PCR	"0000033003300000"
	STX	.local.static.getShapeMap.shapeMaps+6,PCR	offset in variable shapeMaps
	LEAX	S00178,PCR	"0000066066000000"
	STX	.local.static.getShapeMap.shapeMaps+8,PCR	offset in variable shapeMaps
	LEAX	S00179,PCR	"0000880008800000"
	STX	.local.static.getShapeMap.shapeMaps+10,PCR	offset in variable shapeMaps
	LEAX	S00180,PCR	"0000111001000000"
	STX	.local.static.getShapeMap.shapeMaps+12,PCR	offset in variable shapeMaps
	INC	.local.static.getShapeMap.shapeMaps.initialized	mark `shapeMaps' as initialized
L00330	EQU	*
* Line dtet.c:290: return with value
	LDB	5,U		variable shape
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	.local.static.getShapeMap.shapeMaps+0,PCR	address of array shapeMaps
* optimizeLoadDX
	LDD	D,X		get r-value
* optim: branchToNextLocation
* Useless label L00133 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION getShapeMap(): defined at dtet.c:280
funcend_getShapeMap	EQU *
funcsize_getShapeMap	EQU	funcend_getShapeMap-_getShapeMap
_getRotatedShapeMap	EXPORT


*******************************************************************************

* FUNCTION getRotatedShapeMap(): defined at dtet.c:294
_getRotatedShapeMap	EQU	*
* Prototype: void getRotatedShapeMap(unsigned char, unsigned char, char *)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-12,S
* Formal parameter(s):
*      5,U:    1 byte : shape: unsigned char: line 294
*      7,U:    1 byte : angle: unsigned char: line 294
*      8,U:    2 bytes: rotatedMap: char *: line 294
* Local non-static variable(s):
*    -12,U:    2 bytes: blockX: int: line 305
*    -10,U:    2 bytes: blockY: int: line 306
*     -8,U:    2 bytes: newBlockX: int: line 307
*     -6,U:    2 bytes: newBlockY: int: line 307
*     -4,U:    2 bytes: i: int: line 304
*     -2,U:    2 bytes: map: const char *: line 295
* Line dtet.c:295: init of variable map
* Line dtet.c:295: function call: getShapeMap()
	LDB	5,U		variable `shape', declared at dtet.c:294
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 1 of getShapeMap(): unsigned char
	LBSR	_getShapeMap
	LEAS	2,S
	STD	-2,U		variable map
* Line dtet.c:297: if
	LDB	7,U		variable `angle', declared at dtet.c:294
* optim: loadCmpZeroBeqOrBne
	BNE	L00332		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00331 removed
* Line dtet.c:297
* Line dtet.c:298: function call: strncpy()
	CLRA
	LDB	#$10		decimal 16 signed
	PSHS	B,A		C function argument 3 of strncpy(): int
	LDD	-2,U		variable `map', declared at dtet.c:295
	PSHS	B,A		C function argument 2 of strncpy(): const char *
	LDD	8,U		variable `rotatedMap', declared at dtet.c:294
	PSHS	B,A		C function argument 1 of strncpy(): char *
	LBSR	_strncpy
	LEAS	6,S
	LBRA	L00134		return (dtet.c:299)
L00332	EQU	*		else clause of if() started at dtet.c:297
* Useless label L00333 removed
* Line dtet.c:302: function call: memset()
	CLRA
	LDB	#$10		decimal 16 signed
	PSHS	B,A		C function argument 3 of memset(): int
	LDB	#$30		decimal 48 signed
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 2 of memset(): char
	LDD	8,U		variable `rotatedMap', declared at dtet.c:294
	PSHS	B,A		C function argument 1 of memset(): char *
	LBSR	_memset
	LEAS	6,S
* Line dtet.c:304: for init
* Line dtet.c:304: init of variable i
	CLRA
	CLRB
	STD	-4,U		variable i
	LBRA	L00335		jump to for condition
L00334	EQU	*
* Line dtet.c:304: for body
* Line dtet.c:305: init of variable blockX
	LDX	-4,U		left
	CLRA
	LDB	#$04		right
	LBSR	SDIV16
	STD	-12,U		variable blockX
* Line dtet.c:306: init of variable blockY
	LDX	-4,U		left
	CLRA
	LDB	#$04		right
	LBSR	SDIV16
	TFR	X,D		quotient
	STD	-10,U		variable blockY
* Line dtet.c:307: init of variable newBlockX
	CLRA
	CLRB
	STD	-8,U		variable newBlockX
* Line dtet.c:307: init of variable newBlockY
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
	STD	-6,U		variable newBlockY
* Line dtet.c:308: switch
	LDB	7,U		variable `angle', declared at dtet.c:294
* Switch at dtet.c:308 has 3 non-ignored case values.
* Switch at dtet.c:308 uses if-else sequence: IF_ELSE=21, JUMP_TABLE=26
* Switch case at dtet.c:309
	CMPB	#$01		case 1
	BEQ	L00339
* Switch case at dtet.c:313
	CMPB	#$02		case 2
	BEQ	L00340
* Switch case at dtet.c:317
	CMPB	#$03		case 3
	BEQ	L00341
	BRA	L00338		switch default
L00339	EQU	*		case 1
* Line dtet.c:310: assignment: =
* optim: stripConsecutiveLoadsToSameReg
	LDD	-10,U
	STD	-8,U
* Line dtet.c:311: assignment: =
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	CLRA
	LDB	#$03		decimal 3 signed
	SUBD	-12,U		optim: optimizeStackOperations4
	STD	-6,U
	BRA	L00338		break
L00340	EQU	*		case 2
* Line dtet.c:314: assignment: =
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	CLRA
	LDB	#$03		decimal 3 signed
	SUBD	-12,U		optim: optimizeStackOperations4
	STD	-8,U
* Line dtet.c:315: assignment: =
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	CLRA
	LDB	#$03		decimal 3 signed
	SUBD	-10,U		optim: optimizeStackOperations4
	STD	-6,U
	BRA	L00338		break
L00341	EQU	*		case 3
* Line dtet.c:318: assignment: =
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	CLRA
	LDB	#$03		decimal 3 signed
	SUBD	-10,U		optim: optimizeStackOperations4
	STD	-8,U
* Line dtet.c:319: assignment: =
* optim: stripConsecutiveLoadsToSameReg
	LDD	-12,U
	STD	-6,U
* optim: branchToNextLocation
L00338	EQU	*		end of switch
* Line dtet.c:323: assignment: =
	LDD	-12,U		variable `blockX', declared at dtet.c:305
	PSHS	B,A
	LDX	-10,U		left
* optim: removeClrAFromArrayIndexMul
	LDB	#$04		right
	LBSR	MUL168
	ADDD	,S++
	LDX	-2,U		pointer map
* optimizeLoadDX
	LDB	D,X		get r-value
	PSHS	B
	LDD	-8,U		variable `newBlockX', declared at dtet.c:307
	PSHS	B,A
	LDX	-6,U		left
* optim: removeClrAFromArrayIndexMul
	LDB	#$04		right
	LBSR	MUL168
	ADDD	,S++
	LDX	8,U		pointer rotatedMap
	LEAX	D,X		add offset
	LDB	,S+
	STB	,X
* Useless label L00336 removed
* Line dtet.c:304: for increment(s)
	LDD	-4,U
	ADDD	#1
	STD	-4,U
L00335	EQU	*
* Line dtet.c:304: for condition
	LDD	-4,U		variable i
	CMPD	#$10
	LBLT	L00334
* optim: branchToNextLocation
* Useless label L00337 removed
L00134	EQU	*		end of getRotatedShapeMap()
	LEAS	,U
	PULS	U,PC
* END FUNCTION getRotatedShapeMap(): defined at dtet.c:294
funcend_getRotatedShapeMap	EQU *
funcsize_getRotatedShapeMap	EQU	funcend_getRotatedShapeMap-_getRotatedShapeMap
_createNextShape	EXPORT


*******************************************************************************

* FUNCTION createNextShape(): defined at dtet.c:328
_createNextShape	EQU	*
* Prototype: void createNextShape(unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
* Formal parameter(s):
*      5,U:    1 byte : i: unsigned char: line 328
* Line dtet.c:329: assignment: =
* Line dtet.c:329: function call: rand()
	LBSR	_rand
* Cast from `int' to byte: result already in B
	TFR	B,A		dividend expected in A by DIV8BY7
	LBSR	DIV8BY7
	TFR	A,B		resulting modulo in B
	PSHS	B
	LDB	5,U		variable i
	LEAX	_nextShape+0,PCR	address of array nextShape
	ABX			add unsigned 8-bit offset
	LDB	,S+
	STB	,X
* Line dtet.c:330: function call: memcpy()
	CLRA
	LDB	#$10		decimal 16 signed
	PSHS	B,A		C function argument 3 of memcpy(): int
* Line dtet.c:330: function call: getShapeMap()
	LDB	5,U		variable i
	LEAX	_nextShape+0,PCR	address of array nextShape
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of getShapeMap(): unsigned char
	LBSR	_getShapeMap
	LEAS	2,S
	PSHS	B,A		C function argument 2 of memcpy(): const char *
	LDB	5,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LEAX	_nextShapeMap+0,PCR	address of array nextShapeMap
	LEAX	D,X		add offset
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LBSR	_memcpy
	LEAS	6,S
* Useless label L00135 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION createNextShape(): defined at dtet.c:328
funcend_createNextShape	EQU *
funcsize_createNextShape	EQU	funcend_createNextShape-_createNextShape
_createShape	EXPORT


*******************************************************************************

* FUNCTION createShape(): defined at dtet.c:334
_createShape	EQU	*
* Prototype: void createShape(unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
* Formal parameter(s):
*      5,U:    1 byte : i: unsigned char: line 334
* Line dtet.c:337: assignment: =
* Line dtet.c:336: conditional expression
	CLRA
* optim: stripConsecutiveLoadsToSameReg
* PSHS B,A optim: optimizeStackOperations1
	LDB	5,U		variable i
	LEAX	_level+0,PCR	address of array level
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
* optim: stripExtraClrA_B
	CMPD	#9		optim: optimizeStackOperations1
	BHS	L00343		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00342 removed
	LDB	5,U		variable i
	LEAX	_level+0,PCR	address of array level
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	CLRA			promotion of binary operand
	PSHS	B,A
	LDB	#$04		optim: changeLoadDToLoadB
	LDA	1,S		load LSB of left side of multiplication
	LEAS	2,S		pop left side
	MUL			only LSB used, left in B
* optim: removePushBBeforeSubB
	CLRA
	NEGB			optim: removePushBBeforeSubB
	ADDB	#$28		optim: removePushBBeforeSubB
* optim: stripExtraClrA_B
	BRA	L00344		end of true expression of conditional
L00343	EQU	*
	LDB	#$06		optim: lddToLDB
L00344	EQU	*
	CLRA
	PSHS	B,A
	LDB	5,U		variable i
* optim: stripExtraClrA_B
	LSLB
	ROLA
	LEAX	_dropRate+0,PCR	address of array dropRate
	LEAX	D,X		add offset
	PULS	A,B		retrieve value to store
	STD	,X
* Line dtet.c:339: assignment: =
* Line dtet.c:339: conditional expression
	CLRA
* optim: stripConsecutiveLoadsToSameReg
* PSHS B,A optim: optimizeStackOperations1
	LDB	5,U		variable i
	LEAX	_nextShape+0,PCR	address of array nextShape
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
* optim: stripExtraClrA_B
	CMPD	#255		optim: optimizeStackOperations1
	BEQ	L00346		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00345 removed
	LDB	5,U		variable i
	LEAX	_nextShape+0,PCR	address of array nextShape
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	BRA	L00347		end of true expression of conditional
L00346	EQU	*
* Line dtet.c:339: function call: rand()
	LBSR	_rand
	TFR	D,X		optim: stripExtraPulsX
	CLRA
	LDB	#$07		decimal 7 signed
* optim: stripExtraPulsX
	LBSR	SDIV16
* Cast from `int' to byte: result already in B
L00347	EQU	*
	PSHS	B
	LDB	5,U		variable i
	LEAX	_shape+0,PCR	address of array shape
	ABX			add unsigned 8-bit offset
	LDB	,S+
	STB	,X
* Line dtet.c:341: assignment: =
	CLRA
	LDB	#$03		decimal 3 signed
	PSHS	B,A
	LDB	5,U		variable i
* optim: stripExtraClrA_B
	LSLB
	ROLA
	LEAX	_shapeX+0,PCR	address of array shapeX
	LEAX	D,X		add offset
	PULS	A,B		retrieve value to store
	STD	,X
* Line dtet.c:342: assignment: =
	LDD	#$FFFD		constant expression: 65533 decimal, signed
	PSHS	B,A
	LDB	5,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_shapeY+0,PCR	address of array shapeY
	LEAX	D,X		add offset
	PULS	A,B		retrieve value to store
	STD	,X
* Line dtet.c:343: assignment: =
	CLRA
	CLRB
	PSHS	B
	LDB	5,U		variable i
	LEAX	_shapeAngle+0,PCR	address of array shapeAngle
	ABX			add unsigned 8-bit offset
	LDB	,S+
	STB	,X
* Line dtet.c:344: function call: memcpy()
* optim: stripExtraClrA_B
	LDB	#$10		decimal 16 signed
	PSHS	B,A		C function argument 3 of memcpy(): int
* Line dtet.c:344: function call: getShapeMap()
	LDB	5,U		variable i
	LEAX	_shape+0,PCR	address of array shape
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
* optim: removeClr
	PSHS	B,A		C function argument 1 of getShapeMap(): unsigned char
	LBSR	_getShapeMap
	LEAS	2,S
	PSHS	B,A		C function argument 2 of memcpy(): const char *
	LDB	5,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LEAX	_shapeMap+0,PCR	address of array shapeMap
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	PSHS	B,A		C function argument 1 of memcpy(): char[]
	LBSR	_memcpy
	LEAS	6,S
* Line dtet.c:346: function call: createNextShape()
	LDB	5,U		variable `i', declared at dtet.c:334
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 1 of createNextShape(): unsigned char
	LBSR	_createNextShape
	LEAS	2,S
* Useless label L00136 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION createShape(): defined at dtet.c:334
funcend_createShape	EQU *
funcsize_createShape	EQU	funcend_createShape-_createShape
_drawShape	EXPORT


*******************************************************************************

* FUNCTION drawShape(): defined at dtet.c:350
_drawShape	EQU	*
* Prototype: void drawShape(unsigned char, unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-9,S
* Formal parameter(s):
*      5,U:    1 byte : eraseShape: unsigned char: line 350
*      7,U:    1 byte : i: unsigned char: line 350
* Local non-static variable(s):
*     -9,U:    2 bytes: x: int: line 351
*     -7,U:    2 bytes: y: int: line 351
*     -5,U:    2 bytes: blockX: int: line 351
*     -3,U:    2 bytes: blockY: int: line 351
*     -1,U:    1 byte : blockColour: char: line 352
* Line dtet.c:354: for init
* Line dtet.c:354: assignment: =
	CLRA
	CLRB
	STD	-5,U
	LBRA	L00349		jump to for condition
L00348	EQU	*
* Line dtet.c:354: for body
* Line dtet.c:355: for init
* Line dtet.c:355: assignment: =
	CLRA
	CLRB
	STD	-3,U
	LBRA	L00353		jump to for condition
L00352	EQU	*
* Line dtet.c:355: for body
* Line dtet.c:356: assignment: =
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDB	7,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_shapeX+0,PCR	address of array shapeX
* optimizeLoadDX
	LDD	D,X		get r-value
	ADDD	-5,U		optim: optimizeStackOperations4
	STD	-9,U
* Line dtet.c:357: assignment: =
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDB	7,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_shapeY+0,PCR	address of array shapeY
* optimizeLoadDX
	LDD	D,X		get r-value
	ADDD	-3,U		optim: optimizeStackOperations4
	STD	-7,U
* Line dtet.c:359: if
	LDD	-9,U		variable x
	ADDD	#0
	LBLT	L00357		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00360 removed
	LDD	-9,U		variable x
	CMPD	#$0A
	LBGE	L00357		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00359 removed
	LDD	-7,U		variable y
	ADDD	#0
	LBLT	L00357		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00358 removed
	LDD	-7,U		variable y
	CMPD	#$10
	LBGE	L00357		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00356 removed
* Line dtet.c:359
* Line dtet.c:360: if
	LDB	5,U		variable `eraseShape', declared at dtet.c:350
* optim: loadCmpZeroBeqOrBne
	BEQ	L00362		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00361 removed
* Line dtet.c:360
* Line dtet.c:362: assignment: =
	LDD	-9,U		variable `x', declared at dtet.c:351
	PSHS	B,A
	LDD	-7,U		variable `y', declared at dtet.c:351
	LBSR	MUL16BY10
	ADDD	,S++
	PSHS	B,A		preserve array index
	LDB	7,U		variable i
* optim: stripOpToDeadReg
	LDA	#160		size of array element
	MUL			get offset in bytes in D
	LEAX	_pit+0,PCR	address of array pit
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,X		get r-value
	STB	-1,U
	LBRA	L00363		jump over else clause
L00362	EQU	*		else clause of if() started at dtet.c:360
* Line dtet.c:363
* Line dtet.c:365: assignment: =
	LDD	-5,U		variable `blockX', declared at dtet.c:351
	PSHS	B,A
	LDX	-3,U		left
* optim: removeClrAFromArrayIndexMul
	LDB	#$04		right
	LBSR	MUL168
	ADDD	,S++
	PSHS	B,A		preserve array index
	LDB	7,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LEAX	_shapeMap+0,PCR	address of array shapeMap
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,X		get r-value
	STB	-1,U
* Line dtet.c:367: if
* optim: storeLoad
	CMPB	#$30
	BNE	L00365		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00364 removed
* Line dtet.c:368
* Line dtet.c:368: assignment: =
	LDD	-9,U		variable `x', declared at dtet.c:351
	PSHS	B,A
	LDD	-7,U		variable `y', declared at dtet.c:351
	LBSR	MUL16BY10
	ADDD	,S++
	PSHS	B,A		preserve array index
	LDB	7,U		variable i
* optim: stripOpToDeadReg
	LDA	#160		size of array element
	MUL			get offset in bytes in D
	LEAX	_pit+0,PCR	address of array pit
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,X		get r-value
	STB	-1,U
L00365	EQU	*		else clause of if() started at dtet.c:367
* Useless label L00366 removed
L00363	EQU	*		end of if() started at dtet.c:360
* Line dtet.c:371: function call: drawBlock()
	LDB	7,U		variable `i', declared at dtet.c:350
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 4 of drawBlock(): unsigned char
	LDB	-1,U		variable `blockColour', declared at dtet.c:352
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 3 of drawBlock(): char
	LDD	-7,U		variable `y', declared at dtet.c:351
* Cast from `int' to byte: result already in B
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawBlock(): unsigned char
	LDD	-9,U		variable `x', declared at dtet.c:351
* Cast from `int' to byte: result already in B
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 1 of drawBlock(): unsigned char
	LBSR	_drawBlock
	LEAS	8,S
L00357	EQU	*		else clause of if() started at dtet.c:359
* Useless label L00367 removed
* Useless label L00354 removed
* Line dtet.c:355: for increment(s)
	LDD	-3,U
	ADDD	#1
	STD	-3,U
L00353	EQU	*
* Line dtet.c:355: for condition
	LDD	-3,U		variable blockY
	CMPD	#$03
	LBLE	L00352
* optim: branchToNextLocation
* Useless label L00355 removed
* Useless label L00350 removed
* Line dtet.c:354: for increment(s)
	LDD	-5,U
	ADDD	#1
	STD	-5,U
L00349	EQU	*
* Line dtet.c:354: for condition
	LDD	-5,U		variable blockX
	CMPD	#$03
	LBLE	L00348
* optim: branchToNextLocation
* Useless label L00351 removed
* Useless label L00137 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION drawShape(): defined at dtet.c:350
funcend_drawShape	EQU *
funcsize_drawShape	EQU	funcend_drawShape-_drawShape
_removeFullRow	EXPORT


*******************************************************************************

* FUNCTION removeFullRow(): defined at dtet.c:378
_removeFullRow	EQU	*
* Prototype: void removeFullRow(unsigned char, unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-4,S
* Formal parameter(s):
*      5,U:    1 byte : removedRow: unsigned char: line 378
*      7,U:    1 byte : i: unsigned char: line 378
* Local non-static variable(s):
*     -4,U:    1 byte : j: unsigned char: line 388
*     -3,U:    1 byte : x: unsigned char: line 379
*     -2,U:    1 byte : y: unsigned char: line 379
*     -1,U:    1 byte : blockColour: char: line 380
* Line dtet.c:383: for init
* Line dtet.c:383: assignment: =
	LDB	7,U		variable i
	LEAX	_pitLeft+0,PCR	address of array pitLeft
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	PSHS	B
	CLRA
	CLRB
	ADDB	,S+
	STB	-3,U
	BRA	L00369		jump to for condition
L00368	EQU	*
* Line dtet.c:384: for body
* Line dtet.c:384: function call: printBlock()
	CLRA
	LDB	#$CF		decimal 207 signed
	PSHS	B,A		C function argument 3 of printBlock(): int
	LDB	5,U		variable `removedRow', declared at dtet.c:378
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 2 of printBlock(): unsigned char
	LDB	-3,U		variable `x', declared at dtet.c:379
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of printBlock(): unsigned char
	LBSR	_printBlock
	LEAS	6,S
* Useless label L00370 removed
* Line dtet.c:383: for increment(s)
	INC	-3,U
L00369	EQU	*
* Line dtet.c:383: for condition
	LDB	7,U		variable i
	LEAX	_pitLeft+0,PCR	address of array pitLeft
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	PSHS	B
	CLRA
	LDB	#$0A		decimal 10 signed
	ADDB	,S+
	PSHS	B
	LDB	-3,U		variable `x', declared at dtet.c:379
	CMPB	,S+		compare with LSB
	BLO	L00368
* optim: branchToNextLocation
* Useless label L00371 removed
* Line dtet.c:387: if
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:102
* optim: loadCmpZeroBeqOrBne
	BNE	L00373
* optim: branchToNextLocation
* Useless label L00372 removed
* Line dtet.c:389
* Line dtet.c:388: for init
* Line dtet.c:388: init of variable j
	LDB	#$FF		255
	STB	-4,U		variable j
	BRA	L00375		jump to for condition
L00374	EQU	*
* Line dtet.c:389: for body
* Line dtet.c:389: function call: sound()
	CLRA
	CLRB
	PSHS	B,A		C function argument 2 of sound(): int
	LDB	-4,U		variable `j', declared at dtet.c:388
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of sound(): unsigned char
	LBSR	_sound
	LEAS	4,S
* Useless label L00376 removed
* Line dtet.c:388: for increment(s)
* Line dtet.c:388: assignment: =
	LDB	-4,U		variable j
	ADDB	#$FB		251
	STB	-4,U
L00375	EQU	*
* Line dtet.c:388: for condition
	LDB	-4,U		variable j
	CMPB	#$3C
	BHI	L00374
* optim: branchToNextLocation
* Useless label L00377 removed
L00373	EQU	*		else clause of if() started at dtet.c:387
* Useless label L00378 removed
* Line dtet.c:392: for init
* Line dtet.c:392: assignment: =
	LDB	5,U		variable `removedRow', declared at dtet.c:378
	STB	-2,U
	LBRA	L00380		jump to for condition
L00379	EQU	*
* Line dtet.c:392: for body
* Line dtet.c:393: for init
* Line dtet.c:393: assignment: =
	CLRB
	STB	-3,U		variable x
	LBRA	L00384		jump to for condition
L00383	EQU	*
* Line dtet.c:393: for body
* Line dtet.c:395: assignment: =
	LDB	-3,U		variable `x', declared at dtet.c:379
	PSHS	B
	LDB	-2,U		variable y
	ADDB	#$FF		255
	CLRA			promotion of binary operand
	PSHS	B,A
	LDB	#$0A		optim: changeLoadDToLoadB
	LDA	1,S		load LSB of left side of multiplication
	LEAS	2,S		pop left side
	MUL			only LSB used, left in B
	ADDB	,S+
	CLRA			extend byte index expression
	PSHS	B,A		preserve array index
	LDB	7,U		variable i
* optim: stripExtraClrA_B
	LDA	#160		size of array element
	MUL			get offset in bytes in D
	LEAX	_pit+0,PCR	address of array pit
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,X		get r-value
	STB	-1,U
* Line dtet.c:396: assignment: =
* optim: storeLoad
	PSHS	B
	LDB	-3,U		variable `x', declared at dtet.c:379
	PSHS	B
	LDA	-2,U
	LDB	#$0A
	MUL			result of type byte in B
	ADDB	,S+
	CLRA			extend byte index expression
	PSHS	B,A		preserve array index
	LDB	7,U		variable i
* optim: stripExtraClrA_B
	LDA	#160		size of array element
	MUL			get offset in bytes in D
	LEAX	_pit+0,PCR	address of array pit
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,S+
	STB	,X
* Useless label L00385 removed
* Line dtet.c:393: for increment(s)
	INC	-3,U
L00384	EQU	*
* Line dtet.c:393: for condition
	LDB	-3,U		variable x
	CMPB	#$0A
	LBLO	L00383
* optim: branchToNextLocation
* Useless label L00386 removed
* Useless label L00381 removed
* Line dtet.c:392: for increment(s)
	DEC	-2,U
L00380	EQU	*
* Line dtet.c:392: for condition
	LDB	-2,U		variable y
* optim: removeCMPZeroAfterLDIfBHI (BHI->BNE)
	LBNE	L00379
* optim: branchToNextLocation
* Useless label L00382 removed
* Line dtet.c:400: for init
* Line dtet.c:400: assignment: =
	CLRB
	STB	-3,U		variable x
	BRA	L00388		jump to for condition
L00387	EQU	*
* Line dtet.c:401: for body
* Line dtet.c:401: assignment: =
* LDB #$30 optim: optimizeStackOperations1
* PSHS B optim: optimizeStackOperations1
	LDB	-3,U		variable x
	CLRA			extend byte index expression
	PSHS	B,A		preserve array index
	LDB	7,U		variable i
* optim: stripExtraClrA_B
	LDA	#160		size of array element
	MUL			get offset in bytes in D
	LEAX	_pit+0,PCR	address of array pit
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	#48		optim: optimizeStackOperations1
	STB	,X
* Useless label L00389 removed
* Line dtet.c:400: for increment(s)
	INC	-3,U
L00388	EQU	*
* Line dtet.c:400: for condition
	LDB	-3,U		variable x
	CMPB	#$0A
	BLO	L00387
* optim: branchToNextLocation
* Useless label L00390 removed
* Useless label L00138 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION removeFullRow(): defined at dtet.c:378
funcend_removeFullRow	EQU *
funcsize_removeFullRow	EQU	funcend_removeFullRow-_removeFullRow
_setTrapLine	EXPORT


*******************************************************************************

* FUNCTION setTrapLine(): defined at dtet.c:405
_setTrapLine	EQU	*
* Prototype: void setTrapLine(unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-3,S
* Formal parameter(s):
*      5,U:    1 byte : i: unsigned char: line 405
* Local non-static variable(s):
*     -3,U:    1 byte : x: unsigned char: line 406
*     -2,U:    1 byte : y: unsigned char: line 406
*     -1,U:    1 byte : emptyX: unsigned char: line 406
* Line dtet.c:409: if
	LDB	_numPlayers+0,PCR	variable numPlayers
	CMPB	#$01
	BNE	L00392		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00391 removed
* Line dtet.c:409
* Line dtet.c:410: assignment: =
* optim: optimize8BitStackOps
* optim: optimize8BitStackOps
	CLRA
	LDB	#$01		decimal 1 signed
	SUBB	5,U		optim: optimize8BitStackOps
	STB	5,U
* Line dtet.c:411: if
* optim: storeLoad
	LEAX	_gameOver+0,PCR	address of array gameOver
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
* optim: loadCmpZeroBeqOrBne
	LBNE	L00139		 (optim: condBranchOverUncondBranch) (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00393 removed
* Line dtet.c:412
* optim: condBranchOverUncondBranch
* Useless label L00394 removed
* Useless label L00395 removed
L00392	EQU	*		else clause of if() started at dtet.c:409
* Useless label L00396 removed
* Line dtet.c:416: assignment: =
* Line dtet.c:416: function call: rand()
	LBSR	_rand
* Cast from `int' to byte: result already in B
	TFR	B,A		dividend expected in A
	LDB	#$0A		divisor
	LBSR	DIV8
	TFR	A,B		resulting modulo in B
	STB	-1,U
* Line dtet.c:419: for init
* Line dtet.c:419: assignment: =
	LDB	#$01
	STB	-2,U		variable y
	LBRA	L00398		jump to for condition
L00397	EQU	*
* Line dtet.c:421: for body
* Line dtet.c:420: for init
* Line dtet.c:420: assignment: =
	CLRB
	STB	-3,U		variable x
	LBRA	L00402		jump to for condition
L00401	EQU	*
* Line dtet.c:421: for body
* Line dtet.c:421: assignment: =
	LDB	-3,U		variable `x', declared at dtet.c:406
	PSHS	B
	LDA	-2,U
	LDB	#$0A
	MUL			result of type byte in B
	ADDB	,S+
	CLRA			extend byte index expression
	PSHS	B,A		preserve array index
	LDB	5,U		variable i
* optim: stripExtraClrA_B
	LDA	#160		size of array element
	MUL			get offset in bytes in D
	LEAX	_pit+0,PCR	address of array pit
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,X		get r-value
	PSHS	B
	LDB	-3,U		variable `x', declared at dtet.c:406
	PSHS	B
	LDB	-2,U		variable y
	ADDB	#$FF		255
	CLRA			promotion of binary operand
	PSHS	B,A
	LDB	#$0A		optim: changeLoadDToLoadB
	LDA	1,S		load LSB of left side of multiplication
	LEAS	2,S		pop left side
	MUL			only LSB used, left in B
	ADDB	,S+
	CLRA			extend byte index expression
	PSHS	B,A		preserve array index
	LDB	5,U		variable i
* optim: stripExtraClrA_B
	LDA	#160		size of array element
	MUL			get offset in bytes in D
	LEAX	_pit+0,PCR	address of array pit
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,S+
	STB	,X
* Useless label L00403 removed
* Line dtet.c:420: for increment(s)
	INC	-3,U
L00402	EQU	*
* Line dtet.c:420: for condition
	LDB	-3,U		variable x
	CMPB	#$0A
	LBLO	L00401
* optim: branchToNextLocation
* Useless label L00404 removed
* Useless label L00399 removed
* Line dtet.c:419: for increment(s)
	INC	-2,U
L00398	EQU	*
* Line dtet.c:419: for condition
	LDB	-2,U		variable y
	CMPB	#$10
	LBLO	L00397
* optim: branchToNextLocation
* Useless label L00400 removed
* Line dtet.c:424: for init
* Line dtet.c:424: assignment: =
	CLRB
	STB	-3,U		variable x
	BRA	L00406		jump to for condition
L00405	EQU	*
* Line dtet.c:425: for body
* Line dtet.c:425: assignment: =
* Line dtet.c:425: conditional expression
	LDB	-3,U		variable x
	CMPB	-1,U		variable emptyX
	BNE	L00410		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00409 removed
	LDB	#$30		decimal 48 signed
	BRA	L00411		end of true expression of conditional
L00410	EQU	*
	LDB	#$35		decimal 53 signed
L00411	EQU	*
	PSHS	B
	LDB	-3,U		variable x
	ADDB	#$96		150
	CLRA			extend byte index expression
	PSHS	B,A		preserve array index
	LDB	5,U		variable i
* optim: stripExtraClrA_B
	LDA	#160		size of array element
	MUL			get offset in bytes in D
	LEAX	_pit+0,PCR	address of array pit
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,S+
	STB	,X
* Useless label L00407 removed
* Line dtet.c:424: for increment(s)
	INC	-3,U
L00406	EQU	*
* Line dtet.c:424: for condition
	LDB	-3,U		variable x
	CMPB	#$0A
	BLO	L00405
* optim: branchToNextLocation
* Useless label L00408 removed
* Line dtet.c:428: if
	LDB	_numPlayers+0,PCR	variable numPlayers
* optim: removeCMPZeroAfterLDIfBHI (BHI->BNE)
	BEQ	L00413		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00412 removed
* Line dtet.c:428
* Line dtet.c:428: function call: drawPit()
	LDB	5,U		variable `i', declared at dtet.c:405
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 1 of drawPit(): unsigned char
	LBSR	_drawPit
	LEAS	2,S
L00413	EQU	*		else clause of if() started at dtet.c:428
* Useless label L00414 removed
* Line dtet.c:430: if
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:102
* optim: loadCmpZeroBeqOrBne
	BNE	L00416
* optim: branchToNextLocation
* Useless label L00415 removed
* Line dtet.c:430
* Line dtet.c:430: function call: sound()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 2 of sound(): int
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of sound(): int
	LBSR	_sound
	LEAS	4,S
L00416	EQU	*		else clause of if() started at dtet.c:430
* Useless label L00417 removed
L00139	EQU	*		end of setTrapLine()
	LEAS	,U
	PULS	U,PC
* END FUNCTION setTrapLine(): defined at dtet.c:405
funcend_setTrapLine	EQU *
funcsize_setTrapLine	EQU	funcend_setTrapLine-_setTrapLine
_setTrapBlock	EXPORT


*******************************************************************************

* FUNCTION setTrapBlock(): defined at dtet.c:434
_setTrapBlock	EQU	*
* Prototype: void setTrapBlock(unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-6,S
* Formal parameter(s):
*      5,U:    1 byte : i: unsigned char: line 434
* Local non-static variable(s):
*     -6,U:    2 bytes: x: int: line 435
*     -4,U:    2 bytes: y: int: line 435
*     -2,U:    1 byte : rowEmpty: unsigned char: line 436
*     -1,U:    1 byte : attempts: unsigned char: line 436
* Line dtet.c:436: init of variable attempts
	LDB	#$05		5
	STB	-1,U		variable attempts
* Line dtet.c:439: if
	LDB	_numPlayers+0,PCR	variable numPlayers
	CMPB	#$01
	LBNE	L00425		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00418 removed
* Line dtet.c:439
* Line dtet.c:440: assignment: =
* optim: optimize8BitStackOps
* optim: optimize8BitStackOps
	CLRA
	LDB	#$01		decimal 1 signed
	SUBB	5,U		optim: optimize8BitStackOps
	STB	5,U
* Line dtet.c:441: if
* optim: storeLoad
	LEAX	_gameOver+0,PCR	address of array gameOver
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
* optim: loadCmpZeroBeqOrBne
	LBNE	L00140		 (optim: condBranchOverUncondBranch) (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00420 removed
* Line dtet.c:442
* optim: condBranchOverUncondBranch
* Useless label L00421 removed
* Useless label L00422 removed
* Useless label L00419 removed
* Useless label L00423 removed
* Line dtet.c:445: while
	LBRA	L00425		jump to while condition
L00424	EQU	*		while body
* Line dtet.c:447: assignment: =
* Line dtet.c:447: function call: rand()
	LBSR	_rand
	TFR	D,X		optim: stripExtraPulsX
	CLRA
	LDB	#$0B		constant expression: 11 decimal, signed
* optim: stripExtraPulsX
	LBSR	SDIV16
	ADDD	#$05		optim: pushDLoadAdd
* 
* 
	STD	-4,U
* Line dtet.c:449: assignment: =
	LDB	#$01
	STB	-2,U		variable rowEmpty
* Line dtet.c:450: for init
* Line dtet.c:450: assignment: =
	CLRA
	CLRB
	STD	-6,U
	BRA	L00428		jump to for condition
L00427	EQU	*
* Line dtet.c:456: for body
* Line dtet.c:451: if
	LDD	-6,U		variable `x', declared at dtet.c:435
	PSHS	B,A
	LDD	-4,U		variable `y', declared at dtet.c:435
	LBSR	MUL16BY10
	ADDD	,S++
	PSHS	B,A		preserve array index
	LDB	5,U		variable i
* optim: stripOpToDeadReg
	LDA	#160		size of array element
	MUL			get offset in bytes in D
	LEAX	_pit+0,PCR	address of array pit
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,X		get r-value
	CMPB	#48
	BEQ	L00432		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00431 removed
* Line dtet.c:451
* Line dtet.c:452: assignment: =
	CLR	-2,U		variable rowEmpty
	BRA	L00430		break
L00432	EQU	*		else clause of if() started at dtet.c:451
* Useless label L00433 removed
* Useless label L00429 removed
* Line dtet.c:450: for increment(s)
	LDD	-6,U
	ADDD	#1
	STD	-6,U
L00428	EQU	*
* Line dtet.c:450: for condition
	LDD	-6,U		variable x
	CMPD	#$0A
	BLT	L00427
* optim: branchToNextLocation
L00430	EQU	*		end for
* Line dtet.c:456: if
	LDB	-2,U		variable `rowEmpty', declared at dtet.c:436
* optim: loadCmpZeroBeqOrBne
	LBEQ	L00435		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00434 removed
* Line dtet.c:456
* Line dtet.c:457: assignment: =
* Line dtet.c:457: function call: rand()
	LBSR	_rand
	TFR	D,X		optim: stripExtraPulsX
	CLRA
	LDB	#$0A		decimal 10 signed
* optim: stripExtraPulsX
	LBSR	SDIV16
	STD	-6,U
* Line dtet.c:458: assignment: =
	CLRA
	LDB	#$05		decimal 5 signed
	PSHS	B
	LDD	-6,U		variable `x', declared at dtet.c:435
	PSHS	B,A
	LDD	-4,U		variable `y', declared at dtet.c:435
	LBSR	MUL16BY10
	ADDD	,S++
	PSHS	B,A		preserve array index
	LDB	5,U		variable i
* optim: stripOpToDeadReg
	LDA	#160		size of array element
	MUL			get offset in bytes in D
	LEAX	_pit+0,PCR	address of array pit
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,S+
	STB	,X
* Line dtet.c:460: if
	LDB	_numPlayers+0,PCR	variable numPlayers
* optim: removeCMPZeroAfterLDIfBHI (BHI->BNE)
	BEQ	L00437		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00436 removed
* Line dtet.c:460
* Line dtet.c:460: function call: printBlock()
	LDX	#$CF		optim: transformPshsDPshsD
* optim: mergePushXPushD
	LDD	-4,U		variable `y', declared at dtet.c:435
	PSHS	X,B,A		optim: mergePushXPushD
	LDB	5,U		variable i
	LEAX	_pitLeft+0,PCR	address of array pitLeft
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	CLRA			promotion of binary operand
	ADDD	-6,U		optim: pushDLoadAdd
* 
* 
	PSHS	B,A		C function argument 1 of printBlock(): int
	LBSR	_printBlock
	LEAS	6,S
L00437	EQU	*		else clause of if() started at dtet.c:460
* Useless label L00438 removed
* Line dtet.c:462: if
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:102
* optim: loadCmpZeroBeqOrBne
	BNE	L00140
* optim: branchToNextLocation
* Useless label L00439 removed
* Line dtet.c:462
* Line dtet.c:462: function call: sound()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 2 of sound(): int
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of sound(): int
	LBSR	_sound
	LEAS	4,S
* Useless label L00440 removed
* Useless label L00441 removed
	BRA	L00140		return (dtet.c:463)
L00435	EQU	*		else clause of if() started at dtet.c:456
* Useless label L00442 removed
* Line dtet.c:465: post-decrement
	DEC	-1,U
L00425	EQU	*		while condition at dtet.c:445
	LDB	-1,U		variable attempts
* optim: removeCMPZeroAfterLDIfBHI (BHI->BNE)
	LBNE	L00424
* optim: branchToNextLocation
* Useless label L00426 removed
L00140	EQU	*		end of setTrapBlock()
	LEAS	,U
	PULS	U,PC
* END FUNCTION setTrapBlock(): defined at dtet.c:434
funcend_setTrapBlock	EQU *
funcsize_setTrapBlock	EQU	funcend_setTrapBlock-_setTrapBlock
_checkForFullRows	EXPORT


*******************************************************************************

* FUNCTION checkForFullRows(): defined at dtet.c:470
_checkForFullRows	EQU	*
* Prototype: void checkForFullRows(unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-13,S
* Formal parameter(s):
*      5,U:    1 byte : i: unsigned char: line 470
* Local non-static variable(s):
*    -13,U:    8 bytes: pointsPerLine: const int[]: line 495
*     -5,U:    1 byte : fullRow: unsigned char: line 471
*     -4,U:    1 byte : numLines: unsigned char: line 472
*     -3,U:    1 byte : x: unsigned char: line 473
*     -2,U:    1 byte : y: unsigned char: line 473
*     -1,U:    1 byte : j: unsigned char: line 474
* Line dtet.c:472: init of variable numLines
	CLR	-4,U		variable numLines
* Line dtet.c:474: init of variable j
	LDB	5,U		variable i
	ADDB	#$06		6
	STB	-1,U		variable j
* Line dtet.c:476: for init
* Line dtet.c:476: assignment: =
	CLRB
	STB	-2,U		variable y
	LBRA	L00444		jump to for condition
L00443	EQU	*
* Line dtet.c:476: for body
* Line dtet.c:477: assignment: =
	LDB	#$01
	STB	-5,U		variable fullRow
* Line dtet.c:479: for init
* Line dtet.c:479: assignment: =
	CLRB
	STB	-3,U		variable x
	BRA	L00448		jump to for condition
L00447	EQU	*
* Line dtet.c:479: for body
* Line dtet.c:480: if
* optim: optimize8BitStackOps
* optim: optimize8BitStackOps
	LDA	-2,U
	LDB	#$0A
	MUL			result of type byte in B
	ADDB	-3,U		optim: optimize8BitStackOps
	CLRA			extend byte index expression
	PSHS	B,A		preserve array index
	LDB	5,U		variable i
* optim: stripExtraClrA_B
	LDA	#160		size of array element
	MUL			get offset in bytes in D
	LEAX	_pit+0,PCR	address of array pit
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,X		get r-value
	CMPB	#48
	BNE	L00452		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00451 removed
* Line dtet.c:480
* Line dtet.c:481: assignment: =
	CLR	-5,U		variable fullRow
	BRA	L00450		break
L00452	EQU	*		else clause of if() started at dtet.c:480
* Useless label L00453 removed
* Useless label L00449 removed
* Line dtet.c:479: for increment(s)
	INC	-3,U
L00448	EQU	*
* Line dtet.c:479: for condition
	LDB	-3,U		variable x
	CMPB	#$0A
	BLO	L00447
* optim: branchToNextLocation
L00450	EQU	*		end for
* Line dtet.c:486: if
	LDB	-5,U		variable `fullRow', declared at dtet.c:471
* optim: loadCmpZeroBeqOrBne
	BEQ	L00455		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00454 removed
* Line dtet.c:486
* Line dtet.c:487: function call: removeFullRow()
	LDB	5,U		variable `i', declared at dtet.c:470
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of removeFullRow(): unsigned char
	LDB	-2,U		variable `y', declared at dtet.c:473
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of removeFullRow(): unsigned char
	LBSR	_removeFullRow
	LEAS	4,S
* Line dtet.c:488: post-increment
	INC	-4,U
* Line dtet.c:489: if
	LDB	_numPlayers+0,PCR	variable numPlayers
* optim: removeCMPZeroAfterLDIfBHI (BHI->BNE)
	BEQ	L00457		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00458 removed
	CLRA
* optim: stripConsecutiveLoadsToSameReg
* PSHS B,A optim: optimizeStackOperations1
	LDB	5,U		variable i
	LEAX	_level+0,PCR	address of array level
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
* optim: stripExtraClrA_B
	CMPD	#3		optim: optimizeStackOperations1
	BLS	L00457		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00456 removed
* Line dtet.c:490
* Line dtet.c:490: post-increment
	LDB	5,U		variable i
	LEAX	_linesPiecesPlayed+0,PCR	address of array linesPiecesPlayed
	ABX			add unsigned 8-bit offset
	INC	,X
L00457	EQU	*		else clause of if() started at dtet.c:489
* Useless label L00459 removed
L00455	EQU	*		else clause of if() started at dtet.c:486
* Useless label L00460 removed
* Useless label L00445 removed
* Line dtet.c:476: for increment(s)
	INC	-2,U
L00444	EQU	*
* Line dtet.c:476: for condition
	LDB	-2,U		variable y
	CMPB	#$10
	LBLO	L00443
* optim: branchToNextLocation
* Useless label L00446 removed
* Line dtet.c:494: if
	LDB	-4,U		variable numLines
* optim: removeCMPZeroAfterLDIfBHI (BHI->BNE)
	LBEQ	L00462		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00461 removed
* Line dtet.c:494
* Line dtet.c:495: init of variable pointsPerLine
	CLRA
	LDB	#$64		decimal 100 signed
	STD	-13,U		offset in variable pointsPerLine
	LDD	#$012C		decimal 300 signed
	STD	-11,U		offset in variable pointsPerLine
	LDD	#$01F4		decimal 500 signed
	STD	-9,U		offset in variable pointsPerLine
	LDD	#$0320		decimal 800 signed
	STD	-7,U		offset in variable pointsPerLine
* Line dtet.c:496: assignment: =
	LDB	-4,U		variable numLines
	ADDB	#$FF		255
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	-13,U		address of array pointsPerLine
* optimizeLoadDX
	LDD	D,X		get r-value
	PSHS	B,A
	LDB	5,U		variable i
	LEAX	_level+0,PCR	address of array level
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	CLRA			promotion of binary operand
	PULS	X
	LBSR	MUL16
	STD	_lastPoints+0,PCR
* Line dtet.c:499: assignment: +=
* optim: storeLoad
	PSHS	B,A
	LDB	-1,U		variable j
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_scores+0,PCR	address of array scores
	LEAX	D,X		add offset
	LDD	,X
	ADDD	,S++
	STD	,X
* Line dtet.c:500: assignment: +=
	LDB	-4,U		variable `numLines', declared at dtet.c:472
	CLRA
	PSHS	B,A
	LDB	5,U		variable i
* optim: stripExtraClrA_B
	LSLB
	ROLA
	LEAX	_lines+0,PCR	address of array lines
	LEAX	D,X		add offset
	LDD	,X
	ADDD	,S++
	STD	,X
* Line dtet.c:501: assignment: =
	LDB	-4,U		variable `numLines', declared at dtet.c:472
	STB	_lastLines+0,PCR
* Line dtet.c:502: assignment: =
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B
	LDB	5,U		variable i
* optim: stripExtraClrA_B
	LSLB
	ROLA
	LEAX	_lines+0,PCR	address of array lines
* optimizeLoadDX
	LDD	D,X		get r-value
	TFR	D,X		optim: stripExtraPulsX
	CLRA
	LDB	#$04		decimal 4 signed
* optim: stripExtraPulsX
	LBSR	SDIV16
	TFR	X,D		quotient
* Cast from `int' to byte: result already in B
	ADDB	,S+
	PSHS	B
	LDB	5,U		variable i
	LEAX	_level+0,PCR	address of array level
	ABX			add unsigned 8-bit offset
	LDB	,S+
	STB	,X
* Line dtet.c:505: if
	LDB	5,U		variable i
	LEAX	_level+0,PCR	address of array level
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	PSHS	B
	LDB	5,U		variable i
	LEAX	_previousLevel+0,PCR	address of array previousLevel
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	CMPB	,S+		compare with LSB
	LBHS	L00464		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00463 removed
* Line dtet.c:505
* Line dtet.c:506: assignment: =
	LDB	5,U		variable i
	LEAX	_level+0,PCR	address of array level
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	PSHS	B
	LDB	5,U		variable i
	LEAX	_previousLevel+0,PCR	address of array previousLevel
	ABX			add unsigned 8-bit offset
	LDB	,S+
	STB	,X
* Line dtet.c:508: if
	LDB	_emptyBackground+0,PCR	variable `emptyBackground', declared at dtet.c:101
* optim: loadCmpZeroBeqOrBne
	BNE	L00466
* optim: branchToNextLocation
* Useless label L00467 removed
	CLRA
* optim: stripConsecutiveLoadsToSameReg
* PSHS B,A optim: optimizeStackOperations1
	LDB	5,U		variable i
	LEAX	_level+0,PCR	address of array level
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
* optim: stripExtraClrA_B
	CMPD	#9		optim: optimizeStackOperations1
	BHS	L00466		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00465 removed
* Line dtet.c:509
* Line dtet.c:509: assignment: =
	CLRA
* LDB #$01 optim: optimizeStackOperations1
* PSHS B optim: optimizeStackOperations1
	LDB	5,U		variable i
	LEAX	_level+0,PCR	address of array level
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	SUBB	#1		optim: optimizeStackOperations1
	LEAX	_backgroundCharList+0,PCR	address of array backgroundCharList
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	PSHS	B
	LDB	5,U		variable i
	LEAX	_backgroundChar+0,PCR	address of array backgroundChar
	ABX			add unsigned 8-bit offset
	LDB	,S+
	STB	,X
L00466	EQU	*		else clause of if() started at dtet.c:508
* Useless label L00468 removed
* Line dtet.c:511: if
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:102
* optim: loadCmpZeroBeqOrBne
	BNE	L00470
* optim: branchToNextLocation
* Useless label L00469 removed
* Line dtet.c:511
* Line dtet.c:512: function call: sound()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 2 of sound(): int
* optim: stripExtraClrA_B
	LDB	#$E6		decimal 230 signed
	PSHS	B,A		C function argument 1 of sound(): int
	LBSR	_sound
	LEAS	4,S
* Line dtet.c:513: function call: sound()
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A		C function argument 2 of sound(): int
* optim: stripExtraClrA_B
	LDB	#$DC		decimal 220 signed
	PSHS	B,A		C function argument 1 of sound(): int
	LBSR	_sound
	LEAS	4,S
L00470	EQU	*		else clause of if() started at dtet.c:511
* Useless label L00471 removed
L00464	EQU	*		else clause of if() started at dtet.c:505
* Useless label L00472 removed
L00462	EQU	*		else clause of if() started at dtet.c:494
* Useless label L00473 removed
* Line dtet.c:518: if
	LDB	_numPlayers+0,PCR	variable `numPlayers', declared at dtet.c:84
* optim: loadCmpZeroBeqOrBne
	BNE	L00475		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00476 removed
	CLRA
* optim: stripConsecutiveLoadsToSameReg
* PSHS B,A optim: optimizeStackOperations1
	LDB	_linesPiecesPlayed+0,PCR	index 0 in array linesPiecesPlayed[]
* optim: stripExtraClrA_B
	CMPD	#12		optim: optimizeStackOperations1
	BLO	L00475		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00474 removed
* Line dtet.c:518
* Line dtet.c:519: if
	CLRA
* optim: stripConsecutiveLoadsToSameReg
* PSHS B,A optim: optimizeStackOperations1
	LDB	_level+0,PCR	index 0 in array level[]
* optim: stripExtraClrA_B
	CMPD	#5		optim: optimizeStackOperations1
	BLS	L00478		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00477 removed
* Line dtet.c:519
* Line dtet.c:519: function call: setTrapBlock()
	CLRA
	CLRB
	PSHS	B,A		C function argument 1 of setTrapBlock(): int
	LBSR	_setTrapBlock
	LEAS	2,S
	BRA	L00479		jump over else clause
L00478	EQU	*		else clause of if() started at dtet.c:519
* Line dtet.c:521
* Line dtet.c:520: if
	CLRA
* optim: stripConsecutiveLoadsToSameReg
* PSHS B,A optim: optimizeStackOperations1
	LDB	_level+0,PCR	index 0 in array level[]
* optim: stripExtraClrA_B
	CMPD	#3		optim: optimizeStackOperations1
	BLS	L00481		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00480 removed
* Line dtet.c:520
* Line dtet.c:520: function call: setTrapLine()
	CLRA
	CLRB
	PSHS	B,A		C function argument 1 of setTrapLine(): int
	LBSR	_setTrapLine
	LEAS	2,S
L00481	EQU	*		else clause of if() started at dtet.c:520
* Useless label L00482 removed
L00479	EQU	*		end of if() started at dtet.c:519
* Line dtet.c:521: assignment: =
	CLRA
* CLRB  optim: optimizeStackOperations1
* PSHS B optim: optimizeStackOperations1
* optim: optimizeLeax
	LDB	#0		optim: optimizeStackOperations1
	STB	_linesPiecesPlayed+0,PCR	optim: optimizeLeax
	LBRA	L00483		jump over else clause
L00475	EQU	*		else clause of if() started at dtet.c:518
* Line dtet.c:529
* Line dtet.c:524: if
	LDB	_numPlayers+0,PCR	variable numPlayers
* optim: removeCMPZeroAfterLDIfBHI (BHI->BNE)
	LBEQ	L00485		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00486 removed
	CLRA
* optim: stripConsecutiveLoadsToSameReg
* PSHS B,A optim: optimizeStackOperations1
	LDB	5,U		variable i
	LEAX	_linesPiecesPlayed+0,PCR	address of array linesPiecesPlayed
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
* optim: stripExtraClrA_B
	CMPD	#3		optim: optimizeStackOperations1
	BLO	L00485		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00484 removed
* Line dtet.c:524
* Line dtet.c:525: if
	CLRA
* optim: stripConsecutiveLoadsToSameReg
* PSHS B,A optim: optimizeStackOperations1
	LDB	5,U		variable i
	LEAX	_level+0,PCR	address of array level
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
* optim: stripExtraClrA_B
	CMPD	#5		optim: optimizeStackOperations1
	BLS	L00488		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00487 removed
* Line dtet.c:525
* Line dtet.c:525: function call: setTrapBlock()
	LDB	5,U		variable `i', declared at dtet.c:470
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 1 of setTrapBlock(): unsigned char
	LBSR	_setTrapBlock
	LEAS	2,S
	BRA	L00489		jump over else clause
L00488	EQU	*		else clause of if() started at dtet.c:525
* Line dtet.c:527
* Line dtet.c:526: if
	CLRA
* optim: stripConsecutiveLoadsToSameReg
* PSHS B,A optim: optimizeStackOperations1
	LDB	5,U		variable i
	LEAX	_level+0,PCR	address of array level
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
* optim: stripExtraClrA_B
	CMPD	#3		optim: optimizeStackOperations1
	BLS	L00491		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00490 removed
* Line dtet.c:526
* Line dtet.c:526: function call: setTrapLine()
	LDB	5,U		variable `i', declared at dtet.c:470
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 1 of setTrapLine(): unsigned char
	LBSR	_setTrapLine
	LEAS	2,S
L00491	EQU	*		else clause of if() started at dtet.c:526
* Useless label L00492 removed
L00489	EQU	*		end of if() started at dtet.c:525
* Line dtet.c:527: assignment: =
	CLRA
* CLRB  optim: optimizeStackOperations1
* PSHS B optim: optimizeStackOperations1
	LDB	5,U		variable i
	LEAX	_linesPiecesPlayed+0,PCR	address of array linesPiecesPlayed
	ABX			add unsigned 8-bit offset
	LDB	#0		optim: optimizeStackOperations1
	STB	,X
L00485	EQU	*		else clause of if() started at dtet.c:524
* Useless label L00493 removed
L00483	EQU	*		end of if() started at dtet.c:518
* Useless label L00141 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION checkForFullRows(): defined at dtet.c:470
funcend_checkForFullRows	EQU *
funcsize_checkForFullRows	EQU	funcend_checkForFullRows-_checkForFullRows
_settleActiveShapeInPit	EXPORT


*******************************************************************************

* FUNCTION settleActiveShapeInPit(): defined at dtet.c:532
_settleActiveShapeInPit	EQU	*
* Prototype: void settleActiveShapeInPit(unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-9,S
* Formal parameter(s):
*      5,U:    1 byte : i: unsigned char: line 532
* Local non-static variable(s):
*     -9,U:    2 bytes: x: int: line 533
*     -7,U:    2 bytes: y: int: line 533
*     -5,U:    2 bytes: blockX: int: line 533
*     -3,U:    2 bytes: blockY: int: line 533
*     -1,U:    1 byte : blockColour: char: line 534
* Line dtet.c:535: for init
* Line dtet.c:535: assignment: =
	CLRA
	CLRB
	STD	-3,U
	LBRA	L00495		jump to for condition
L00494	EQU	*
* Line dtet.c:535: for body
* Line dtet.c:536: for init
* Line dtet.c:536: assignment: =
	CLRA
	CLRB
	STD	-5,U
	LBRA	L00499		jump to for condition
L00498	EQU	*
* Line dtet.c:536: for body
* Line dtet.c:537: assignment: =
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDB	5,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_shapeX+0,PCR	address of array shapeX
* optimizeLoadDX
	LDD	D,X		get r-value
	ADDD	-5,U		optim: optimizeStackOperations4
	STD	-9,U
* Line dtet.c:538: assignment: =
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDB	5,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_shapeY+0,PCR	address of array shapeY
* optimizeLoadDX
	LDD	D,X		get r-value
	ADDD	-3,U		optim: optimizeStackOperations4
	STD	-7,U
* Line dtet.c:539: assignment: =
	LDD	-5,U		variable `blockX', declared at dtet.c:533
	PSHS	B,A
	LDX	-3,U		left
* optim: removeClrAFromArrayIndexMul
	LDB	#$04		right
	LBSR	MUL168
	ADDD	,S++
	PSHS	B,A		preserve array index
	LDB	5,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LEAX	_shapeMap+0,PCR	address of array shapeMap
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,X		get r-value
	STB	-1,U
* Line dtet.c:541: if
* optim: storeLoad
	CMPB	#$30
	BEQ	L00503		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00507 removed
	LDD	-9,U		variable x
	ADDD	#0
	BLT	L00503		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00506 removed
	LDD	-9,U		variable x
	CMPD	#$0A
	BGE	L00503		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00505 removed
	LDD	-7,U		variable y
	ADDD	#0
	BLT	L00503		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00504 removed
	LDD	-7,U		variable y
	CMPD	#$10
	BGE	L00503		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00502 removed
* Line dtet.c:543
* Line dtet.c:543: assignment: =
	LDB	-1,U		variable `blockColour', declared at dtet.c:534
	PSHS	B
	LDD	-9,U		variable `x', declared at dtet.c:533
	PSHS	B,A
	LDD	-7,U		variable `y', declared at dtet.c:533
	LBSR	MUL16BY10
	ADDD	,S++
	PSHS	B,A		preserve array index
	LDB	5,U		variable i
* optim: stripOpToDeadReg
	LDA	#160		size of array element
	MUL			get offset in bytes in D
	LEAX	_pit+0,PCR	address of array pit
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,S+
	STB	,X
L00503	EQU	*		else clause of if() started at dtet.c:541
* Useless label L00508 removed
* Useless label L00500 removed
* Line dtet.c:536: for increment(s)
	LDD	-5,U
	ADDD	#1
	STD	-5,U
L00499	EQU	*
* Line dtet.c:536: for condition
	LDD	-5,U		variable blockX
	CMPD	#$03
	LBLE	L00498
* optim: branchToNextLocation
* Useless label L00501 removed
* Useless label L00496 removed
* Line dtet.c:535: for increment(s)
	LDD	-3,U
	ADDD	#1
	STD	-3,U
L00495	EQU	*
* Line dtet.c:535: for condition
	LDD	-3,U		variable blockY
	CMPD	#$03
	LBLE	L00494
* optim: branchToNextLocation
* Useless label L00497 removed
* Line dtet.c:546: if
	LDB	_numPlayers+0,PCR	variable `numPlayers', declared at dtet.c:84
* optim: loadCmpZeroBeqOrBne
	BNE	L00510		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00511 removed
	CLRA
* optim: stripConsecutiveLoadsToSameReg
* PSHS B,A optim: optimizeStackOperations1
	LDB	_level+0,PCR	index 0 in array level[]
* optim: stripExtraClrA_B
	CMPD	#3		optim: optimizeStackOperations1
	BLS	L00510		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00509 removed
* Line dtet.c:547
* Line dtet.c:547: post-increment
* optim: optimizeLeax
	INC	_linesPiecesPlayed+0,PCR	optim: optimizeLeax
L00510	EQU	*		else clause of if() started at dtet.c:546
* Useless label L00512 removed
* Useless label L00142 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION settleActiveShapeInPit(): defined at dtet.c:532
funcend_settleActiveShapeInPit	EQU *
funcsize_settleActiveShapeInPit	EQU	funcend_settleActiveShapeInPit-_settleActiveShapeInPit
_dropShape	EXPORT


*******************************************************************************

* FUNCTION dropShape(): defined at dtet.c:551
_dropShape	EQU	*
* Prototype: void dropShape(unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
* Formal parameter(s):
*      5,U:    1 byte : i: unsigned char: line 551
* Line dtet.c:553: if
* Line dtet.c:553: function call: shapeCanMove()
	LDB	5,U		variable `i', declared at dtet.c:551
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 4 of shapeCanMove(): unsigned char
	LDB	#$01		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 3 of shapeCanMove(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 2 of shapeCanMove(): int
	LDB	5,U		variable i
* optim: removeClr
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LEAX	_shapeMap+0,PCR	address of array shapeMap
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	PSHS	B,A		C function argument 1 of shapeCanMove(): char[]
	LBSR	_shapeCanMove
	LEAS	8,S
	TSTB
	LBEQ	L00514		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00513 removed
* Line dtet.c:553
* Line dtet.c:554: function call: drawShape()
	LDB	5,U		variable `i', declared at dtet.c:551
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawShape(): unsigned char
	LDB	#$01		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of drawShape(): int
	LBSR	_drawShape
	LEAS	4,S
* Line dtet.c:555: assignment: +=
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A
	LDB	5,U		variable i
* optim: stripExtraClrA_B
	LSLB
	ROLA
	LEAX	_shapeY+0,PCR	address of array shapeY
	LEAX	D,X		add offset
	LDD	,X
	ADDD	,S++
	STD	,X
* Line dtet.c:556: function call: drawShape()
	LDB	5,U		variable `i', declared at dtet.c:551
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawShape(): unsigned char
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of drawShape(): int
	LBSR	_drawShape
	LEAS	4,S
* Line dtet.c:558: if
	LDB	5,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_dropRate+0,PCR	address of array dropRate
* optimizeLoadDX
	LDD	D,X		get r-value
* optim: loadCmpZeroBeqOrBne
	LBNE	L00518		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00515 removed
* Line dtet.c:558
* Line dtet.c:559: post-increment
	LDB	5,U		variable i
	ADDB	#$06		6
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_scores+0,PCR	address of array scores
	LEAX	D,X		add offset
	LDD	,X
	ADDD	#1
	STD	,X
* Line dtet.c:560: post-increment
	LDX	_lastPoints+0,PCR	variable `lastPoints', declared at dtet.c:560
	LEAX	1,X
	STX	_lastPoints+0,PCR
* Useless label L00516 removed
* Useless label L00517 removed
	LBRA	L00518		jump over else clause
L00514	EQU	*		else clause of if() started at dtet.c:553
* Line dtet.c:562
* Line dtet.c:563: function call: settleActiveShapeInPit()
	LDB	5,U		variable `i', declared at dtet.c:551
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 1 of settleActiveShapeInPit(): unsigned char
	LBSR	_settleActiveShapeInPit
	LEAS	2,S
* Line dtet.c:564: if
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:102
* optim: loadCmpZeroBeqOrBne
	BNE	L00520
* optim: branchToNextLocation
* Useless label L00519 removed
* Line dtet.c:564
* Line dtet.c:564: function call: sound()
	CLRA
	CLRB
	PSHS	B,A		C function argument 2 of sound(): int
	LDB	#$F5		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of sound(): int
	LBSR	_sound
	LEAS	4,S
L00520	EQU	*		else clause of if() started at dtet.c:564
* Useless label L00521 removed
* Line dtet.c:566: if
	LDB	5,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_shapeY+0,PCR	address of array shapeY
* optimizeLoadDX
	LDD	D,X		get r-value
	CMPD	#0
	BGE	L00523		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00522 removed
* Line dtet.c:566
* Line dtet.c:567: assignment: =
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B
	LDB	5,U		variable i
	LEAX	_gameOver+0,PCR	address of array gameOver
	ABX			add unsigned 8-bit offset
	LDB	,S+
	STB	,X
* Line dtet.c:568: function call: locate()
* optim: stripExtraClrA_B
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of locate(): int
	LDB	5,U		variable i
	LEAX	_pitLeft+0,PCR	address of array pitLeft
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of locate(): const unsigned char
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:568: function call: printf()
	LEAX	S00181,PCR	"GAME OVER!"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:569: function call: playTune()
	CLRA
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 3 of playTune(): int
	LEAX	_tune3Durations+0,PCR	address of array tune3Durations
	PSHS	X		C function argument 2 of playTune(): const unsigned char[]
	LEAX	_tune3Notes+0,PCR	address of array tune3Notes
	PSHS	X		C function argument 1 of playTune(): const unsigned char[]
	LBSR	_playTune
	LEAS	6,S
	BRA	L00524		jump over else clause
L00523	EQU	*		else clause of if() started at dtet.c:566
* Line dtet.c:571
* Line dtet.c:572: function call: checkForFullRows()
	LDB	5,U		variable `i', declared at dtet.c:551
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 1 of checkForFullRows(): unsigned char
	LBSR	_checkForFullRows
	LEAS	2,S
* Line dtet.c:573: function call: drawPit()
	LDB	5,U		variable `i', declared at dtet.c:551
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 1 of drawPit(): unsigned char
	LBSR	_drawPit
	LEAS	2,S
* Line dtet.c:574: function call: createShape()
	LDB	5,U		variable `i', declared at dtet.c:551
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 1 of createShape(): unsigned char
	LBSR	_createShape
	LEAS	2,S
* Line dtet.c:575: function call: drawShape()
	LDB	5,U		variable `i', declared at dtet.c:551
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawShape(): unsigned char
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of drawShape(): int
	LBSR	_drawShape
	LEAS	4,S
L00524	EQU	*		end of if() started at dtet.c:566
* Line dtet.c:578: function call: displayStatus()
	LBSR	_displayStatus
L00518	EQU	*		end of if() started at dtet.c:553
* Useless label L00143 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION dropShape(): defined at dtet.c:551
funcend_dropShape	EQU *
funcsize_dropShape	EQU	funcend_dropShape-_dropShape
_roundWindow	EXPORT


*******************************************************************************

* FUNCTION roundWindow(): defined at dtet.c:585
_roundWindow	EQU	*
* Prototype: void roundWindow(int, int, int, int, unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
* Formal parameter(s):
*      4,U:    2 bytes: ulx: int: line 585
*      6,U:    2 bytes: uly: int: line 585
*      8,U:    2 bytes: brx: int: line 585
*     10,U:    2 bytes: bry: int: line 585
*     13,U:    1 byte : offset: unsigned char: line 585
* Line dtet.c:586: function call: printBlock()
	LDB	13,U		variable offset
	ADDB	#$81		129
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 3 of printBlock(): unsigned char
	LDD	6,U		variable `uly', declared at dtet.c:585
	PSHS	B,A		C function argument 2 of printBlock(): int
	LDD	4,U		variable `ulx', declared at dtet.c:585
	PSHS	B,A		C function argument 1 of printBlock(): int
	LBSR	_printBlock
	LEAS	6,S
* Line dtet.c:587: function call: printBlock()
	LDB	13,U		variable offset
	ADDB	#$82		130
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 3 of printBlock(): unsigned char
	LDD	6,U		variable `uly', declared at dtet.c:585
	PSHS	B,A		C function argument 2 of printBlock(): int
	LDD	8,U		variable `brx', declared at dtet.c:585
	PSHS	B,A		C function argument 1 of printBlock(): int
	LBSR	_printBlock
	LEAS	6,S
* Line dtet.c:588: function call: printBlock()
	LDB	13,U		variable offset
	ADDB	#$84		132
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 3 of printBlock(): unsigned char
	LDD	10,U		variable `bry', declared at dtet.c:585
	PSHS	B,A		C function argument 2 of printBlock(): int
	LDD	4,U		variable `ulx', declared at dtet.c:585
	PSHS	B,A		C function argument 1 of printBlock(): int
	LBSR	_printBlock
	LEAS	6,S
* Line dtet.c:589: function call: printBlock()
	LDB	13,U		variable offset
	ADDB	#$88		136
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 3 of printBlock(): unsigned char
	LDD	10,U		variable `bry', declared at dtet.c:585
	PSHS	B,A		C function argument 2 of printBlock(): int
	LDD	8,U		variable `brx', declared at dtet.c:585
	PSHS	B,A		C function argument 1 of printBlock(): int
	LBSR	_printBlock
	LEAS	6,S
* Useless label L00144 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION roundWindow(): defined at dtet.c:585
funcend_roundWindow	EQU *
funcsize_roundWindow	EQU	funcend_roundWindow-_roundWindow
_drawHighScores	EXPORT


*******************************************************************************

* FUNCTION drawHighScores(): defined at dtet.c:593
_drawHighScores	EQU	*
* Prototype: void drawHighScores(...)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-1,S
* Local non-static variable(s):
*     -1,U:    1 byte : pos: unsigned char: line 598
* Line dtet.c:594: function call: cls()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of cls(): int
	LBSR	_cls
	LEAS	2,S
* Line dtet.c:595: function call: roundWindow()
	CLRA
	LDB	#$50		decimal 80 signed
	PSHS	B,A		C function argument 5 of roundWindow(): int
* optim: stripExtraClrA_B
	LDB	#$0F		decimal 15 signed
	PSHS	B,A		C function argument 4 of roundWindow(): int
* optim: stripExtraClrA_B
	LDB	#$1F		decimal 31 signed
	PSHS	B,A		C function argument 3 of roundWindow(): int
* optim: removeClr
	CLRB
	PSHS	B,A		C function argument 2 of roundWindow(): int
* optim: removeClr
* optim: removeClr
	PSHS	B,A		C function argument 1 of roundWindow(): int
	LBSR	_roundWindow
	LEAS	10,S
* Line dtet.c:596: function call: drawHeader()
	LDB	_colourShift+0,PCR
	INC	_colourShift+0,PCR
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawHeader(): unsigned char
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of drawHeader(): int
	LBSR	_drawHeader
	LEAS	4,S
* Line dtet.c:598: for init
* Line dtet.c:598: init of variable pos
	CLR	-1,U		variable pos
	LBRA	L00526		jump to for condition
L00525	EQU	*
* Line dtet.c:598: for body
* Line dtet.c:599: function call: locate()
	LDB	-1,U		variable pos
	ADDB	#$07		7
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of locate(): unsigned char
	LDB	#$08		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:599: function call: printf()
	LEAX	S00182,PCR	"............."
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:600: function call: locate()
	LDB	-1,U		variable pos
	ADDB	#$07		7
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of locate(): unsigned char
	LDB	#$07		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:600: function call: printf()
	LDB	-1,U		variable pos
* optim: stripOpToDeadReg
	LDA	#11		size of array element
	MUL			get offset in bytes in D
	LEAX	_names+0,PCR	address of array names
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	PSHS	B,A		C function argument 2 of printf(): char[]
	LEAX	S00183,PCR	"%s"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	4,S
* Line dtet.c:601: function call: locate()
	LDB	-1,U		variable pos
	ADDB	#$07		7
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of locate(): unsigned char
	LDB	#$14		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:601: function call: printf()
	LDB	-1,U		variable pos
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_scores+0,PCR	address of array scores
* optimizeLoadDX
	LDD	D,X		get r-value
	PSHS	B,A		C function argument 2 of printf(): unsigned int
	LEAX	S00184,PCR	"%5u"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	4,S
* Useless label L00527 removed
* Line dtet.c:598: for increment(s)
	INC	-1,U
L00526	EQU	*
* Line dtet.c:598: for condition
	LDB	-1,U		variable pos
	CMPB	#$06
	LBLO	L00525
* optim: branchToNextLocation
* Useless label L00528 removed
* Line dtet.c:603: function call: locate()
	CLRA
	LDB	#$0E		decimal 14 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$03		decimal 3 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:603: function call: printf()
	LEAX	S00185,PCR	"PRESS ANY KEY TO CONTINUE!"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:604: function call: playTune()
	CLRA
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 3 of playTune(): int
	LEAX	_tune1Durations+0,PCR	address of array tune1Durations
	PSHS	X		C function argument 2 of playTune(): const unsigned char[]
	LEAX	_tune1Notes+0,PCR	address of array tune1Notes
	PSHS	X		C function argument 1 of playTune(): const unsigned char[]
	LBSR	_playTune
	LEAS	6,S
* Line dtet.c:605: while
* optim: branchToNextLocation
L00529	EQU	*		while body
* Line dtet.c:606: if
* Line dtet.c:606: function call: inkey()
	LBSR	_inkey
	TSTB
	BNE	L00531		 (optim: condBranchOverUncondBranch) (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00532 removed
* Line dtet.c:606
* optim: condBranchOverUncondBranch
* Useless label L00533 removed
* Useless label L00534 removed
* Line dtet.c:607: function call: drawHeader()
	LDB	_colourShift+0,PCR
	INC	_colourShift+0,PCR
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawHeader(): unsigned char
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of drawHeader(): int
	LBSR	_drawHeader
	LEAS	4,S
* Line dtet.c:608: function call: delay()
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A		C function argument 1 of delay(): int
	LBSR	_delay
	LEAS	2,S
* Useless label L00530 removed
	BRA	L00529		go to start of while body
L00531	EQU	*		after end of while starting at dtet.c:605
* Useless label L00145 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION drawHighScores(): defined at dtet.c:593
funcend_drawHighScores	EQU *
funcsize_drawHighScores	EQU	funcend_drawHighScores-_drawHighScores
_drawHelp	EXPORT


*******************************************************************************

* FUNCTION drawHelp(): defined at dtet.c:613
_drawHelp	EQU	*
* Prototype: void drawHelp(...)
* Calling convention: 0 (CMOC Default)
* Line dtet.c:614: function call: cls()
	CLRA
	CLRB
	PSHS	B,A		C function argument 1 of cls(): int
	LBSR	_cls
	LEAS	2,S
* Line dtet.c:615: function call: printf()
	LEAX	S00186,PCR	"  =DRAGON 1=  "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:616: function call: locate()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:616: function call: printf()
	LEAX	S00187,PCR	"              "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:617: function call: locate()
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:617: function call: printf()
	LEAX	S00188,PCR	" w ROTATE     "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:618: function call: locate()
	CLRA
	LDB	#$03		decimal 3 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:618: function call: printf()
	LEAX	S00189,PCR	" s DROP       "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:619: function call: locate()
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:619: function call: printf()
	LEAX	S00190,PCR	" a MOVE LEFT  "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:620: function call: locate()
	CLRA
	LDB	#$05		decimal 5 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:620: function call: printf()
	LEAX	S00191,PCR	" d MOVE RIGHT "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:621: function call: locate()
	CLRA
	LDB	#$06		decimal 6 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:621: function call: printf()
	LEAX	S00187,PCR	"              "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:622: function call: locate()
	CLRA
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:622: function call: printf()
	LEAX	S00192,PCR	" + CURSORS    "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:623: function call: locate()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:623: function call: printf()
	LEAX	S00193,PCR	" + JOYSTICK1  "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:624: function call: locate()
	CLRA
	LDB	#$09		decimal 9 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:624: function call: printf()
	LEAX	S00187,PCR	"              "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:626: function call: locate()
	CLRA
	CLRB
	PSHS	B,A		C function argument 2 of locate(): int
	LDB	#$12		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:626: function call: printf()
	LEAX	S00194,PCR	"  =DRAGON 2=  "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:627: function call: locate()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$12		decimal 18 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:627: function call: printf()
	LEAX	S00187,PCR	"              "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:628: function call: locate()
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$12		decimal 18 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:628: function call: printf()
	LEAX	S00195,PCR	" i ROTATE     "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:629: function call: locate()
	CLRA
	LDB	#$03		decimal 3 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$12		decimal 18 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:629: function call: printf()
	LEAX	S00196,PCR	" k DROP       "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:630: function call: locate()
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$12		decimal 18 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:630: function call: printf()
	LEAX	S00197,PCR	" j MOVE LEFT  "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:631: function call: locate()
	CLRA
	LDB	#$05		decimal 5 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$12		decimal 18 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:631: function call: printf()
	LEAX	S00198,PCR	" l MOVE RIGHT "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:632: function call: locate()
	CLRA
	LDB	#$06		decimal 6 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$12		decimal 18 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:632: function call: printf()
	LEAX	S00187,PCR	"              "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:633: function call: locate()
	CLRA
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$12		decimal 18 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:633: function call: printf()
	LEAX	S00199,PCR	" + JOYSTICK2  "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:634: function call: locate()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$12		decimal 18 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:634: function call: printf()
	LEAX	S00187,PCR	"              "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:636: function call: locate()
	CLRA
	LDB	#$0B		decimal 11 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:636: function call: printf()
	LEAX	S00200,PCR	" X = CANCEL/RETURN TO MAIN MENU "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:637: function call: locate()
	CLRA
	LDB	#$0C		decimal 12 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:637: function call: printf()
	LEAX	S00201,PCR	" H = PAUSE THE GAME             "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:638: function call: locate()
	CLRA
	LDB	#$0E		decimal 14 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:638: function call: printf()
	LEAX	S00202,PCR	"   PRESS ANY KEY TO CONTINUE!   "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:640: function call: roundWindow()
	CLRA
	LDB	#$70		decimal 112 signed
	PSHS	B,A		C function argument 5 of roundWindow(): int
* optim: stripExtraClrA_B
	LDB	#$09		decimal 9 signed
	PSHS	B,A		C function argument 4 of roundWindow(): int
* optim: stripExtraClrA_B
	LDB	#$0D		decimal 13 signed
	PSHS	B,A		C function argument 3 of roundWindow(): int
* optim: removeClr
	CLRB
	PSHS	B,A		C function argument 2 of roundWindow(): int
* optim: removeClr
* optim: removeClr
	PSHS	B,A		C function argument 1 of roundWindow(): int
	LBSR	_roundWindow
	LEAS	10,S
* Line dtet.c:641: function call: roundWindow()
	CLRA
	LDB	#$70		decimal 112 signed
	PSHS	B,A		C function argument 5 of roundWindow(): int
* optim: stripExtraClrA_B
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 4 of roundWindow(): int
* optim: stripExtraClrA_B
	LDB	#$1F		decimal 31 signed
	PSHS	B,A		C function argument 3 of roundWindow(): int
* optim: removeClr
	CLRB
	PSHS	B,A		C function argument 2 of roundWindow(): int
	LDB	#$12		optim: removeAndOrMulAddSub
	PSHS	B,A		C function argument 1 of roundWindow(): int
	LBSR	_roundWindow
	LEAS	10,S
* Line dtet.c:642: function call: screen()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 2 of screen(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of screen(): int
	LBSR	_screen
	LEAS	4,S
* Line dtet.c:643: function call: waitkey()
	CLRA
	CLRB
	PSHS	B,A		C function argument 1 of waitkey(): int
	LBSR	_waitkey
	LEAS	2,S
* Line dtet.c:645: function call: cls()
	CLRA
	CLRB
	PSHS	B,A		C function argument 1 of cls(): int
	LBSR	_cls
	LEAS	2,S
* Line dtet.c:646: function call: locate()
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:646: function call: printf()
	LEAX	S00203,PCR	"                             "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:647: function call: locate()
	CLRA
	LDB	#$03		decimal 3 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:647: function call: printf()
	LEAX	S00204,PCR	"        = s c o r e =        "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:648: function call: locate()
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:648: function call: printf()
	LEAX	S00203,PCR	"                             "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:649: function call: locate()
	CLRA
	LDB	#$05		decimal 5 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:649: function call: printf()
	LEAX	S00205,PCR	" 1 LINE:  100 * LEVEL NUMBER "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:650: function call: locate()
	CLRA
	LDB	#$06		decimal 6 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:650: function call: printf()
	LEAX	S00206,PCR	" 2 LINES: 300 * LEVEL NUMBER "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:651: function call: locate()
	CLRA
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:651: function call: printf()
	LEAX	S00207,PCR	" 3 LINES: 500 * LEVEL NUMBER "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:652: function call: locate()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:652: function call: printf()
	LEAX	S00208,PCR	" 4 LINES: 800 * LEVEL NUMBER "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:653: function call: locate()
	CLRA
	LDB	#$09		decimal 9 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:653: function call: printf()
	LEAX	S00203,PCR	"                             "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:654: function call: locate()
	CLRA
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:654: function call: printf()
	LEAX	S00209,PCR	"  SOFT DROP:  1 POINT * ROW  "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:656: function call: locate()
	CLRA
	LDB	#$0E		decimal 14 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:656: function call: printf()
	LEAX	S00202,PCR	"   PRESS ANY KEY TO CONTINUE!   "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:658: function call: roundWindow()
	CLRA
	LDB	#$70		decimal 112 signed
	PSHS	B,A		C function argument 5 of roundWindow(): int
* optim: stripExtraClrA_B
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 4 of roundWindow(): int
	LDB	#$1D		optim: removeAndOrMulAddSub
	PSHS	B,A		C function argument 3 of roundWindow(): int
	LDB	#$02		optim: removeAndOrMulAddSub
	PSHS	B,A		C function argument 2 of roundWindow(): int
	LDB	#$01		optim: removeAndOrMulAddSub
	PSHS	B,A		C function argument 1 of roundWindow(): int
	LBSR	_roundWindow
	LEAS	10,S
* Line dtet.c:659: function call: screen()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 2 of screen(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of screen(): int
	LBSR	_screen
	LEAS	4,S
* Line dtet.c:660: function call: waitkey()
	CLRA
	CLRB
	PSHS	B,A		C function argument 1 of waitkey(): int
	LBSR	_waitkey
	LEAS	2,S
* Useless label L00146 removed
	RTS
* END FUNCTION drawHelp(): defined at dtet.c:613
funcend_drawHelp	EQU *
funcsize_drawHelp	EQU	funcend_drawHelp-_drawHelp
_drawMenuPtr	EXPORT


*******************************************************************************

* FUNCTION drawMenuPtr(): defined at dtet.c:664
_drawMenuPtr	EQU	*
* Prototype: void drawMenuPtr(unsigned char, unsigned char, unsigned char, unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-1,S
* Formal parameter(s):
*      5,U:    1 byte : x: unsigned char: line 664
*      7,U:    1 byte : y: unsigned char: line 664
*      9,U:    1 byte : offset: unsigned char: line 664
*     11,U:    1 byte : delete: unsigned char: line 664
* Local non-static variable(s):
*     -1,U:    1 byte : pointer: unsigned char: line 665
* Line dtet.c:665: init of variable pointer
* Line dtet.c:665: conditional expression
	LDB	11,U		variable `delete', declared at dtet.c:664
* optim: loadCmpZeroBeqOrBne
	BEQ	L00536		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00535 removed
	CLRA
	LDB	#$8F		decimal 143 signed
	BRA	L00537		end of true expression of conditional
L00536	EQU	*
	CLRA
	LDB	#$3E		decimal 62 signed
L00537	EQU	*
	STB	-1,U		variable pointer
* Line dtet.c:666: function call: printBlock()
* optim: storeLoad
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 3 of printBlock(): unsigned char
	LDB	7,U		variable y
	ADDB	9,U		variable offset
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 2 of printBlock(): unsigned char
	LDB	5,U		variable `x', declared at dtet.c:664
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of printBlock(): unsigned char
	LBSR	_printBlock
	LEAS	6,S
* Useless label L00147 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION drawMenuPtr(): defined at dtet.c:664
funcend_drawMenuPtr	EQU *
funcsize_drawMenuPtr	EQU	funcend_drawMenuPtr-_drawMenuPtr
_drawOptionsMenu	EXPORT


*******************************************************************************

* FUNCTION drawOptionsMenu(): defined at dtet.c:670
_drawOptionsMenu	EQU	*
* Prototype: void drawOptionsMenu(...)
* Calling convention: 0 (CMOC Default)
* Line dtet.c:671: function call: cls()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of cls(): int
	LBSR	_cls
	LEAS	2,S
* Line dtet.c:672: function call: roundWindow()
	CLRA
	LDB	#$50		decimal 80 signed
	PSHS	B,A		C function argument 5 of roundWindow(): int
* optim: stripExtraClrA_B
	LDB	#$0F		decimal 15 signed
	PSHS	B,A		C function argument 4 of roundWindow(): int
* optim: stripExtraClrA_B
	LDB	#$1F		decimal 31 signed
	PSHS	B,A		C function argument 3 of roundWindow(): int
* optim: removeClr
	CLRB
	PSHS	B,A		C function argument 2 of roundWindow(): int
* optim: removeClr
* optim: removeClr
	PSHS	B,A		C function argument 1 of roundWindow(): int
	LBSR	_roundWindow
	LEAS	10,S
* Line dtet.c:673: function call: locate()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:673: function call: printf()
	LEAX	S00210,PCR	"EMPTY BACKGROUND:"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:674: function call: locate()
	CLRA
	LDB	#$09		decimal 9 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:674: function call: printf()
	LEAX	S00211,PCR	"MUTED:"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:675: function call: locate()
	CLRA
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:675: function call: printf()
	LEAX	S00212,PCR	"BACK"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:676: function call: locate()
	CLRA
	LDB	#$0E		decimal 14 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$02		decimal 2 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:676: function call: printf()
	LEAX	S00213,PCR	"SELECT OPTION (CURSOR/ENTER)"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:678: function call: locate()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$19		decimal 25 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:679: if
	LDB	_emptyBackground+0,PCR	variable `emptyBackground', declared at dtet.c:101
* optim: loadCmpZeroBeqOrBne
	BEQ	L00539		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00538 removed
* Line dtet.c:679
* Line dtet.c:679: function call: printf()
	LEAX	S00214,PCR	"on "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
	BRA	L00540		jump over else clause
L00539	EQU	*		else clause of if() started at dtet.c:679
* Line dtet.c:680
* Line dtet.c:680: function call: printf()
	LEAX	S00215,PCR	"off"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
L00540	EQU	*		end of if() started at dtet.c:679
* Line dtet.c:681: function call: locate()
	CLRA
	LDB	#$09		decimal 9 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$19		decimal 25 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:682: if
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:102
* optim: loadCmpZeroBeqOrBne
	BEQ	L00542		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00541 removed
* Line dtet.c:682
* Line dtet.c:682: function call: printf()
	LEAX	S00214,PCR	"on "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
	BRA	L00543		jump over else clause
L00542	EQU	*		else clause of if() started at dtet.c:682
* Line dtet.c:683
* Line dtet.c:683: function call: printf()
	LEAX	S00215,PCR	"off"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
L00543	EQU	*		end of if() started at dtet.c:682
* Useless label L00148 removed
	RTS
* END FUNCTION drawOptionsMenu(): defined at dtet.c:670
funcend_drawOptionsMenu	EQU *
funcsize_drawOptionsMenu	EQU	funcend_drawOptionsMenu-_drawOptionsMenu
_optionsMenu	EXPORT


*******************************************************************************

* FUNCTION optionsMenu(): defined at dtet.c:687
_optionsMenu	EQU	*
* Prototype: void optionsMenu(...)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-1,S
* Local non-static variable(s):
*     -1,U:    1 byte : optNumber: char: line 688
* Line dtet.c:688: init of variable optNumber
	CLR	-1,U		variable optNumber
* Line dtet.c:689: function call: drawOptionsMenu()
	LBSR	_drawOptionsMenu
* Line dtet.c:690: function call: drawMenuPtr()
	CLRA
	CLRB
	PSHS	B,A		C function argument 4 of drawMenuPtr(): int
	LDB	-1,U		variable `optNumber', declared at dtet.c:688
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 3 of drawMenuPtr(): char
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of drawMenuPtr(): int
* optim: stripExtraClrA_B
	LDB	#$05		decimal 5 signed
	PSHS	B,A		C function argument 1 of drawMenuPtr(): int
	LBSR	_drawMenuPtr
	LEAS	8,S
* Line dtet.c:722: do-while
L00544	EQU	*		do-while body
* Line dtet.c:692: function call: drawHeader()
	LDB	_colourShift+0,PCR
	INC	_colourShift+0,PCR
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawHeader(): unsigned char
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of drawHeader(): int
	LBSR	_drawHeader
	LEAS	4,S
* Line dtet.c:693: assignment: =
* Line dtet.c:693: function call: inkey()
	LBSR	_inkey
	STB	_key+0,PCR
* Line dtet.c:694: if
* optim: storeLoad
	CMPB	#$0A
	LBNE	L00548		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00547 removed
* Line dtet.c:694
* Line dtet.c:695: function call: drawMenuPtr()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 4 of drawMenuPtr(): int
	LDB	-1,U		variable `optNumber', declared at dtet.c:688
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 3 of drawMenuPtr(): char
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of drawMenuPtr(): int
* optim: stripExtraClrA_B
	LDB	#$05		decimal 5 signed
	PSHS	B,A		C function argument 1 of drawMenuPtr(): int
	LBSR	_drawMenuPtr
	LEAS	8,S
* Line dtet.c:696: if
	LDB	-1,U
	INC	-1,U
	CMPB	#2
	BNE	L00550		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00549 removed
* Line dtet.c:696
* Line dtet.c:696: assignment: =
	CLR	-1,U		variable optNumber
L00550	EQU	*		else clause of if() started at dtet.c:696
* Useless label L00551 removed
* Line dtet.c:697: function call: drawMenuPtr()
	CLRA
	CLRB
	PSHS	B,A		C function argument 4 of drawMenuPtr(): int
	LDB	-1,U		variable `optNumber', declared at dtet.c:688
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 3 of drawMenuPtr(): char
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of drawMenuPtr(): int
* optim: stripExtraClrA_B
	LDB	#$05		decimal 5 signed
	PSHS	B,A		C function argument 1 of drawMenuPtr(): int
	LBSR	_drawMenuPtr
	LEAS	8,S
* Line dtet.c:698: if
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:102
* optim: loadCmpZeroBeqOrBne
	LBNE	L00555
* optim: branchToNextLocation
* Useless label L00552 removed
* Line dtet.c:698
* Line dtet.c:698: function call: sound()
	CLRA
	CLRB
	PSHS	B,A		C function argument 2 of sound(): int
	LDB	#$C8		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of sound(): int
	LBSR	_sound
	LEAS	4,S
* Useless label L00553 removed
* Useless label L00554 removed
	LBRA	L00555		jump over else clause
L00548	EQU	*		else clause of if() started at dtet.c:694
* Line dtet.c:721
* Line dtet.c:700: if
	LDB	_key+0,PCR	variable key
	CMPB	#$5E
	LBNE	L00557		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00556 removed
* Line dtet.c:700
* Line dtet.c:701: function call: drawMenuPtr()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 4 of drawMenuPtr(): int
	LDB	-1,U		variable `optNumber', declared at dtet.c:688
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 3 of drawMenuPtr(): char
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of drawMenuPtr(): int
* optim: stripExtraClrA_B
	LDB	#$05		decimal 5 signed
	PSHS	B,A		C function argument 1 of drawMenuPtr(): int
	LBSR	_drawMenuPtr
	LEAS	8,S
* Line dtet.c:702: if
	LDB	-1,U
	DEC	-1,U
	TSTB
	BNE	L00559		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00558 removed
* Line dtet.c:702
* Line dtet.c:702: assignment: =
	LDB	#$02
	STB	-1,U		variable optNumber
L00559	EQU	*		else clause of if() started at dtet.c:702
* Useless label L00560 removed
* Line dtet.c:703: function call: drawMenuPtr()
	CLRA
	CLRB
	PSHS	B,A		C function argument 4 of drawMenuPtr(): int
	LDB	-1,U		variable `optNumber', declared at dtet.c:688
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 3 of drawMenuPtr(): char
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of drawMenuPtr(): int
* optim: stripExtraClrA_B
	LDB	#$05		decimal 5 signed
	PSHS	B,A		C function argument 1 of drawMenuPtr(): int
	LBSR	_drawMenuPtr
	LEAS	8,S
* Line dtet.c:704: if
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:102
* optim: loadCmpZeroBeqOrBne
	LBNE	L00564
* optim: branchToNextLocation
* Useless label L00561 removed
* Line dtet.c:704
* Line dtet.c:704: function call: sound()
	CLRA
	CLRB
	PSHS	B,A		C function argument 2 of sound(): int
	LDB	#$C8		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of sound(): int
	LBSR	_sound
	LEAS	4,S
* Useless label L00562 removed
* Useless label L00563 removed
	LBRA	L00564		jump over else clause
L00557	EQU	*		else clause of if() started at dtet.c:700
* Line dtet.c:721
* Line dtet.c:706: if
	LDB	_key+0,PCR	variable key
	CMPB	#$0D
	BEQ	L00565
* optim: branchToNextLocation
* Useless label L00567 removed
* optim: removeLoadInComparisonWithTwoValues
	CMPB	#$20
	LBNE	L00566		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
L00565	EQU	*		then clause of if() started at dtet.c:706
* Line dtet.c:706
* Line dtet.c:707: if
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:102
* optim: loadCmpZeroBeqOrBne
	BNE	L00569
* optim: branchToNextLocation
* Useless label L00568 removed
* Line dtet.c:707
* Line dtet.c:707: function call: sound()
	CLRA
	CLRB
	PSHS	B,A		C function argument 2 of sound(): int
	LDB	#$64		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of sound(): int
	LBSR	_sound
	LEAS	4,S
L00569	EQU	*		else clause of if() started at dtet.c:707
* Useless label L00570 removed
* Line dtet.c:708: switch
	LDB	-1,U		variable `optNumber', declared at dtet.c:688
* Switch at dtet.c:708 has 3 non-ignored case values.
* Switch at dtet.c:708 uses if-else sequence: IF_ELSE=21, JUMP_TABLE=26
* Switch case at dtet.c:709
* optim: loadCmpZeroBeqOrBne
	BEQ	L00572
* Switch case at dtet.c:712
	CMPB	#$01		case 1
	BEQ	L00573
* Switch case at dtet.c:715
	CMPB	#$02		case 2
	BEQ	L00149
	BRA	L00571		switch default
L00572	EQU	*		case 0
* Line dtet.c:710: assignment: =
	LDB	_emptyBackground+0,PCR	variable `emptyBackground', declared at dtet.c:101
* optim: optimizeLoadTest
	LBSR	tfrZtoB
	STB	_emptyBackground+0,PCR
	BRA	L00571		break
L00573	EQU	*		case 1
* Line dtet.c:713: assignment: =
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:102
* optim: optimizeLoadTest
	LBSR	tfrZtoB
	STB	_muted+0,PCR
	BRA	L00571		break
* Useless label L00574 removed
	BRA	L00149		return (dtet.c:716)
L00571	EQU	*		end of switch
* Line dtet.c:718: function call: drawOptionsMenu()
	LBSR	_drawOptionsMenu
* Line dtet.c:719: function call: drawMenuPtr()
	CLRA
	CLRB
	PSHS	B,A		C function argument 4 of drawMenuPtr(): int
	LDB	-1,U		variable `optNumber', declared at dtet.c:688
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 3 of drawMenuPtr(): char
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of drawMenuPtr(): int
* optim: stripExtraClrA_B
	LDB	#$05		decimal 5 signed
	PSHS	B,A		C function argument 1 of drawMenuPtr(): int
	LBSR	_drawMenuPtr
	LEAS	8,S
L00566	EQU	*		else clause of if() started at dtet.c:706
* Useless label L00575 removed
L00564	EQU	*		end of if() started at dtet.c:700
L00555	EQU	*		end of if() started at dtet.c:694
* Line dtet.c:721: function call: delay()
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A		C function argument 1 of delay(): int
	LBSR	_delay
	LEAS	2,S
* Useless label L00545 removed
	LBRA	L00544		go to start of do-while body
* Useless label L00546 removed
L00149	EQU	*		end of optionsMenu()
	LEAS	,U
	PULS	U,PC
* END FUNCTION optionsMenu(): defined at dtet.c:687
funcend_optionsMenu	EQU *
funcsize_optionsMenu	EQU	funcend_optionsMenu-_optionsMenu
_drawMenu	EXPORT


*******************************************************************************

* FUNCTION drawMenu(): defined at dtet.c:726
_drawMenu	EQU	*
* Prototype: void drawMenu(...)
* Calling convention: 0 (CMOC Default)
* Line dtet.c:727: function call: cls()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of cls(): int
	LBSR	_cls
	LEAS	2,S
* Line dtet.c:728: function call: roundWindow()
	CLRA
	LDB	#$50		decimal 80 signed
	PSHS	B,A		C function argument 5 of roundWindow(): int
* optim: stripExtraClrA_B
	LDB	#$0F		decimal 15 signed
	PSHS	B,A		C function argument 4 of roundWindow(): int
* optim: stripExtraClrA_B
	LDB	#$1F		decimal 31 signed
	PSHS	B,A		C function argument 3 of roundWindow(): int
* optim: removeClr
	CLRB
	PSHS	B,A		C function argument 2 of roundWindow(): int
* optim: removeClr
* optim: removeClr
	PSHS	B,A		C function argument 1 of roundWindow(): int
	LBSR	_roundWindow
	LEAS	10,S
* Line dtet.c:729: function call: locate()
	CLRA
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:729: function call: printf()
	LEAX	S00216,PCR	"1 DRAGON GAME"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:730: function call: locate()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:730: function call: printf()
	LEAX	S00217,PCR	"2 DRAGONS GAME"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:731: function call: locate()
	CLRA
	LDB	#$09		decimal 9 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:731: function call: printf()
	LEAX	S00218,PCR	"HIGH SCORES"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:732: function call: locate()
	CLRA
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:732: function call: printf()
	LEAX	S00219,PCR	"OPTIONS"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:733: function call: locate()
	CLRA
	LDB	#$0B		decimal 11 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:733: function call: printf()
	LEAX	S00220,PCR	"HELP"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:734: function call: locate()
	CLRA
	LDB	#$0C		decimal 12 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:734: function call: printf()
	LEAX	S00221,PCR	"EXIT"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:735: function call: locate()
	CLRA
	LDB	#$0E		decimal 14 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$02		decimal 2 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:735: function call: printf()
	LEAX	S00213,PCR	"SELECT OPTION (CURSOR/ENTER)"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Useless label L00150 removed
	RTS
* END FUNCTION drawMenu(): defined at dtet.c:726
funcend_drawMenu	EQU *
funcsize_drawMenu	EQU	funcend_drawMenu-_drawMenu
_menu	EXPORT


*******************************************************************************

* FUNCTION menu(): defined at dtet.c:739
_menu	EQU	*
* Prototype: void menu(...)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-1,S
* Local non-static variable(s):
*     -1,U:    1 byte : optNumber: char: line 740
* Line dtet.c:740: init of variable optNumber
	CLR	-1,U		variable optNumber
* Line dtet.c:741: function call: drawMenu()
	LBSR	_drawMenu
* Line dtet.c:742: function call: drawMenuPtr()
	CLRA
	CLRB
	PSHS	B,A		C function argument 4 of drawMenuPtr(): int
	LDB	-1,U		variable `optNumber', declared at dtet.c:740
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 3 of drawMenuPtr(): char
	CLRA
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 2 of drawMenuPtr(): int
* optim: stripExtraClrA_B
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 1 of drawMenuPtr(): int
	LBSR	_drawMenuPtr
	LEAS	8,S
* Line dtet.c:795: do-while
L00576	EQU	*		do-while body
* Line dtet.c:745: function call: drawHeader()
	LDB	_colourShift+0,PCR
	INC	_colourShift+0,PCR
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawHeader(): unsigned char
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of drawHeader(): int
	LBSR	_drawHeader
	LEAS	4,S
* Line dtet.c:746: assignment: =
* Line dtet.c:746: function call: inkey()
	LBSR	_inkey
	STB	_key+0,PCR
* Line dtet.c:747: if
* optim: storeLoad
	CMPB	#$0A
	LBNE	L00580		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00579 removed
* Line dtet.c:747
* Line dtet.c:748: function call: drawMenuPtr()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 4 of drawMenuPtr(): int
	LDB	-1,U		variable `optNumber', declared at dtet.c:740
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 3 of drawMenuPtr(): char
	CLRA
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 2 of drawMenuPtr(): int
* optim: stripExtraClrA_B
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 1 of drawMenuPtr(): int
	LBSR	_drawMenuPtr
	LEAS	8,S
* Line dtet.c:749: if
	LDB	-1,U
	INC	-1,U
	CMPB	#5
	BNE	L00582		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00581 removed
* Line dtet.c:749
* Line dtet.c:749: assignment: =
	CLR	-1,U		variable optNumber
L00582	EQU	*		else clause of if() started at dtet.c:749
* Useless label L00583 removed
* Line dtet.c:750: function call: drawMenuPtr()
	CLRA
	CLRB
	PSHS	B,A		C function argument 4 of drawMenuPtr(): int
	LDB	-1,U		variable `optNumber', declared at dtet.c:740
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 3 of drawMenuPtr(): char
	CLRA
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 2 of drawMenuPtr(): int
* optim: stripExtraClrA_B
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 1 of drawMenuPtr(): int
	LBSR	_drawMenuPtr
	LEAS	8,S
* Line dtet.c:751: if
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:102
* optim: loadCmpZeroBeqOrBne
	LBNE	L00587
* optim: branchToNextLocation
* Useless label L00584 removed
* Line dtet.c:751
* Line dtet.c:751: function call: sound()
	CLRA
	CLRB
	PSHS	B,A		C function argument 2 of sound(): int
	LDB	#$C8		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of sound(): int
	LBSR	_sound
	LEAS	4,S
* Useless label L00585 removed
* Useless label L00586 removed
	LBRA	L00587		jump over else clause
L00580	EQU	*		else clause of if() started at dtet.c:747
* Line dtet.c:794
* Line dtet.c:753: if
	LDB	_key+0,PCR	variable key
	CMPB	#$5E
	LBNE	L00589		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00588 removed
* Line dtet.c:753
* Line dtet.c:754: function call: drawMenuPtr()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 4 of drawMenuPtr(): int
	LDB	-1,U		variable `optNumber', declared at dtet.c:740
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 3 of drawMenuPtr(): char
	CLRA
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 2 of drawMenuPtr(): int
* optim: stripExtraClrA_B
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 1 of drawMenuPtr(): int
	LBSR	_drawMenuPtr
	LEAS	8,S
* Line dtet.c:755: if
	LDB	-1,U
	DEC	-1,U
	TSTB
	BNE	L00591		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00590 removed
* Line dtet.c:755
* Line dtet.c:755: assignment: =
	LDB	#$05
	STB	-1,U		variable optNumber
L00591	EQU	*		else clause of if() started at dtet.c:755
* Useless label L00592 removed
* Line dtet.c:756: function call: drawMenuPtr()
	CLRA
	CLRB
	PSHS	B,A		C function argument 4 of drawMenuPtr(): int
	LDB	-1,U		variable `optNumber', declared at dtet.c:740
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 3 of drawMenuPtr(): char
	CLRA
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 2 of drawMenuPtr(): int
* optim: stripExtraClrA_B
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 1 of drawMenuPtr(): int
	LBSR	_drawMenuPtr
	LEAS	8,S
* Line dtet.c:757: if
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:102
* optim: loadCmpZeroBeqOrBne
	LBNE	L00596
* optim: branchToNextLocation
* Useless label L00593 removed
* Line dtet.c:757
* Line dtet.c:757: function call: sound()
	CLRA
	CLRB
	PSHS	B,A		C function argument 2 of sound(): int
	LDB	#$C8		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of sound(): int
	LBSR	_sound
	LEAS	4,S
* Useless label L00594 removed
* Useless label L00595 removed
	LBRA	L00596		jump over else clause
L00589	EQU	*		else clause of if() started at dtet.c:753
* Line dtet.c:794
* Line dtet.c:759: if
	LDB	_key+0,PCR	variable key
	CMPB	#$0D
	BEQ	L00597
* optim: branchToNextLocation
* Useless label L00599 removed
* optim: removeLoadInComparisonWithTwoValues
	CMPB	#$20
	LBNE	L00598		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
L00597	EQU	*		then clause of if() started at dtet.c:759
* Line dtet.c:759
* Line dtet.c:760: if
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:102
* optim: loadCmpZeroBeqOrBne
	BNE	L00601
* optim: branchToNextLocation
* Useless label L00600 removed
* Line dtet.c:760
* Line dtet.c:760: function call: sound()
	CLRA
	CLRB
	PSHS	B,A		C function argument 2 of sound(): int
	LDB	#$64		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of sound(): int
	LBSR	_sound
	LEAS	4,S
L00601	EQU	*		else clause of if() started at dtet.c:760
* Useless label L00602 removed
* Line dtet.c:761: function call: drawMenuPtr()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 4 of drawMenuPtr(): int
	LDB	-1,U		variable `optNumber', declared at dtet.c:740
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 3 of drawMenuPtr(): char
	CLRA
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 2 of drawMenuPtr(): int
* optim: stripExtraClrA_B
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 1 of drawMenuPtr(): int
	LBSR	_drawMenuPtr
	LEAS	8,S
* Line dtet.c:762: switch
	LDB	-1,U		variable `optNumber', declared at dtet.c:740
* Switch at dtet.c:762 has 6 non-ignored case values.
* Switch at dtet.c:762 uses jump table: IF_ELSE=39, JUMP_TABLE=32
	SEX
	LEAX	L00611,PCR	jump table for switch at dtet.c:762
signedJumpTableSwitch	IMPORT
	LBRA	signedJumpTableSwitch
	FDB	0		minimum case value
	FDB	5		maximum case value
	FDB	L00610-L00611	offset of default label
L00611	EQU	*
	FDB	L00604-L00611
	FDB	L00605-L00611
	FDB	L00606-L00611
	FDB	L00607-L00611
	FDB	L00608-L00611
	FDB	L00609-L00611
L00604	EQU	*		case 0
* Line dtet.c:764: assignment: =
	CLR	_numPlayers+0,PCR	variable numPlayers
* Line dtet.c:765: assignment: =
	CLRA
* CLRB  optim: optimizeStackOperations1
* PSHS B optim: optimizeStackOperations1
* optim: optimizeLeax
	LDB	#0		optim: optimizeStackOperations1
	STB	_gameOver+0,PCR	optim: optimizeLeax
* Line dtet.c:766: assignment: =
* LDD #$01 optim: optimizeStackOperations1
* PSHS B optim: optimizeStackOperations1
* optim: optimizeLeax
	LDB	#1		optim: optimizeStackOperations1
	STB	_gameOver+1,PCR	optim: optimizeLeax
	LBRA	L00151		return (dtet.c:767)
L00605	EQU	*		case 1
* Line dtet.c:769: assignment: =
	LDB	#$01
	STB	_numPlayers+0,PCR	variable numPlayers
* Line dtet.c:770: assignment: =
	CLRA
* CLRB  optim: optimizeStackOperations1
* PSHS B optim: optimizeStackOperations1
* optim: optimizeLeax
	LDB	#0		optim: optimizeStackOperations1
	STB	_gameOver+0,PCR	optim: optimizeLeax
* Line dtet.c:771: assignment: =
* optim: stripExtraClrA_B
* CLRB  optim: optimizeStackOperations1
* PSHS B optim: optimizeStackOperations1
* optim: optimizeLeax
	LDB	#0		optim: optimizeStackOperations1
	STB	_gameOver+1,PCR	optim: optimizeLeax
	LBRA	L00151		return (dtet.c:772)
L00606	EQU	*		case 2
* Line dtet.c:774: function call: drawHighScores()
	LBSR	_drawHighScores
* Line dtet.c:775: if
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:102
* optim: loadCmpZeroBeqOrBne
	BNE	L00603
* optim: branchToNextLocation
* Useless label L00612 removed
* Line dtet.c:775
* Line dtet.c:775: function call: sound()
	CLRA
	CLRB
	PSHS	B,A		C function argument 2 of sound(): int
	LDB	#$64		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of sound(): int
	LBSR	_sound
	LEAS	4,S
* Useless label L00613 removed
* Useless label L00614 removed
	BRA	L00603		break
L00607	EQU	*		case 3
* Line dtet.c:778: function call: optionsMenu()
	LBSR	_optionsMenu
	BRA	L00603		break
L00608	EQU	*		case 4
* Line dtet.c:781: function call: drawHelp()
	LBSR	_drawHelp
* Line dtet.c:782: if
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:102
* optim: loadCmpZeroBeqOrBne
	BNE	L00603
* optim: branchToNextLocation
* Useless label L00615 removed
* Line dtet.c:782
* Line dtet.c:782: function call: sound()
	CLRA
	CLRB
	PSHS	B,A		C function argument 2 of sound(): int
	LDB	#$64		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of sound(): int
	LBSR	_sound
	LEAS	4,S
* Useless label L00616 removed
* Useless label L00617 removed
	BRA	L00603		break
L00609	EQU	*		case 5
* Line dtet.c:785: function call: cls()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of cls(): int
	LBSR	_cls
	LEAS	2,S
* Line dtet.c:786: function call: printf()
	LEAX	S00222,PCR	"THANKS FOR PLAYING DRAGONTET!\n"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:787: function call: exit()
	CLRA
	CLRB
	PSHS	B,A		C function argument 1 of exit(): int
	LBSR	_exit
	LEAS	2,S
L00610	EQU	*		default
* optim: branchToNextLocation
L00603	EQU	*		end of switch
* Line dtet.c:791: function call: drawMenu()
	LBSR	_drawMenu
* Line dtet.c:792: function call: drawMenuPtr()
	CLRA
	CLRB
	PSHS	B,A		C function argument 4 of drawMenuPtr(): int
	LDB	-1,U		variable `optNumber', declared at dtet.c:740
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 3 of drawMenuPtr(): char
	CLRA
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 2 of drawMenuPtr(): int
* optim: stripExtraClrA_B
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 1 of drawMenuPtr(): int
	LBSR	_drawMenuPtr
	LEAS	8,S
L00598	EQU	*		else clause of if() started at dtet.c:759
* Useless label L00618 removed
L00596	EQU	*		end of if() started at dtet.c:753
L00587	EQU	*		end of if() started at dtet.c:747
* Line dtet.c:794: function call: delay()
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A		C function argument 1 of delay(): int
	LBSR	_delay
	LEAS	2,S
* Useless label L00577 removed
	LBRA	L00576		go to start of do-while body
* Useless label L00578 removed
L00151	EQU	*		end of menu()
	LEAS	,U
	PULS	U,PC
* END FUNCTION menu(): defined at dtet.c:739
funcend_menu	EQU *
funcsize_menu	EQU	funcend_menu-_menu
_init	EXPORT


*******************************************************************************

* FUNCTION init(): defined at dtet.c:800
_init	EQU	*
* Prototype: void init(...)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-1,S
* Local non-static variable(s):
*     -1,U:    1 byte : i: unsigned char: line 801
* Line dtet.c:802: assignment: =
	CLRA
	CLRB
	STD	$0112
* Line dtet.c:803: function call: menu()
	LBSR	_menu
* Line dtet.c:804: function call: cls()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of cls(): int
	LBSR	_cls
	LEAS	2,S
* Line dtet.c:805: function call: roundWindow()
	CLRA
	CLRB
	PSHS	B,A		C function argument 5 of roundWindow(): int
	LDB	#$0F		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 4 of roundWindow(): int
	LDB	#$01		optim: changeLoadDToLoadB
* optim: removePushBBeforeSubB
	NEGB			optim: removePushBBeforeSubB
	ADDB	_pitLeft+1,PCR	optim: removePushBBeforeSubB
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 3 of roundWindow(): unsigned char
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 2 of roundWindow(): int
* optim: stripExtraClrA_B
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 1 of roundWindow(): int
	LBSR	_roundWindow
	LEAS	10,S
* Line dtet.c:807: for init
* Line dtet.c:807: assignment: =
	LDB	#$01
	STB	-1,U		variable i
	BRA	L00620		jump to for condition
L00619	EQU	*
* Line dtet.c:807: for body
* Line dtet.c:808: function call: printBlock()
	CLRA
	LDB	#$85		decimal 133 signed
	PSHS	B,A		C function argument 3 of printBlock(): int
	LDB	-1,U		variable `i', declared at dtet.c:801
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 2 of printBlock(): unsigned char
	LDB	#$0A		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of printBlock(): int
	LBSR	_printBlock
	LEAS	6,S
* Line dtet.c:809: function call: printBlock()
	CLRA
	LDB	#$8A		decimal 138 signed
	PSHS	B,A		C function argument 3 of printBlock(): int
	LDB	-1,U		variable `i', declared at dtet.c:801
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 2 of printBlock(): unsigned char
	LDB	#$15		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of printBlock(): int
	LBSR	_printBlock
	LEAS	6,S
* Useless label L00621 removed
* Line dtet.c:807: for increment(s)
	INC	-1,U
L00620	EQU	*
* Line dtet.c:807: for condition
	LDB	-1,U		variable i
	CMPB	#$0F
	BLO	L00619
* optim: branchToNextLocation
* Useless label L00622 removed
* Line dtet.c:812: for init
* Line dtet.c:812: assignment: =
	CLRB
	STB	-1,U		variable i
	LBRA	L00624		jump to for condition
L00623	EQU	*
* Line dtet.c:812: for body
* Line dtet.c:813: assignment: =
* Line dtet.c:813: assignment: =
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B
	LDB	-1,U		variable i
	LEAX	_previousLevel+0,PCR	address of array previousLevel
	ABX			add unsigned 8-bit offset
	LDB	,S+
	STB	,X
	PSHS	B
	LDB	-1,U		variable i
	LEAX	_level+0,PCR	address of array level
	ABX			add unsigned 8-bit offset
	LDB	,S+
	STB	,X
* Line dtet.c:814: assignment: =
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A
	LDB	-1,U		variable i
* optim: stripExtraClrA_B
	LSLB
	ROLA
	LEAX	_lines+0,PCR	address of array lines
	LEAX	D,X		add offset
	PULS	A,B		retrieve value to store
	STD	,X
* Line dtet.c:815: assignment: =
	CLRA
	CLRB
	PSHS	B,A
	LDB	-1,U		variable i
	ADDB	#$06		6
* optim: stripExtraClrA_B
	LSLB
	ROLA
	LEAX	_scores+0,PCR	address of array scores
	LEAX	D,X		add offset
	PULS	A,B		retrieve value to store
	STD	,X
* Line dtet.c:816: assignment: =
	CLRA
	LDB	#$FF		decimal 255 signed
	PSHS	B
	LDB	-1,U		variable i
	LEAX	_nextShape+0,PCR	address of array nextShape
	ABX			add unsigned 8-bit offset
	LDB	,S+
	STB	,X
* Line dtet.c:817: assignment: =
	LDB	_backgroundCharList+0,PCR	index 0 in array backgroundCharList[]
	PSHS	B
	LDB	-1,U		variable i
	LEAX	_backgroundChar+0,PCR	address of array backgroundChar
	ABX			add unsigned 8-bit offset
	LDB	,S+
	STB	,X
* Line dtet.c:818: assignment: =
* optim: stripExtraClrA_B
	CLRB
	PSHS	B
	LDB	-1,U		variable i
	LEAX	_linesPiecesPlayed+0,PCR	address of array linesPiecesPlayed
	ABX			add unsigned 8-bit offset
	LDB	,S+
	STB	,X
* Line dtet.c:819: function call: createShape()
	LDB	-1,U		variable `i', declared at dtet.c:801
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of createShape(): unsigned char
	LBSR	_createShape
	LEAS	2,S
* Line dtet.c:820: function call: memset()
	CLRA
	LDB	#$A0		constant expression: 160 decimal, signed
	PSHS	B,A		C function argument 3 of memset(): int
	LDB	#$30		decimal 48 signed
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 2 of memset(): char
	LDB	-1,U		variable i
* optim: stripOpToDeadReg
	LDA	#160		size of array element
	MUL			get offset in bytes in D
	LEAX	_pit+0,PCR	address of array pit
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	PSHS	B,A		C function argument 1 of memset(): char[]
	LBSR	_memset
	LEAS	6,S
* Line dtet.c:821: function call: drawPit()
	LDB	-1,U		variable `i', declared at dtet.c:801
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 1 of drawPit(): unsigned char
	LBSR	_drawPit
	LEAS	2,S
* Useless label L00625 removed
* Line dtet.c:812: for increment(s)
	INC	-1,U
L00624	EQU	*
* Line dtet.c:812: for condition
	LDB	-1,U		variable i
	CMPB	#$02
	LBLO	L00623
* optim: branchToNextLocation
* Useless label L00626 removed
* Line dtet.c:823: assignment: =
	CLR	_cancelled+0,PCR	variable cancelled
* Line dtet.c:824: assignment: =
	CLR	_lastLines+0,PCR	variable lastLines
* Line dtet.c:825: assignment: =
	CLRA
	CLRB
	STD	_lastPoints+0,PCR
* Line dtet.c:826: function call: displayStatus()
	LBSR	_displayStatus
* Line dtet.c:827: if
	LDB	_numPlayers+0,PCR	variable `numPlayers', declared at dtet.c:84
* optim: loadCmpZeroBeqOrBne
	LBNE	L00628		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00627 removed
* Line dtet.c:827
* Line dtet.c:828: function call: locate()
	CLRA
	LDB	#$06		decimal 6 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$17		decimal 23 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:828: function call: printf()
	LEAX	S00223,PCR	" PLEASE "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:829: function call: locate()
	CLRA
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$17		decimal 23 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:829: function call: printf()
	LEAX	S00224,PCR	"  WAIT  "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:830: function call: locate()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$17		decimal 23 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:830: function call: printf()
	LEAX	S00225,PCR	" DRAGON "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:831: function call: locate()
	CLRA
	LDB	#$09		decimal 9 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$17		decimal 23 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:831: function call: printf()
	LEAX	S00226,PCR	"   2!   "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
L00628	EQU	*		else clause of if() started at dtet.c:827
* Useless label L00629 removed
* Useless label L00152 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION init(): defined at dtet.c:800
funcend_init	EQU *
funcsize_init	EQU	funcend_init-_init
_rotateKeyPressed	EXPORT


*******************************************************************************

* FUNCTION rotateKeyPressed(): defined at dtet.c:836
_rotateKeyPressed	EQU	*
* Prototype: void rotateKeyPressed(unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-1,S
* Formal parameter(s):
*      5,U:    1 byte : i: unsigned char: line 836
* Local non-static variable(s):
*     -1,U:    1 byte : nextAngle: unsigned char: line 837
* Line dtet.c:837: init of variable nextAngle
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B
	LDB	5,U		variable i
	LEAX	_shapeAngle+0,PCR	address of array shapeAngle
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	ADDB	,S+
	ANDB	#$03		modulo 4
	STB	-1,U		variable nextAngle
* Line dtet.c:838: function call: getRotatedShapeMap()
	LDB	5,U		variable i
* optim: stripExtraClrA_B
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LEAX	_rotatedMap+0,PCR	address of array rotatedMap
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	PSHS	B,A		C function argument 3 of getRotatedShapeMap(): char[]
	LDB	-1,U		variable `nextAngle', declared at dtet.c:837
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of getRotatedShapeMap(): unsigned char
	LDB	5,U		variable i
	LEAX	_shape+0,PCR	address of array shape
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of getRotatedShapeMap(): unsigned char
	LBSR	_getRotatedShapeMap
	LEAS	6,S
* Line dtet.c:839: if
* Line dtet.c:839: function call: shapeCanMove()
	LDB	5,U		variable `i', declared at dtet.c:836
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 4 of shapeCanMove(): unsigned char
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 3 of shapeCanMove(): int
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 2 of shapeCanMove(): int
	LDB	5,U		variable i
* optim: stripExtraClrA_B
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LEAX	_rotatedMap+0,PCR	address of array rotatedMap
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	PSHS	B,A		C function argument 1 of shapeCanMove(): char[]
	LBSR	_shapeCanMove
	LEAS	8,S
	TSTB
	LBEQ	L00631		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00630 removed
* Line dtet.c:839
* Line dtet.c:840: assignment: =
	LDB	-1,U		variable `nextAngle', declared at dtet.c:837
	PSHS	B
	LDB	5,U		variable i
	LEAX	_shapeAngle+0,PCR	address of array shapeAngle
	ABX			add unsigned 8-bit offset
	LDB	,S+
	STB	,X
* Line dtet.c:841: function call: drawShape()
	LDB	5,U		variable `i', declared at dtet.c:836
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawShape(): unsigned char
	LDB	#$01		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of drawShape(): int
	LBSR	_drawShape
	LEAS	4,S
* Line dtet.c:842: function call: strncpy()
	CLRA
	LDB	#$10		decimal 16 signed
	PSHS	B,A		C function argument 3 of strncpy(): int
	LDB	5,U		variable i
* optim: stripExtraClrA_B
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LEAX	_rotatedMap+0,PCR	address of array rotatedMap
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	PSHS	B,A		C function argument 2 of strncpy(): char[]
	LDB	5,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LEAX	_shapeMap+0,PCR	address of array shapeMap
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	PSHS	B,A		C function argument 1 of strncpy(): char[]
	LBSR	_strncpy
	LEAS	6,S
* Line dtet.c:843: function call: drawShape()
	LDB	5,U		variable `i', declared at dtet.c:836
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawShape(): unsigned char
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of drawShape(): int
	LBSR	_drawShape
	LEAS	4,S
L00631	EQU	*		else clause of if() started at dtet.c:839
* Useless label L00632 removed
* Useless label L00153 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION rotateKeyPressed(): defined at dtet.c:836
funcend_rotateKeyPressed	EQU *
funcsize_rotateKeyPressed	EQU	funcend_rotateKeyPressed-_rotateKeyPressed
_moveLeftKeyPressed	EXPORT


*******************************************************************************

* FUNCTION moveLeftKeyPressed(): defined at dtet.c:848
_moveLeftKeyPressed	EQU	*
* Prototype: void moveLeftKeyPressed(unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
* Formal parameter(s):
*      5,U:    1 byte : i: unsigned char: line 848
* Line dtet.c:849: if
* Line dtet.c:849: function call: shapeCanMove()
	LDB	5,U		variable `i', declared at dtet.c:848
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 4 of shapeCanMove(): unsigned char
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 3 of shapeCanMove(): int
	LDD	#$FFFF		constant expression: 65535 decimal, signed
	PSHS	B,A		C function argument 2 of shapeCanMove(): int
	LDB	5,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LEAX	_shapeMap+0,PCR	address of array shapeMap
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	PSHS	B,A		C function argument 1 of shapeCanMove(): char[]
	LBSR	_shapeCanMove
	LEAS	8,S
	TSTB
	BEQ	L00634		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00633 removed
* Line dtet.c:849
* Line dtet.c:850: function call: drawShape()
	LDB	5,U		variable `i', declared at dtet.c:848
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawShape(): unsigned char
	LDB	#$01		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of drawShape(): int
	LBSR	_drawShape
	LEAS	4,S
* Line dtet.c:851: post-decrement
	LDB	5,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_shapeX+0,PCR	address of array shapeX
	LEAX	D,X		add offset
	LDD	,X
	ADDD	#-1
	STD	,X
* Line dtet.c:852: function call: drawShape()
	LDB	5,U		variable `i', declared at dtet.c:848
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawShape(): unsigned char
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of drawShape(): int
	LBSR	_drawShape
	LEAS	4,S
L00634	EQU	*		else clause of if() started at dtet.c:849
* Useless label L00635 removed
* Useless label L00154 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION moveLeftKeyPressed(): defined at dtet.c:848
funcend_moveLeftKeyPressed	EQU *
funcsize_moveLeftKeyPressed	EQU	funcend_moveLeftKeyPressed-_moveLeftKeyPressed
_moveRightKeyPressed	EXPORT


*******************************************************************************

* FUNCTION moveRightKeyPressed(): defined at dtet.c:857
_moveRightKeyPressed	EQU	*
* Prototype: void moveRightKeyPressed(unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
* Formal parameter(s):
*      5,U:    1 byte : i: unsigned char: line 857
* Line dtet.c:858: if
* Line dtet.c:858: function call: shapeCanMove()
	LDB	5,U		variable `i', declared at dtet.c:857
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 4 of shapeCanMove(): unsigned char
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 3 of shapeCanMove(): int
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 2 of shapeCanMove(): int
	LDB	5,U		variable i
* optim: removeClr
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LEAX	_shapeMap+0,PCR	address of array shapeMap
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	PSHS	B,A		C function argument 1 of shapeCanMove(): char[]
	LBSR	_shapeCanMove
	LEAS	8,S
	TSTB
	BEQ	L00637		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00636 removed
* Line dtet.c:858
* Line dtet.c:859: function call: drawShape()
	LDB	5,U		variable `i', declared at dtet.c:857
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawShape(): unsigned char
	LDB	#$01		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of drawShape(): int
	LBSR	_drawShape
	LEAS	4,S
* Line dtet.c:860: post-increment
	LDB	5,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_shapeX+0,PCR	address of array shapeX
	LEAX	D,X		add offset
	LDD	,X
	ADDD	#1
	STD	,X
* Line dtet.c:861: function call: drawShape()
	LDB	5,U		variable `i', declared at dtet.c:857
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawShape(): unsigned char
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of drawShape(): int
	LBSR	_drawShape
	LEAS	4,S
L00637	EQU	*		else clause of if() started at dtet.c:858
* Useless label L00638 removed
* Useless label L00155 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION moveRightKeyPressed(): defined at dtet.c:857
funcend_moveRightKeyPressed	EQU *
funcsize_moveRightKeyPressed	EQU	funcend_moveRightKeyPressed-_moveRightKeyPressed
_canProcessInput	EXPORT


*******************************************************************************

* FUNCTION canProcessInput(): defined at dtet.c:870
_canProcessInput	EQU	*
* Prototype: unsigned char canProcessInput(unsigned char, unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-2,S
* Formal parameter(s):
*      5,U:    1 byte : i: unsigned char: line 870
*      7,U:    1 byte : action: unsigned char: line 870
* Local non-static variable(s):
*     -2,U:    2 bytes: currentTime: unsigned int: line 871
* Line dtet.c:871: init of variable currentTime
	LDD	$0112		decimal 274
	STD	-2,U		variable currentTime
* Line dtet.c:872: if
	CLRA
* optim: stripConsecutiveLoadsToSameReg
* PSHS B,A optim: optimizeStackOperations1
	LDB	7,U		variable action
* optim: stripExtraClrA_B
	LSLB
	ROLA
	PSHS	B,A		preserve array index
	LDB	5,U		variable i
* optim: stripOpToDeadReg
	LDA	#6		size of array element
	MUL			get offset in bytes in D
	LEAX	_lastInputTime+0,PCR	address of array lastInputTime
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDD	-2,U		variable `currentTime', declared at dtet.c:871
	SUBD	,X		optim: optimizeStackOperations4
	CMPD	#6		optim: optimizeStackOperations1
	BLO	L00640		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00639 removed
* Line dtet.c:872
* Line dtet.c:873: assignment: =
	LDD	-2,U		variable `currentTime', declared at dtet.c:871
	PSHS	B,A
	LDB	7,U		variable action
	CLRA			index expression is of byte type
	LSLB
	ROLA
	PSHS	B,A		preserve array index
	LDB	5,U		variable i
* optim: stripOpToDeadReg
	LDA	#6		size of array element
	MUL			get offset in bytes in D
	LEAX	_lastInputTime+0,PCR	address of array lastInputTime
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	PULS	A,B		retrieve value to store
	STD	,X
	LDB	#1
	BRA	L00156		return (dtet.c:874)
L00640	EQU	*		else clause of if() started at dtet.c:872
* Useless label L00641 removed
	CLRB
* optim: branchToNextLocation
L00156	EQU	*		end of canProcessInput()
	LEAS	,U
	PULS	U,PC
* END FUNCTION canProcessInput(): defined at dtet.c:870
funcend_canProcessInput	EQU *
funcsize_canProcessInput	EQU	funcend_canProcessInput-_canProcessInput
_mainLoop	EXPORT


*******************************************************************************

* FUNCTION mainLoop(): defined at dtet.c:880
_mainLoop	EQU	*
* Prototype: void mainLoop(...)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-3,S
* Local non-static variable(s):
*     -3,U:    2 bytes: joystickPositions: const unsigned char *: line 889
*     -1,U:    1 byte : i: unsigned char: line 881
* Line dtet.c:883: function call: playTune()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 3 of playTune(): int
	LEAX	_tune2Durations+0,PCR	address of array tune2Durations
	PSHS	X		C function argument 2 of playTune(): const unsigned char[]
	LEAX	_tune2Notes+0,PCR	address of array tune2Notes
	PSHS	X		C function argument 1 of playTune(): const unsigned char[]
	LBSR	_playTune
	LEAS	6,S
* Line dtet.c:886: assignment: =
* Line dtet.c:886: assignment: =
	LDD	$0112		decimal 274
* optim: stripUselessPushPull
* optim: optimizeLeax
* optim: stripUselessPushPull
	STD	_startTime+2,PCR	optim: optimizeLeax
* optim: stripUselessPushPull
* optim: optimizeLeax
* optim: stripUselessPushPull
	STD	_startTime+0,PCR	optim: optimizeLeax
* Line dtet.c:888: while
	LBRA	L00643		jump to while condition
L00642	EQU	*		while body
* Line dtet.c:889: init of variable joystickPositions
* Line dtet.c:889: function call: readJoystickPositions()
	LBSR	_readJoystickPositions
	STD	-3,U		variable joystickPositions
* Line dtet.c:919: if
* Line dtet.c:919: function call: isKeyPressed()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$FE		decimal 254 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BEQ	L00646		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00645 removed
* Line dtet.c:919
* Line dtet.c:920: while
	BRA	L00648		jump to while condition
L00647	EQU	*		while body
L00648	EQU	*		while condition at dtet.c:920
* Line dtet.c:920: function call: inkey()
	LBSR	_inkey
	TSTB
	BNE	L00647
* optim: branchToNextLocation
* Useless label L00649 removed
* Line dtet.c:921: while
	BRA	L00651		jump to while condition
L00650	EQU	*		while body
* Line dtet.c:921: function call: delay()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of delay(): int
	LBSR	_delay
	LEAS	2,S
L00651	EQU	*		while condition at dtet.c:921
* Line dtet.c:921: function call: inkey()
	LBSR	_inkey
	TSTB
	BEQ	L00650
* optim: branchToNextLocation
* Useless label L00652 removed
* Line dtet.c:922: assignment: =
* Line dtet.c:922: assignment: =
	LDD	$0112		decimal 274
* optim: stripUselessPushPull
* optim: optimizeLeax
* optim: stripUselessPushPull
	STD	_startTime+2,PCR	optim: optimizeLeax
* optim: stripUselessPushPull
* optim: optimizeLeax
* optim: stripUselessPushPull
	STD	_startTime+0,PCR	optim: optimizeLeax
	LBRA	L00643		continue
	LBRA	L00653		jump over else clause
L00646	EQU	*		else clause of if() started at dtet.c:919
* Line dtet.c:937
* Line dtet.c:925: if
* Line dtet.c:925: function call: isKeyPressed()
	CLRA
	LDB	#$20		decimal 32 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$FE		decimal 254 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BEQ	L00655		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00654 removed
* Line dtet.c:925
* Line dtet.c:926: if
	LDB	_gameOver+0,PCR	index 0 in array gameOver[]
* optim: loadCmpZeroBeqOrBne
	BEQ	L00656		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00658 removed
	LDB	_gameOver+1,PCR	index 1 in array gameOver[]
* optim: loadCmpZeroBeqOrBne
	LBNE	L00644
* optim: branchToNextLocation
L00656	EQU	*		then clause of if() started at dtet.c:926
* Line dtet.c:927
* Line dtet.c:927: assignment: =
	LDB	#$01
	STB	_cancelled+0,PCR	variable cancelled
* Useless label L00657 removed
* Useless label L00659 removed
	LBRA	L00644		break
	BRA	L00660		jump over else clause
L00655	EQU	*		else clause of if() started at dtet.c:925
* Line dtet.c:937
* Line dtet.c:932: if
* Line dtet.c:930: function call: isKeyPressed()
	CLRA
	LDB	#$40		decimal 64 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$FE		decimal 254 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BNE	L00663
* optim: branchToNextLocation
* Useless label L00664 removed
* Line dtet.c:931: function call: isKeyPressed()
	CLRA
	LDB	#$20		decimal 32 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$7F		decimal 127 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BEQ	L00662		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
L00663	EQU	*
	LDB	_gameOver+0,PCR	index 0 in array gameOver[]
* optim: loadCmpZeroBeqOrBne
	BEQ	L00662		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00665 removed
	LDB	_gameOver+1,PCR	index 1 in array gameOver[]
* optim: loadCmpZeroBeqOrBne
	LBNE	L00644		 (optim: condBranchOverUncondBranch) (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00661 removed
* Line dtet.c:932
* optim: condBranchOverUncondBranch
L00662	EQU	*		else clause of if() started at dtet.c:932
* Useless label L00666 removed
L00660	EQU	*		end of if() started at dtet.c:925
L00653	EQU	*		end of if() started at dtet.c:919
* Line dtet.c:939: if
* Line dtet.c:937: function call: isKeyPressed()
	CLRA
	LDB	#$10		decimal 16 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$7F		decimal 127 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BNE	L00667
* optim: branchToNextLocation
* Useless label L00670 removed
* Line dtet.c:938: function call: isKeyPressed()
	CLRA
	LDB	#$20		decimal 32 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$F7		decimal 247 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BNE	L00667
* optim: branchToNextLocation
* Useless label L00669 removed
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
	LDX	-3,U		get pointer value
* optim: optimizeLeax
	LDB	3,X		optim: optimizeLeax
* optim: stripExtraClrA_B
	CMPD	#16		optim: optimizeStackOperations1
	BHS	L00668		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
L00667	EQU	*		then clause of if() started at dtet.c:939
* Line dtet.c:942
* Line dtet.c:940: if
* Line dtet.c:940: function call: canProcessInput()
	CLRA
	CLRB
	PSHS	B,A		C function argument 2 of canProcessInput(): int
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of canProcessInput(): int
	LBSR	_canProcessInput
	LEAS	4,S
	TSTB
	BEQ	L00672		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00671 removed
* Line dtet.c:940
* Line dtet.c:940: function call: rotateKeyPressed()
	CLRA
	CLRB
	PSHS	B,A		C function argument 1 of rotateKeyPressed(): int
	LBSR	_rotateKeyPressed
	LEAS	2,S
L00672	EQU	*		else clause of if() started at dtet.c:940
* Useless label L00673 removed
L00668	EQU	*		else clause of if() started at dtet.c:939
* Useless label L00674 removed
* Line dtet.c:944: if
* Line dtet.c:942: function call: isKeyPressed()
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$FD		decimal 253 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BNE	L00675
* optim: branchToNextLocation
* Useless label L00678 removed
* Line dtet.c:943: function call: isKeyPressed()
	CLRA
	LDB	#$20		decimal 32 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$DF		decimal 223 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BNE	L00675
* optim: branchToNextLocation
* Useless label L00677 removed
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
	LDX	-3,U		get pointer value
* optim: optimizeLeax
	LDB	2,X		optim: optimizeLeax
* optim: stripExtraClrA_B
	CMPD	#16		optim: optimizeStackOperations1
	BHS	L00676		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
L00675	EQU	*		then clause of if() started at dtet.c:944
* Line dtet.c:947
* Line dtet.c:945: if
* Line dtet.c:945: function call: canProcessInput()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 2 of canProcessInput(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of canProcessInput(): int
	LBSR	_canProcessInput
	LEAS	4,S
	TSTB
	BEQ	L00680		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00679 removed
* Line dtet.c:945
* Line dtet.c:945: function call: moveLeftKeyPressed()
	CLRA
	CLRB
	PSHS	B,A		C function argument 1 of moveLeftKeyPressed(): int
	LBSR	_moveLeftKeyPressed
	LEAS	2,S
L00680	EQU	*		else clause of if() started at dtet.c:945
* Useless label L00681 removed
L00676	EQU	*		else clause of if() started at dtet.c:944
* Useless label L00682 removed
* Line dtet.c:949: if
* Line dtet.c:947: function call: isKeyPressed()
	CLRA
	LDB	#$10		decimal 16 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$F7		decimal 247 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BNE	L00683
* optim: branchToNextLocation
* Useless label L00686 removed
* Line dtet.c:948: function call: isKeyPressed()
	CLRA
	LDB	#$20		decimal 32 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$EF		decimal 239 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BNE	L00683
* optim: branchToNextLocation
* Useless label L00685 removed
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
	LDX	-3,U		get pointer value
* optim: optimizeLeax
	LDB	3,X		optim: optimizeLeax
* optim: stripExtraClrA_B
	CMPD	#48		optim: optimizeStackOperations1
	BLS	L00684		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
L00683	EQU	*		then clause of if() started at dtet.c:949
* Line dtet.c:950
* Line dtet.c:950: assignment: =
	CLRA
	CLRB
* optim: stripUselessPushPull
	LEAX	_dropRate+0,PCR	index 0 in array dropRate[]
* optim: stripUselessPushPull
	STD	,X
L00684	EQU	*		else clause of if() started at dtet.c:949
* Useless label L00687 removed
* Line dtet.c:954: if
* Line dtet.c:952: function call: isKeyPressed()
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$EF		decimal 239 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BNE	L00688
* optim: branchToNextLocation
* Useless label L00691 removed
* Line dtet.c:953: function call: isKeyPressed()
	CLRA
	LDB	#$20		decimal 32 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$BF		decimal 191 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BNE	L00688
* optim: branchToNextLocation
* Useless label L00690 removed
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
	LDX	-3,U		get pointer value
* optim: optimizeLeax
	LDB	2,X		optim: optimizeLeax
* optim: stripExtraClrA_B
	CMPD	#48		optim: optimizeStackOperations1
	BLS	L00689		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
L00688	EQU	*		then clause of if() started at dtet.c:954
* Line dtet.c:958
* Line dtet.c:955: if
* Line dtet.c:955: function call: canProcessInput()
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A		C function argument 2 of canProcessInput(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of canProcessInput(): int
	LBSR	_canProcessInput
	LEAS	4,S
	TSTB
	BEQ	L00693		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00692 removed
* Line dtet.c:955
* Line dtet.c:955: function call: moveRightKeyPressed()
	CLRA
	CLRB
	PSHS	B,A		C function argument 1 of moveRightKeyPressed(): int
	LBSR	_moveRightKeyPressed
	LEAS	2,S
L00693	EQU	*		else clause of if() started at dtet.c:955
* Useless label L00694 removed
L00689	EQU	*		else clause of if() started at dtet.c:954
* Useless label L00695 removed
* Line dtet.c:958: if
	LDB	_numPlayers+0,PCR	variable numPlayers
* optim: removeCMPZeroAfterLDIfBHI (BHI->BNE)
	LBEQ	L00697		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00696 removed
* Line dtet.c:958
* Line dtet.c:961: if
* Line dtet.c:960: function call: isKeyPressed()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$FD		decimal 253 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BNE	L00698
* optim: branchToNextLocation
* Useless label L00700 removed
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
	LDX	-3,U		get pointer value
* optim: optimizeLeax
	LDB	1,X		optim: optimizeLeax
* optim: stripExtraClrA_B
	CMPD	#16		optim: optimizeStackOperations1
	BHS	L00699		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
L00698	EQU	*		then clause of if() started at dtet.c:961
* Line dtet.c:964
* Line dtet.c:962: if
* Line dtet.c:962: function call: canProcessInput()
	CLRA
	CLRB
	PSHS	B,A		C function argument 2 of canProcessInput(): int
	LDB	#$01		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of canProcessInput(): int
	LBSR	_canProcessInput
	LEAS	4,S
	TSTB
	BEQ	L00702		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00701 removed
* Line dtet.c:962
* Line dtet.c:962: function call: rotateKeyPressed()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of rotateKeyPressed(): int
	LBSR	_rotateKeyPressed
	LEAS	2,S
L00702	EQU	*		else clause of if() started at dtet.c:962
* Useless label L00703 removed
L00699	EQU	*		else clause of if() started at dtet.c:961
* Useless label L00704 removed
* Line dtet.c:965: if
* Line dtet.c:964: function call: isKeyPressed()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$FB		decimal 251 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BNE	L00705
* optim: branchToNextLocation
* Useless label L00707 removed
	CLRA
	LDB	#$10		decimal 16 signed
	PSHS	B,A
* optim: optimizeLdx
	LDB	[-3,U]		optim: optimizeLdx
* optim: stripExtraClrA_B
	CMPD	,S++
	BHS	L00706		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
L00705	EQU	*		then clause of if() started at dtet.c:965
* Line dtet.c:968
* Line dtet.c:966: if
* Line dtet.c:966: function call: canProcessInput()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 2 of canProcessInput(): int
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of canProcessInput(): int
	LBSR	_canProcessInput
	LEAS	4,S
	TSTB
	BEQ	L00709		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00708 removed
* Line dtet.c:966
* Line dtet.c:966: function call: moveLeftKeyPressed()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of moveLeftKeyPressed(): int
	LBSR	_moveLeftKeyPressed
	LEAS	2,S
L00709	EQU	*		else clause of if() started at dtet.c:966
* Useless label L00710 removed
L00706	EQU	*		else clause of if() started at dtet.c:965
* Useless label L00711 removed
* Line dtet.c:969: if
* Line dtet.c:968: function call: isKeyPressed()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$F7		decimal 247 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BNE	L00712
* optim: branchToNextLocation
* Useless label L00714 removed
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
	LDX	-3,U		get pointer value
* optim: optimizeLeax
	LDB	1,X		optim: optimizeLeax
* optim: stripExtraClrA_B
	CMPD	#48		optim: optimizeStackOperations1
	BLS	L00713		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
L00712	EQU	*		then clause of if() started at dtet.c:969
* Line dtet.c:970
* Line dtet.c:970: assignment: =
	CLRA
	CLRB
* optim: stripUselessPushPull
	LEAX	_dropRate+2,PCR	index 1 in array dropRate[]
* optim: stripUselessPushPull
	STD	,X
L00713	EQU	*		else clause of if() started at dtet.c:969
* Useless label L00715 removed
* Line dtet.c:973: if
* Line dtet.c:972: function call: isKeyPressed()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$EF		decimal 239 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BNE	L00716
* optim: branchToNextLocation
* Useless label L00718 removed
	CLRA
	LDB	#$30		decimal 48 signed
	PSHS	B,A
* optim: optimizeLdx
	LDB	[-3,U]		optim: optimizeLdx
* optim: stripExtraClrA_B
	CMPD	,S++
	BLS	L00717		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
L00716	EQU	*		then clause of if() started at dtet.c:973
* Line dtet.c:975
* Line dtet.c:974: if
* Line dtet.c:974: function call: canProcessInput()
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A		C function argument 2 of canProcessInput(): int
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of canProcessInput(): int
	LBSR	_canProcessInput
	LEAS	4,S
	TSTB
	BEQ	L00720		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00719 removed
* Line dtet.c:974
* Line dtet.c:974: function call: moveRightKeyPressed()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of moveRightKeyPressed(): int
	LBSR	_moveRightKeyPressed
	LEAS	2,S
L00720	EQU	*		else clause of if() started at dtet.c:974
* Useless label L00721 removed
L00717	EQU	*		else clause of if() started at dtet.c:973
* Useless label L00722 removed
L00697	EQU	*		else clause of if() started at dtet.c:958
* Useless label L00723 removed
* Line dtet.c:1040: for init
* Line dtet.c:1040: assignment: =
	CLRB
	STB	-1,U		variable i
	LBRA	L00725		jump to for condition
L00724	EQU	*
* Line dtet.c:1040: for body
* Line dtet.c:1041: if
	LDB	-1,U		variable i
	LEAX	_gameOver+0,PCR	address of array gameOver
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
* optim: loadCmpZeroBeqOrBne
	BNE	L00729
* optim: branchToNextLocation
* Useless label L00730 removed
	LDB	-1,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_dropRate+0,PCR	address of array dropRate
* optimizeLoadDX
	LDD	D,X		get r-value
	PSHS	B,A
	LDB	-1,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_startTime+0,PCR	address of array startTime
* optimizeLoadDX
	LDD	D,X		get r-value
	ADDD	,S++
	PSHS	B,A
	LDD	$0112		decimal 274
	CMPD	,S++
	BLO	L00729		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00728 removed
* Line dtet.c:1041
* Line dtet.c:1042: function call: dropShape()
	LDB	-1,U		variable `i', declared at dtet.c:881
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 1 of dropShape(): unsigned char
	LBSR	_dropShape
	LEAS	2,S
* Line dtet.c:1043: assignment: =
	LDD	$0112		decimal 274
	PSHS	B,A
	LDB	-1,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_startTime+0,PCR	address of array startTime
	LEAX	D,X		add offset
	PULS	A,B		retrieve value to store
	STD	,X
L00729	EQU	*		else clause of if() started at dtet.c:1041
* Useless label L00731 removed
* Useless label L00726 removed
* Line dtet.c:1040: for increment(s)
	INC	-1,U
L00725	EQU	*
* Line dtet.c:1040: for condition
	LDB	-1,U		variable i
	CMPB	_numPlayers+0,PCR	variable numPlayers
	LBLS	L00724
* optim: branchToNextLocation
* Useless label L00727 removed
L00643	EQU	*		while condition at dtet.c:888
	LBRA	L00642		go to start of while body
L00644	EQU	*		after end of while starting at dtet.c:888
* Useless label L00157 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION mainLoop(): defined at dtet.c:880
funcend_mainLoop	EQU *
funcsize_mainLoop	EQU	funcend_mainLoop-_mainLoop
_checkScore	EXPORT


*******************************************************************************

* FUNCTION checkScore(): defined at dtet.c:1051
_checkScore	EQU	*
* Prototype: void checkScore(unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-6,S
* Formal parameter(s):
*      5,U:    1 byte : player: unsigned char: line 1051
* Local non-static variable(s):
*     -6,U:    2 bytes: response: char *: line 1064
*     -4,U:    2 bytes: i: int: line 1053
*     -2,U:    2 bytes: j: int: line 1054
* Line dtet.c:1053: init of variable i
	LDB	5,U		variable player
	ADDB	#$06		6
	CLRA
	STD	-4,U		variable i
* Line dtet.c:1055: assignment: =
* optim: stripExtraClrA_B
* CLRB  optim: optimizeStackOperations1
* PSHS B optim: optimizeStackOperations1
	LDB	5,U		variable player
	LEAX	_newScore+0,PCR	address of array newScore
	ABX			add unsigned 8-bit offset
	LDB	#0		optim: optimizeStackOperations1
	STB	,X
* Line dtet.c:1056: if
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDD	-4,U		variable i
	LSLB
	ROLA
	LEAX	_scores+0,PCR	address of array scores
* optimizeLoadDX
	LDD	D,X		get r-value
	CMPD	_scores+10,PCR	optim: optimizeStackOperations4
	LBLS	L00733		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00732 removed
* Line dtet.c:1056
* Line dtet.c:1057: function call: cls()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of cls(): int
	LBSR	_cls
	LEAS	2,S
* Line dtet.c:1058: function call: roundWindow()
	CLRA
	LDB	#$50		decimal 80 signed
	PSHS	B,A		C function argument 5 of roundWindow(): int
* optim: stripExtraClrA_B
	LDB	#$0F		decimal 15 signed
	PSHS	B,A		C function argument 4 of roundWindow(): int
* optim: stripExtraClrA_B
	LDB	#$1F		decimal 31 signed
	PSHS	B,A		C function argument 3 of roundWindow(): int
* optim: removeClr
	CLRB
	PSHS	B,A		C function argument 2 of roundWindow(): int
* optim: removeClr
* optim: removeClr
	PSHS	B,A		C function argument 1 of roundWindow(): int
	LBSR	_roundWindow
	LEAS	10,S
* Line dtet.c:1059: function call: drawHeader()
	INC	_colourShift+0,PCR
	LDB	_colourShift+0,PCR
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawHeader(): unsigned char
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of drawHeader(): int
	LBSR	_drawHeader
	LEAS	4,S
* Line dtet.c:1060: function call: locate()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:1060: function call: printf()
	LDD	-4,U		variable i
	LSLB
	ROLA
	LEAX	_scores+0,PCR	address of array scores
* optimizeLoadDX
	LDD	D,X		get r-value
	PSHS	B,A		C function argument 2 of printf(): unsigned int
	LEAX	S00227,PCR	"*** %u ***"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	4,S
* Line dtet.c:1061: function call: locate()
	CLRA
	LDB	#$0B		decimal 11 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:1061: function call: printf()
	LDB	5,U		variable player
	ADDB	#$01		1
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of printf(): unsigned char
	LEAX	S00228,PCR	"GOOD SCORE DRAGON %d"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	4,S
* Line dtet.c:1062: function call: locate()
	CLRA
	LDB	#$0C		decimal 12 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:1062: function call: printf()
	LEAX	S00229,PCR	"NAME?: "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:1064: init of variable response
* Line dtet.c:1064: function call: readline()
	LBSR	_readline
	STD	-6,U		variable response
* Line dtet.c:1066: if
* optim: stripOpToDeadReg
* optim: stripOpToDeadReg
* Emitted no code to cast `int' to `void *'
* PSHS B,A optim: optimizeStackOperations1
* optim: storeLoad
* optim: loadCmpZeroBeqOrBne
	BEQ	L00734
* optim: branchToNextLocation
* Useless label L00736 removed
* optim: optimizeIndexedX
	LDB	[-6,U]		optim: optimizeIndexedX
* optim: loadCmpZeroBeqOrBne
	BNE	L00735		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
L00734	EQU	*		then clause of if() started at dtet.c:1066
* Line dtet.c:1066
* Line dtet.c:1067: function call: strncpy()
	CLRA
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 3 of strncpy(): int
	LEAX	S00230,PCR	"?"
	PSHS	X		C function argument 2 of strncpy(): const char[]
	LDX	-4,U		variable i
	LDB	#11		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LEAX	_names+0,PCR	address of array names
	LEAX	D,X		add offset
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LBSR	_strncpy
	LEAS	6,S
	BRA	L00737		jump over else clause
L00735	EQU	*		else clause of if() started at dtet.c:1066
* Line dtet.c:1068
* Line dtet.c:1069: function call: strncpy()
	LDX	#$0A		optim: transformPshsDPshsD
* optim: mergePushXPushD
	LDD	-6,U		variable `response', declared at dtet.c:1064
	PSHS	X,B,A		optim: mergePushXPushD
	LDX	-4,U		variable i
	LDB	#11		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LEAX	_names+0,PCR	address of array names
	LEAX	D,X		add offset
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LBSR	_strncpy
	LEAS	6,S
L00737	EQU	*		end of if() started at dtet.c:1066
* Line dtet.c:1071: assignment: =
	CLRB
	PSHS	B
	LDX	-4,U		variable i
	LDB	#11		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LEAX	_names+0,PCR	address of array names
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
* optim: stripConsecOppositeTFRs
* optim: optimizeLeax
	LDB	,S+
	STB	10,X		optim: optimizeLeax
* Line dtet.c:1074: for init
* Line dtet.c:1074: assignment: =
	CLRA
	LDB	#$05		decimal 5 signed
	STD	-2,U
	LBRA	L00739		jump to for condition
L00738	EQU	*
* Line dtet.c:1074: for body
* Line dtet.c:1075: if
	LDD	-2,U		variable j
	LSLB
	ROLA
	LEAX	_scores+0,PCR	address of array scores
* optimizeLoadDX
	LDD	D,X		get r-value
	PSHS	B,A
	LDD	-4,U		variable i
	LSLB
	ROLA
	LEAX	_scores+0,PCR	address of array scores
* optimizeLoadDX
	LDD	D,X		get r-value
	CMPD	,S++
	LBLS	L00741		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00742 removed
* Line dtet.c:1075
* Line dtet.c:1077: if
	LDD	-2,U		variable j
	CMPD	#$05
	BGE	L00747		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00744 removed
* Line dtet.c:1077
* Line dtet.c:1078: assignment: =
	LDD	-2,U		variable j
	LSLB
	ROLA
	LEAX	_scores+0,PCR	address of array scores
* optimizeLoadDX
	LDD	D,X		get r-value
	PSHS	B,A
	LDD	-2,U		variable j
	ADDD	#$01		1
	LSLB
	ROLA
	LEAX	_scores+0,PCR	address of array scores
	LEAX	D,X		add offset
	PULS	A,B		retrieve value to store
	STD	,X
* Line dtet.c:1079: function call: strncpy()
	CLRA
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 3 of strncpy(): int
	LDX	-2,U		variable j
	LDB	#11		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LEAX	_names+0,PCR	address of array names
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	PSHS	B,A		C function argument 2 of strncpy(): char[]
	LDD	-2,U		variable j
	ADDD	#$01		1
	LDX	#11		size of array element
	LBSR	MUL16		get offset in bytes in D
	LEAX	_names+0,PCR	address of array names
	LEAX	D,X		add offset
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LBSR	_strncpy
	LEAS	6,S
* Useless label L00745 removed
* Useless label L00746 removed
	BRA	L00747		jump over else clause
* Useless label L00743 removed
* Line dtet.c:1082
	BRA	L00741		break
L00747	EQU	*		end of if() started at dtet.c:1075
* Useless label L00740 removed
* Line dtet.c:1074: for increment(s)
	LDD	-2,U
	SUBD	#1
	STD	-2,U
L00739	EQU	*
* Line dtet.c:1074: for condition
	LDD	-2,U		variable j
	ADDD	#0
	LBGE	L00738
* optim: branchToNextLocation
L00741	EQU	*		end for
* Line dtet.c:1085: assignment: =
	LDD	-4,U		variable i
	LSLB
	ROLA
	LEAX	_scores+0,PCR	address of array scores
* optimizeLoadDX
	LDD	D,X		get r-value
	PSHS	B,A
	LDD	-2,U		variable j
	ADDD	#$01		1
	LSLB
	ROLA
	LEAX	_scores+0,PCR	address of array scores
	LEAX	D,X		add offset
	PULS	A,B		retrieve value to store
	STD	,X
* Line dtet.c:1086: function call: strncpy()
	CLRA
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 3 of strncpy(): int
	LDX	-4,U		variable i
	LDB	#11		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LEAX	_names+0,PCR	address of array names
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	PSHS	B,A		C function argument 2 of strncpy(): char[]
	LDD	-2,U		variable j
	ADDD	#$01		1
	LDX	#11		size of array element
	LBSR	MUL16		get offset in bytes in D
	LEAX	_names+0,PCR	address of array names
	LEAX	D,X		add offset
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LBSR	_strncpy
	LEAS	6,S
* Line dtet.c:1087: assignment: =
	CLRA
* LDB #$01 optim: optimizeStackOperations1
* PSHS B optim: optimizeStackOperations1
	LDB	5,U		variable player
	LEAX	_newScore+0,PCR	address of array newScore
	ABX			add unsigned 8-bit offset
	LDB	#1		optim: optimizeStackOperations1
	STB	,X
L00733	EQU	*		else clause of if() started at dtet.c:1056
* Useless label L00748 removed
* Useless label L00158 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION checkScore(): defined at dtet.c:1051
funcend_checkScore	EQU *
funcsize_checkScore	EQU	funcend_checkScore-_checkScore
_main	EXPORT


*******************************************************************************

* FUNCTION main(): defined at dtet.c:1092
_main	EQU	*
* Prototype: int main(...)
* Calling convention: 0 (CMOC Default)
* Line dtet.c:1093: while
* optim: branchToNextLocation
L00749	EQU	*		while body
* Line dtet.c:1094: function call: srand()
	LDD	$0112		decimal 274
	PSHS	B,A		C function argument 1 of srand(): unsigned int
	LBSR	_srand
	LEAS	2,S
* Line dtet.c:1095: function call: init()
	LBSR	_init
* Line dtet.c:1096: function call: mainLoop()
	LBSR	_mainLoop
* Line dtet.c:1097: while
	BRA	L00753		jump to while condition
L00752	EQU	*		while body
L00753	EQU	*		while condition at dtet.c:1097
* Line dtet.c:1097: function call: inkey()
	LBSR	_inkey
	TSTB
	BNE	L00752
* optim: branchToNextLocation
* Useless label L00754 removed
* Line dtet.c:1099: if
	LDB	_cancelled+0,PCR	variable `cancelled', declared at dtet.c:103
* optim: loadCmpZeroBeqOrBne
	BNE	L00749
* optim: branchToNextLocation
* Useless label L00755 removed
* Line dtet.c:1099
* Line dtet.c:1100: function call: checkScore()
	CLRA
	CLRB
	PSHS	B,A		C function argument 1 of checkScore(): int
	LBSR	_checkScore
	LEAS	2,S
* Line dtet.c:1101: if
	LDB	_numPlayers+0,PCR	variable numPlayers
* optim: removeCMPZeroAfterLDIfBHI (BHI->BNE)
	BEQ	L00758		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00757 removed
* Line dtet.c:1102
* Line dtet.c:1102: function call: checkScore()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of checkScore(): int
	LBSR	_checkScore
	LEAS	2,S
L00758	EQU	*		else clause of if() started at dtet.c:1101
* Useless label L00759 removed
* Line dtet.c:1104: if
	LDB	_newScore+0,PCR	index 0 in array newScore[]
* optim: loadCmpZeroBeqOrBne
	BNE	L00760
* optim: branchToNextLocation
* Useless label L00762 removed
	LDB	_newScore+1,PCR	index 1 in array newScore[]
* optim: loadCmpZeroBeqOrBne
	BEQ	L00749		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
L00760	EQU	*		then clause of if() started at dtet.c:1104
* Line dtet.c:1104
* Line dtet.c:1105: function call: cls()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of cls(): int
	LBSR	_cls
	LEAS	2,S
* Line dtet.c:1106: function call: drawHeader()
	LDB	_colourShift+0,PCR	variable `colourShift', declared at dtet.c:100
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawHeader(): unsigned char
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of drawHeader(): int
	LBSR	_drawHeader
	LEAS	4,S
* Line dtet.c:1107: function call: drawHighScores()
	LBSR	_drawHighScores
* Useless label L00761 removed
* Useless label L00763 removed
* Useless label L00756 removed
* Useless label L00764 removed
* Useless label L00750 removed
	LBRA	L00749		go to start of while body
* Useless label L00751 removed
* Line dtet.c:1111: return with value
	CLRA
	CLRB
* optim: branchToNextLocation
* Useless label L00159 removed
	RTS
* END FUNCTION main(): defined at dtet.c:1092
funcend_main	EQU *
funcsize_main	EQU	funcend_main-_main


	ENDSECTION




	SECTION	initgl_start


INITGL	EXPORT
INITGL	EQU	*


	ENDSECTION




	SECTION	initgl




*******************************************************************************

* Initialize global variables.


	ENDSECTION




	SECTION	rodata


string_literals_start	EQU	*


*******************************************************************************

* STRING LITERALS
S00160	EQU	*
	FCC	"DRAGON"
	FCB	0
S00161	EQU	*
	FCB	0
S00162	EQU	*
	FCC	"DRAGONTET!"
	FCB	0
S00163	EQU	*
	FCC	"D R A G O N T E T"
	FCB	0
S00164	EQU	*
	FCC	"SALVAKANTERO 2025"
	FCB	0
S00165	EQU	*
	FCC	"DRAGON %u"
	FCB	0
S00166	EQU	*
	FCC	"LEVEL:  %2u"
	FCB	0
S00167	EQU	*
	FCC	"LINES: %3d"
	FCB	0
S00168	EQU	*
	FCC	"SC: %6u"
	FCB	0
S00169	EQU	*
	FCC	"NEXT:"
	FCB	0
S00170	EQU	*
	FCC	"HI: %6u"
	FCB	0
S00171	EQU	*
	FCC	"%uLIN +%4u"
	FCB	0
S00172	EQU	*
	FCC	"DROP   +%2u"
	FCB	0
S00173	EQU	*
	FCC	"          "
	FCB	0
S00174	EQU	*
	FCC	"0000444400000000"
	FCB	0
S00175	EQU	*
	FCC	"0000222000200000"
	FCB	0
S00176	EQU	*
	FCC	"0000777070000000"
	FCB	0
S00177	EQU	*
	FCC	"0000033003300000"
	FCB	0
S00178	EQU	*
	FCC	"0000066066000000"
	FCB	0
S00179	EQU	*
	FCC	"0000880008800000"
	FCB	0
S00180	EQU	*
	FCC	"0000111001000000"
	FCB	0
S00181	EQU	*
	FCC	"GAME OVER!"
	FCB	0
S00182	EQU	*
	FCC	"............."
	FCB	0
S00183	EQU	*
	FCC	"%s"
	FCB	0
S00184	EQU	*
	FCC	"%5u"
	FCB	0
S00185	EQU	*
	FCC	"PRESS ANY KEY TO CONTINUE!"
	FCB	0
S00186	EQU	*
	FCC	"  =DRAGON 1=  "
	FCB	0
S00187	EQU	*
	FCC	"              "
	FCB	0
S00188	EQU	*
	FCC	" w ROTATE     "
	FCB	0
S00189	EQU	*
	FCC	" s DROP       "
	FCB	0
S00190	EQU	*
	FCC	" a MOVE LEFT  "
	FCB	0
S00191	EQU	*
	FCC	" d MOVE RIGHT "
	FCB	0
S00192	EQU	*
	FCC	" + CURSORS    "
	FCB	0
S00193	EQU	*
	FCC	" + JOYSTICK1  "
	FCB	0
S00194	EQU	*
	FCC	"  =DRAGON 2=  "
	FCB	0
S00195	EQU	*
	FCC	" i ROTATE     "
	FCB	0
S00196	EQU	*
	FCC	" k DROP       "
	FCB	0
S00197	EQU	*
	FCC	" j MOVE LEFT  "
	FCB	0
S00198	EQU	*
	FCC	" l MOVE RIGHT "
	FCB	0
S00199	EQU	*
	FCC	" + JOYSTICK2  "
	FCB	0
S00200	EQU	*
	FCC	" X = CANCEL/RETURN TO MAIN MENU "
	FCB	0
S00201	EQU	*
	FCC	" H = PAUSE THE GAME             "
	FCB	0
S00202	EQU	*
	FCC	"   PRESS ANY KEY TO CONTINUE!   "
	FCB	0
S00203	EQU	*
	FCC	"                             "
	FCB	0
S00204	EQU	*
	FCC	"        = s c o r e =        "
	FCB	0
S00205	EQU	*
	FCC	" 1 LINE:  100 * LEVEL NUMBER "
	FCB	0
S00206	EQU	*
	FCC	" 2 LINES: 300 * LEVEL NUMBER "
	FCB	0
S00207	EQU	*
	FCC	" 3 LINES: 500 * LEVEL NUMBER "
	FCB	0
S00208	EQU	*
	FCC	" 4 LINES: 800 * LEVEL NUMBER "
	FCB	0
S00209	EQU	*
	FCC	"  SOFT DROP:  1 POINT * ROW  "
	FCB	0
S00210	EQU	*
	FCC	"EMPTY BACKGROUND:"
	FCB	0
S00211	EQU	*
	FCC	"MUTED:"
	FCB	0
S00212	EQU	*
	FCC	"BACK"
	FCB	0
S00213	EQU	*
	FCC	"SELECT OPTION (CURSOR/ENTER)"
	FCB	0
S00214	EQU	*
	FCC	"on "
	FCB	0
S00215	EQU	*
	FCC	"off"
	FCB	0
S00216	EQU	*
	FCC	"1 DRAGON GAME"
	FCB	0
S00217	EQU	*
	FCC	"2 DRAGONS GAME"
	FCB	0
S00218	EQU	*
	FCC	"HIGH SCORES"
	FCB	0
S00219	EQU	*
	FCC	"OPTIONS"
	FCB	0
S00220	EQU	*
	FCC	"HELP"
	FCB	0
S00221	EQU	*
	FCC	"EXIT"
	FCB	0
S00222	EQU	*
	FCC	"THANKS FOR PLAYING DRAGONTET!"
	FCB	$0A
	FCB	0
S00223	EQU	*
	FCC	" PLEASE "
	FCB	0
S00224	EQU	*
	FCC	"  WAIT  "
	FCB	0
S00225	EQU	*
	FCC	" DRAGON "
	FCB	0
S00226	EQU	*
	FCC	"   2!   "
	FCB	0
S00227	EQU	*
	FCC	"*** %u ***"
	FCB	0
S00228	EQU	*
	FCC	"GOOD SCORE DRAGON %d"
	FCB	0
S00229	EQU	*
	FCC	"NAME?: "
	FCB	0
S00230	EQU	*
	FCC	"?"
	FCB	0
string_literals_end	EQU	*


*******************************************************************************

* READ-ONLY GLOBAL VARIABLES
_pitLeft	EQU	*		pitLeft: const unsigned char[]
* Element 0 of array, of type const unsigned char
	FCB	$00		decimal 0
* Element 1 of array, of type const unsigned char
	FCB	$16		decimal 22
_backgroundCharList	EQU	*		backgroundCharList: const unsigned char[]
* Element 0 of array, of type const unsigned char
	FCB	$2A		decimal 42
* Element 1 of array, of type const unsigned char
	FCB	$2B		decimal 43
* Element 2 of array, of type const unsigned char
	FCB	$27		decimal 39
* Element 3 of array, of type const unsigned char
	FCB	$23		decimal 35
* Element 4 of array, of type const unsigned char
	FCB	$1C		decimal 28
* Element 5 of array, of type const unsigned char
	FCB	$2C		decimal 44
* Element 6 of array, of type const unsigned char
	FCB	$2F		decimal 47
* Element 7 of array, of type const unsigned char
	FCB	$2E		decimal 46
_tune1Notes	EQU	*		tune1Notes: const unsigned char[]
* Element 0 of array, of type const unsigned char
	FCB	$C4		decimal 196
* Element 1 of array, of type const unsigned char
	FCB	$C4		decimal 196
* Element 2 of array, of type const unsigned char
	FCB	$C4		decimal 196
* Element 3 of array, of type const unsigned char
	FCB	$CC		decimal 204
* Element 4 of array, of type const unsigned char
	FCB	$BF		decimal 191
* Element 5 of array, of type const unsigned char
	FCB	$CE		decimal 206
* Element 6 of array, of type const unsigned char
	FCB	$D6		decimal 214
_tune1Durations	EQU	*		tune1Durations: const unsigned char[]
* Element 0 of array, of type const unsigned char
	FCB	$04		decimal 4
* Element 1 of array, of type const unsigned char
	FCB	$02		decimal 2
* Element 2 of array, of type const unsigned char
	FCB	$02		decimal 2
* Element 3 of array, of type const unsigned char
	FCB	$03		decimal 3
* Element 4 of array, of type const unsigned char
	FCB	$03		decimal 3
* Element 5 of array, of type const unsigned char
	FCB	$03		decimal 3
* Element 6 of array, of type const unsigned char
	FCB	$07		decimal 7
_tune2Notes	EQU	*		tune2Notes: const unsigned char[]
* Element 0 of array, of type const unsigned char
	FCB	$BF		decimal 191
* Element 1 of array, of type const unsigned char
	FCB	$C8		decimal 200
* Element 2 of array, of type const unsigned char
	FCB	$D2		decimal 210
* Element 3 of array, of type const unsigned char
	FCB	$D8		decimal 216
* Element 4 of array, of type const unsigned char
	FCB	$C8		decimal 200
* Element 5 of array, of type const unsigned char
	FCB	$B4		decimal 180
* Element 6 of array, of type const unsigned char
	FCB	$BE		decimal 190
* Element 7 of array, of type const unsigned char
	FCB	$C8		decimal 200
_tune2Durations	EQU	*		tune2Durations: const unsigned char[]
* Element 0 of array, of type const unsigned char
	FCB	$02		decimal 2
* Element 1 of array, of type const unsigned char
	FCB	$02		decimal 2
* Element 2 of array, of type const unsigned char
	FCB	$02		decimal 2
* Element 3 of array, of type const unsigned char
	FCB	$02		decimal 2
* Element 4 of array, of type const unsigned char
	FCB	$04		decimal 4
* Element 5 of array, of type const unsigned char
	FCB	$02		decimal 2
* Element 6 of array, of type const unsigned char
	FCB	$02		decimal 2
* Element 7 of array, of type const unsigned char
	FCB	$04		decimal 4
_tune3Notes	EQU	*		tune3Notes: const unsigned char[]
* Element 0 of array, of type const unsigned char
	FCB	$A5		decimal 165
* Element 1 of array, of type const unsigned char
	FCB	$8C		decimal 140
* Element 2 of array, of type const unsigned char
	FCB	$9B		decimal 155
* Element 3 of array, of type const unsigned char
	FCB	$87		decimal 135
* Element 4 of array, of type const unsigned char
	FCB	$96		decimal 150
* Element 5 of array, of type const unsigned char
	FCB	$82		decimal 130
* Element 6 of array, of type const unsigned char
	FCB	$8C		decimal 140
* Element 7 of array, of type const unsigned char
	FCB	$78		decimal 120
* Element 8 of array, of type const unsigned char
	FCB	$6E		decimal 110
* Element 9 of array, of type const unsigned char
	FCB	$66		decimal 102
_tune3Durations	EQU	*		tune3Durations: const unsigned char[]
* Element 0 of array, of type const unsigned char
	FCB	$03		decimal 3
* Element 1 of array, of type const unsigned char
	FCB	$01		decimal 1
* Element 2 of array, of type const unsigned char
	FCB	$03		decimal 3
* Element 3 of array, of type const unsigned char
	FCB	$01		decimal 1
* Element 4 of array, of type const unsigned char
	FCB	$03		decimal 3
* Element 5 of array, of type const unsigned char
	FCB	$01		decimal 1
* Element 6 of array, of type const unsigned char
	FCB	$02		decimal 2
* Element 7 of array, of type const unsigned char
	FCB	$01		decimal 1
* Element 8 of array, of type const unsigned char
	FCB	$02		decimal 2
* Element 9 of array, of type const unsigned char
	FCB	$04		decimal 4


	ENDSECTION




	SECTION	rwdata


* Statically-initialized global variables
_key	EQU	*		key: char: dtet.c:83
	FCB	$00		decimal 0
_newScore	EQU	*		newScore: unsigned char[]
* Element 0 of array, of type unsigned char
	FCB	$00		decimal 0
* Element 1 of array, of type unsigned char
	FCB	$00		decimal 0
_gameOver	EQU	*		gameOver: unsigned char[]
* Element 0 of array, of type unsigned char
	FCB	$00		decimal 0
* Element 1 of array, of type unsigned char
	FCB	$00		decimal 0
_dropRate	EQU	*		dropRate: int[]
* Element 0 of array, of type int
	FDB	$00		decimal 0
* Element 1 of array, of type int
	FDB	$00		decimal 0
_startTime	EQU	*		startTime: int[]
* Element 0 of array, of type int
	FDB	$00		decimal 0
* Element 1 of array, of type int
	FDB	$00		decimal 0
_level	EQU	*		level: unsigned char[]
* Element 0 of array, of type unsigned char
	FCB	$01		decimal 1
* Element 1 of array, of type unsigned char
	FCB	$01		decimal 1
_lines	EQU	*		lines: int[]
* Element 0 of array, of type int
	FDB	$00		decimal 0
* Element 1 of array, of type int
	FDB	$00		decimal 0
_shape	EQU	*		shape: unsigned char[]
* Element 0 of array, of type unsigned char
	FCB	$FF		decimal 255
* Element 1 of array, of type unsigned char
	FCB	$FF		decimal 255
_nextShape	EQU	*		nextShape: unsigned char[]
* Element 0 of array, of type unsigned char
	FCB	$FF		decimal 255
* Element 1 of array, of type unsigned char
	FCB	$FF		decimal 255
_shapeAngle	EQU	*		shapeAngle: unsigned char[]
* Element 0 of array, of type unsigned char
	FCB	$00		decimal 0
* Element 1 of array, of type unsigned char
	FCB	$00		decimal 0
_shapeX	EQU	*		shapeX: int[]
* Element 0 of array, of type int
	FDB	$00		decimal 0
* Element 1 of array, of type int
	FDB	$00		decimal 0
_shapeY	EQU	*		shapeY: int[]
* Element 0 of array, of type int
	FDB	$00		decimal 0
* Element 1 of array, of type int
	FDB	$00		decimal 0
_colourShift	EQU	*		colourShift: unsigned char: dtet.c:100
	FCB	$00		decimal 0
_emptyBackground	EQU	*		emptyBackground: unsigned char: dtet.c:101
	FCB	$00		decimal 0
_muted	EQU	*		muted: unsigned char: dtet.c:102
	FCB	$00		decimal 0
_cancelled	EQU	*		cancelled: unsigned char: dtet.c:103
	FCB	$00		decimal 0
_names	EQU	*		names: char[][] (array of string literals)
	FCC	"DRAGON"
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCC	"DRAGON"
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCC	"DRAGON"
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCC	"DRAGON"
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCC	"DRAGON"
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCC	"DRAGON"
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
_scores	EQU	*		scores: unsigned int[]
* Element 0 of array, of type unsigned int
	FDB	$07D0		decimal 2000
* Element 1 of array, of type unsigned int
	FDB	$0708		decimal 1800
* Element 2 of array, of type unsigned int
	FDB	$0640		decimal 1600
* Element 3 of array, of type unsigned int
	FDB	$0578		decimal 1400
* Element 4 of array, of type unsigned int
	FDB	$04B0		decimal 1200
* Element 5 of array, of type unsigned int
	FDB	$03E8		decimal 1000
* Element 6 of array, of type unsigned int
	FDB	$00		decimal 0
* Element 7 of array, of type unsigned int
	FDB	$00		decimal 0
* Statically-initialized local static variables


	ENDSECTION




	SECTION	bss


bss_start	EQU	*
* Uninitialized global variables
_numPlayers	EQU	*
	RMB	1		numPlayers: unsigned char: dtet.c:84
_pit	EQU	*
	RMB	320		pit: char[][]: dtet.c:89
_shapeMap	EQU	*
	RMB	32		shapeMap: char[][]: dtet.c:97
_nextShapeMap	EQU	*
	RMB	32		nextShapeMap: char[][]: dtet.c:98
_rotatedMap	EQU	*
	RMB	32		rotatedMap: char[][]: dtet.c:99
_lastLines	EQU	*
	RMB	1		lastLines: unsigned char: dtet.c:104
_lastPoints	EQU	*
	RMB	2		lastPoints: unsigned int: dtet.c:105
_backgroundChar	EQU	*
	RMB	2		backgroundChar: unsigned char[]: dtet.c:106
_lastInputTime	EQU	*
	RMB	12		lastInputTime: unsigned int[][]: dtet.c:108
_linesPiecesPlayed	EQU	*
	RMB	2		linesPiecesPlayed: unsigned char[]: dtet.c:109
_previousLevel	EQU	*
	RMB	2		previousLevel: unsigned char[]: dtet.c:110
* Uninitialized local static variables
.local.static.getShapeMap.shapeMaps.initialized	EQU	*
	RMB	1
.local.static.getShapeMap.shapeMaps	EQU	*
	RMB	14		shapeMaps: const char *[]: dtet.c:281
bss_end	EQU	*


	ENDSECTION




	SECTION	initgl_end


	RTS			end of global variable initialization


	ENDSECTION




*******************************************************************************



	SECTION	program_end


program_end	EXPORT
program_end	EQU	*


	ENDSECTION




*******************************************************************************

* Importing 25 utility routine(s).
DIV8	IMPORT
DIV8BY7	IMPORT
MUL16	IMPORT
MUL168	IMPORT
MUL16BY10	IMPORT
SDIV16	IMPORT
_cls	IMPORT
_delay	IMPORT
_exit	IMPORT
_inkey	IMPORT
_isKeyPressed	IMPORT
_locate	IMPORT
_memcpy	IMPORT
_memset	IMPORT
_printf	IMPORT
_rand	IMPORT
_readJoystickPositions	IMPORT
_readline	IMPORT
_screen	IMPORT
_sound	IMPORT
_srand	IMPORT
_strncpy	IMPORT
_waitkey	IMPORT
signedJumpTableSwitch	IMPORT
tfrZtoB	IMPORT


*******************************************************************************

	END
