* 6809 assembly program generated by cmoc 0.1.89


	SECTION	start


program_start	EXPORT
_main	IMPORT
INILIB	IMPORT
_exit	IMPORT
program_start	EQU	*
	LDD	#-1024		stack space in bytes
	LBSR	INILIB		initialize standard library and global variables
	LBSR	_main		call main()
	PSHS	B,A		send main() return value to exit()
	LBSR	_exit		use LBSR to respect calling convention


	ENDSECTION




	SECTION	code


_isCoCo3	IMPORT
_textScreenWidth	IMPORT
_textScreenHeight	IMPORT
_key	EXPORT
_numPlayers	EXPORT
_newScore	EXPORT
_gameOver	EXPORT
_dropRate	EXPORT
_startTime	EXPORT
_pit	EXPORT
_level	EXPORT
_lines	EXPORT
_pitLeft	EXPORT
_shape	EXPORT
_nextShape	EXPORT
_shapeAngle	EXPORT
_shapeX	EXPORT
_shapeY	EXPORT
_shapeMap	EXPORT
_nextShapeMap	EXPORT
_rotatedMap	EXPORT
_colourShift	EXPORT
_emptyBackground	EXPORT
_muted	EXPORT
_cancelled	EXPORT
_lastLines	EXPORT
_lastPoints	EXPORT
_backgroundChar	EXPORT
_backgroundCharList	EXPORT
_lastInputTime	EXPORT
_linesPiecesPlayed	EXPORT
_previousLevel	EXPORT
_names	EXPORT
_scores	EXPORT
_tune1Notes	EXPORT
_tune1Durations	EXPORT
_tune2Notes	EXPORT
_tune2Durations	EXPORT
_tune3Notes	EXPORT
_tune3Durations	EXPORT
___va_arg	IMPORT
_abs	IMPORT
_adddww	IMPORT
_atanf	IMPORT
_atoff	IMPORT
_atoi	IMPORT
_atol	IMPORT
_atoui	IMPORT
_atoul	IMPORT
_attr	IMPORT
_bsearch	IMPORT
_cls	IMPORT
_cmp	IMPORT
_cmpdww	IMPORT
_coldStart	IMPORT
_cosf	IMPORT
_delay	IMPORT
_divdwb	IMPORT
_divdww	IMPORT
_divmod16	IMPORT
_divmod8	IMPORT
_dwtoa	IMPORT
_enable_printf_float	IMPORT
_exit	IMPORT
_expf	IMPORT
_fabsf	IMPORT
_floorf	IMPORT
_ftoa	IMPORT
_getTextMode	IMPORT
_hscreen	IMPORT
_hset	IMPORT
_initCoCoSupport	IMPORT
_inkey	IMPORT
_isKeyPressed	IMPORT
_isalnum	IMPORT
_isalpha	IMPORT
_isdigit	IMPORT
_isspace	IMPORT
_itoa10	IMPORT
_labs	IMPORT
_locate	IMPORT
_logf	IMPORT
_ltoa10	IMPORT
_memchr	IMPORT
_memcmp	IMPORT
_memcpy	IMPORT
_memichr	IMPORT
_memicmp	IMPORT
_memmove	IMPORT
_memset	IMPORT
_memset16	IMPORT
_mulwb	IMPORT
_mulww	IMPORT
_palette	IMPORT
_paletteRGB	IMPORT
_pcls	IMPORT
_pmode	IMPORT
_printf	IMPORT
_putchar	IMPORT
_putstr	IMPORT
_qsort	IMPORT
_rand	IMPORT
_readJoystickButtons	IMPORT
_readJoystickPositions	IMPORT
_readline	IMPORT
_readword	IMPORT
_resetPalette	IMPORT
_rgb	IMPORT
_roundf	IMPORT
_sbrk	IMPORT
_sbrkmax	IMPORT
_screen	IMPORT
_setBorderColor	IMPORT
_setCaseFlag	IMPORT
_setConsoleOutHook	IMPORT
_setHighSpeed	IMPORT
_setOutputDevice	IMPORT
_setPmodeGraphicsAddressEx	IMPORT
_setSAMRegisters	IMPORT
_set_null_ptr_handler	IMPORT
_set_stack_overflow_handler	IMPORT
_showGraphicsAddress	IMPORT
_showLowResTextAddress	IMPORT
_showPmode4	IMPORT
_sinf	IMPORT
_sleep	IMPORT
_sound	IMPORT
_sprintf	IMPORT
_sqrt16	IMPORT
_sqrt32	IMPORT
_sqrtf	IMPORT
_srand	IMPORT
_strcat	IMPORT
_strchr	IMPORT
_strcmp	IMPORT
_strcpy	IMPORT
_strcspn	IMPORT
_stricmp	IMPORT
_strlen	IMPORT
_strlwr	IMPORT
_strncmp	IMPORT
_strncpy	IMPORT
_strpbrk	IMPORT
_strrchr	IMPORT
_strspn	IMPORT
_strstr	IMPORT
_strtof	IMPORT
_strtok	IMPORT
_strtol	IMPORT
_strtoul	IMPORT
_strupr	IMPORT
_subdww	IMPORT
_tanf	IMPORT
_tolower	IMPORT
_toupper	IMPORT
_truncf	IMPORT
_ultoa10	IMPORT
_utoa10	IMPORT
_vprintf	IMPORT
_vsprintf	IMPORT
_waitkey	IMPORT
_width	IMPORT
_zerodw	IMPORT
_playTune	EXPORT


*******************************************************************************

* FUNCTION playTune(): defined at dtet.c:127
_playTune	EQU	*
* Prototype: void playTune(const unsigned char *, const unsigned char *, unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-1,S
* Formal parameter(s):
*      4,U:    2 bytes: notes: const unsigned char *: line 127
*      6,U:    2 bytes: durations: const unsigned char *: line 127
*      9,U:    1 byte : numNotes: unsigned char: line 127
* Local non-static variable(s):
*     -1,U:    1 byte : i: unsigned char: line 130
* Line dtet.c:128: if
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:100
* optim: loadCmpZeroBeqOrBne
	BNE	L00124		 (optim: condBranchOverUncondBranch) (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00231 removed
* Line dtet.c:128
* optim: condBranchOverUncondBranch
* Useless label L00232 removed
* Useless label L00233 removed
* Line dtet.c:130: for init
* Line dtet.c:130: init of variable i
	CLR	-1,U		variable i
	BRA	L00235		jump to for condition
L00234	EQU	*
* Line dtet.c:130: for body
* Line dtet.c:131: if
* Line dtet.c:131: function call: inkey()
	LBSR	_inkey
	TSTB
	BNE	L00124		 (optim: condBranchOverUncondBranch) (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00238 removed
* Line dtet.c:131
* optim: condBranchOverUncondBranch
* Useless label L00239 removed
* Useless label L00240 removed
* Line dtet.c:132: function call: sound()
	LDB	-1,U		variable i
	LDX	6,U		pointer durations
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of sound(): const unsigned char
	LDB	-1,U		variable i
	LDX	4,U		pointer notes
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of sound(): const unsigned char
	LBSR	_sound
	LEAS	4,S
* Line dtet.c:133: if
* Line dtet.c:133: function call: inkey()
	LBSR	_inkey
	TSTB
	BNE	L00124		 (optim: condBranchOverUncondBranch) (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00241 removed
* Line dtet.c:133
* optim: condBranchOverUncondBranch
* Useless label L00242 removed
* Useless label L00243 removed
* Useless label L00236 removed
* Line dtet.c:130: for increment(s)
	INC	-1,U
L00235	EQU	*
* Line dtet.c:130: for condition
	LDB	-1,U		variable i
	CMPB	9,U		variable numNotes
	BLO	L00234
* optim: branchToNextLocation
* Useless label L00237 removed
L00124	EQU	*		end of playTune()
	LEAS	,U
	PULS	U,PC
* END FUNCTION playTune(): defined at dtet.c:127
funcend_playTune	EQU *
funcsize_playTune	EQU	funcend_playTune-_playTune
_printBlock	EXPORT


*******************************************************************************

* FUNCTION printBlock(): defined at dtet.c:138
_printBlock	EQU	*
* Prototype: void printBlock(int, int, unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-2,S
* Formal parameter(s):
*      4,U:    2 bytes: x: int: line 138
*      6,U:    2 bytes: y: int: line 138
*      9,U:    1 byte : ch: unsigned char: line 138
* Local non-static variable(s):
*     -2,U:    2 bytes: screenPos: unsigned char *: line 140
* Line dtet.c:140: init of variable screenPos
	LDD	4,U		variable `x', declared at dtet.c:138
	PSHS	B,A
	LDX	6,U		left
* optim: removeClrAFromArrayIndexMul
	LDB	#$20		right
	LBSR	MUL168
	ADDD	#$0400		optim: pushDLoadAdd
* 
* 
	ADDD	,S++
* Emitted no code to cast `int' to `unsigned char *'
	STD	-2,U		variable screenPos
* Line dtet.c:141: assignment: =
	LDB	9,U		variable `ch', declared at dtet.c:138
* optim: stripExtraPushPullB
* optim: optimizeLdx
* optim: stripExtraPushPullB
	STB	[-2,U]		optim: optimizeLdx
* Useless label L00125 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION printBlock(): defined at dtet.c:138
funcend_printBlock	EQU *
funcsize_printBlock	EQU	funcend_printBlock-_printBlock
_drawBlock	EXPORT


*******************************************************************************

* FUNCTION drawBlock(): defined at dtet.c:145
_drawBlock	EQU	*
* Prototype: void drawBlock(unsigned char, unsigned char, char, unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-1,S
* Formal parameter(s):
*      5,U:    1 byte : x: unsigned char: line 145
*      7,U:    1 byte : y: unsigned char: line 145
*      9,U:    1 byte : blockColour: char: line 145
*     11,U:    1 byte : i: unsigned char: line 145
* Local non-static variable(s):
*     -1,U:    1 byte : colour: unsigned char: line 148
* Line dtet.c:148: init of variable colour
	LDB	9,U		variable blockColour
	ADDB	#$D0		208
	STB	-1,U		variable colour
* Line dtet.c:149: assignment: +=
	LDB	11,U		variable i
	LEAX	_pitLeft+0,PCR	address of array pitLeft
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	ADDB	5,U		optim: pushBLoadAdd
* 
* 
	STB	5,U
	CLRA
* Line dtet.c:150: if
	LDB	-1,U		variable `colour', declared at dtet.c:148
* optim: loadCmpZeroBeqOrBne
	BNE	L00245		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00244 removed
* Line dtet.c:150
* Line dtet.c:151: function call: printBlock()
* Line dtet.c:151: conditional expression
	LDB	_emptyBackground+0,PCR	variable `emptyBackground', declared at dtet.c:99
* optim: loadCmpZeroBeqOrBne
	BEQ	L00247		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00246 removed
	CLRA
	LDB	#$80		decimal 128 signed
	BRA	L00248		end of true expression of conditional
L00247	EQU	*
	LDB	11,U		variable i
	LEAX	_backgroundChar+0,PCR	address of array backgroundChar
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	CLRA			promote from byte (conditional expression)
L00248	EQU	*
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 3 of printBlock(): unsigned char
	LDB	7,U		variable `y', declared at dtet.c:145
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 2 of printBlock(): unsigned char
	LDB	5,U		variable `x', declared at dtet.c:145
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of printBlock(): unsigned char
	LBSR	_printBlock
	LEAS	6,S
	BRA	L00126		return (dtet.c:152)
L00245	EQU	*		else clause of if() started at dtet.c:150
* Useless label L00249 removed
* Line dtet.c:154: function call: printBlock()
	LDB	-1,U		variable colour
	ADDB	#$FF		255
	LSLB
	LSLB
	LSLB
	LSLB
	PSHS	B
	CLRA
	LDB	#$8F		decimal 143 signed
	ADDB	,S+
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 3 of printBlock(): unsigned char
	LDB	7,U		variable `y', declared at dtet.c:145
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 2 of printBlock(): unsigned char
	LDB	5,U		variable `x', declared at dtet.c:145
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of printBlock(): unsigned char
	LBSR	_printBlock
	LEAS	6,S
L00126	EQU	*		end of drawBlock()
	LEAS	,U
	PULS	U,PC
* END FUNCTION drawBlock(): defined at dtet.c:145
funcend_drawBlock	EQU *
funcsize_drawBlock	EQU	funcend_drawBlock-_drawBlock
_drawPit	EXPORT


*******************************************************************************

* FUNCTION drawPit(): defined at dtet.c:158
_drawPit	EQU	*
* Prototype: void drawPit(unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-3,S
* Formal parameter(s):
*      5,U:    1 byte : i: unsigned char: line 158
* Local non-static variable(s):
*     -3,U:    1 byte : x: unsigned char: line 159
*     -2,U:    1 byte : y: unsigned char: line 159
*     -1,U:    1 byte : rowOffset: unsigned char: line 159
* Line dtet.c:161: for init
* Line dtet.c:161: assignment: =
	CLRB
	STB	-2,U		variable y
	LBRA	L00251		jump to for condition
L00250	EQU	*
* Line dtet.c:161: for body
* Line dtet.c:162: assignment: =
	LDA	-2,U
	LDB	#$0A
	MUL			result of type byte in B
	STB	-1,U
* Line dtet.c:163: for init
* Line dtet.c:163: assignment: =
	CLRB
	STB	-3,U		variable x
	BRA	L00255		jump to for condition
L00254	EQU	*
* Line dtet.c:164: for body
* Line dtet.c:164: function call: drawBlock()
	LDB	5,U		variable `i', declared at dtet.c:158
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 4 of drawBlock(): unsigned char
	LDB	-3,U		variable x
	ADDB	-1,U		variable rowOffset
* optim: stripExtraClrA_B
	PSHS	B,A		preserve array index
	LDB	5,U		variable i
* optim: stripExtraClrA_B
	LDA	#160		size of array element
	MUL			get offset in bytes in D
	LEAX	_pit+0,PCR	address of array pit
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,X		get r-value
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 3 of drawBlock(): char
	LDB	-2,U		variable `y', declared at dtet.c:159
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawBlock(): unsigned char
	LDB	-3,U		variable `x', declared at dtet.c:159
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of drawBlock(): unsigned char
	LBSR	_drawBlock
	LEAS	8,S
* Useless label L00256 removed
* Line dtet.c:163: for increment(s)
	INC	-3,U
L00255	EQU	*
* Line dtet.c:163: for condition
	LDB	-3,U		variable x
	CMPB	#$0A
	BLO	L00254
* optim: branchToNextLocation
* Useless label L00257 removed
* Useless label L00252 removed
* Line dtet.c:161: for increment(s)
	INC	-2,U
L00251	EQU	*
* Line dtet.c:161: for condition
	LDB	-2,U		variable y
	CMPB	#$10
	LBLO	L00250
* optim: branchToNextLocation
* Useless label L00253 removed
* Useless label L00127 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION drawPit(): defined at dtet.c:158
funcend_drawPit	EQU *
funcsize_drawPit	EQU	funcend_drawPit-_drawPit
_shapeCanMove	EXPORT


*******************************************************************************

* FUNCTION shapeCanMove(): defined at dtet.c:170
_shapeCanMove	EQU	*
* Prototype: unsigned char shapeCanMove(char *, char, char, unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-8,S
* Formal parameter(s):
*      4,U:    2 bytes: map: char *: line 170
*      7,U:    1 byte : xDir: char: line 170
*      9,U:    1 byte : yDir: char: line 170
*     11,U:    1 byte : i: unsigned char: line 170
* Local non-static variable(s):
*     -8,U:    2 bytes: x: int: line 171
*     -6,U:    2 bytes: y: int: line 171
*     -4,U:    2 bytes: blockX: int: line 171
*     -2,U:    2 bytes: blockY: int: line 171
* Line dtet.c:173: for init
* Line dtet.c:173: assignment: =
	CLRA
	CLRB
	STD	-2,U
	LBRA	L00259		jump to for condition
L00258	EQU	*
* Line dtet.c:173: for body
* Line dtet.c:174: for init
* Line dtet.c:174: assignment: =
	CLRA
	CLRB
	STD	-4,U
	LBRA	L00263		jump to for condition
L00262	EQU	*
* Line dtet.c:174: for body
* Line dtet.c:175: if
	LDD	-4,U		variable `blockX', declared at dtet.c:171
	PSHS	B,A
	LDX	#$04		left
	LDD	-2,U		right
	LBSR	MUL16
	ADDD	,S++
	LDX	4,U		pointer map
* optimizeLoadDX
	LDB	D,X		get r-value
	CMPB	#48
	LBEQ	L00267		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00266 removed
* Line dtet.c:175
* Line dtet.c:177: assignment: =
	LDB	7,U		variable `xDir', declared at dtet.c:170
	SEX			promotion of binary operand
	PSHS	B,A
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDB	11,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_shapeX+0,PCR	address of array shapeX
* optimizeLoadDX
	LDD	D,X		get r-value
	ADDD	-4,U		optim: optimizeStackOperations4
	ADDD	,S++
	STD	-8,U
* Line dtet.c:178: assignment: =
	LDB	9,U		variable `yDir', declared at dtet.c:170
	SEX			promotion of binary operand
	PSHS	B,A
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDB	11,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_shapeY+0,PCR	address of array shapeY
* optimizeLoadDX
	LDD	D,X		get r-value
	ADDD	-2,U		optim: optimizeStackOperations4
	ADDD	,S++
	STD	-6,U
* Line dtet.c:180: if
* optim: storeLoad
	ADDD	#0
	BGE	L00269		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00268 removed
* Line dtet.c:181
* Line dtet.c:181: return with value
	LDB	7,U		variable xDir
* optim: loadCmpZeroBeqOrBne
	BEQ	L00270		if true
	CLRB
	LBRA	L00128		false
L00270	EQU	*
	LDB	#1
* Useless label L00271 removed
	LBRA	L00128		return (dtet.c:181)
L00269	EQU	*		else clause of if() started at dtet.c:180
* Useless label L00272 removed
* Line dtet.c:183: if
	LDD	-8,U		variable x
	ADDD	#0
	BLT	L00274		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00276 removed
	LDD	-8,U		variable x
	CMPD	#$0A
	BGE	L00274		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00275 removed
	LDD	-6,U		variable y
	CMPD	#$10
	BGE	L00274		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00273 removed
* Line dtet.c:183
* Line dtet.c:185: if
	LDD	-8,U		variable `x', declared at dtet.c:171
	PSHS	B,A
	LDD	-6,U		variable `y', declared at dtet.c:171
	LBSR	MUL16BY10
	ADDD	,S++
	PSHS	B,A		preserve array index
	LDB	11,U		variable i
* optim: stripOpToDeadReg
	LDA	#160		size of array element
	MUL			get offset in bytes in D
	LEAX	_pit+0,PCR	address of array pit
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,X		get r-value
	CMPB	#48
	BEQ	L00280		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00277 removed
* Line dtet.c:186
	CLRB
	BRA	L00128		return (dtet.c:186)
* Useless label L00278 removed
* Useless label L00279 removed
	BRA	L00280		jump over else clause
L00274	EQU	*		else clause of if() started at dtet.c:183
* Line dtet.c:189
	CLRB
	BRA	L00128		return (dtet.c:189)
L00280	EQU	*		end of if() started at dtet.c:183
L00267	EQU	*		else clause of if() started at dtet.c:175
* Useless label L00281 removed
* Useless label L00264 removed
* Line dtet.c:174: for increment(s)
	LDD	-4,U
	ADDD	#1
	STD	-4,U
L00263	EQU	*
* Line dtet.c:174: for condition
	LDD	-4,U		variable blockX
	CMPD	#$03
	LBLE	L00262
* optim: branchToNextLocation
* Useless label L00265 removed
* Useless label L00260 removed
* Line dtet.c:173: for increment(s)
	LDD	-2,U
	ADDD	#1
	STD	-2,U
L00259	EQU	*
* Line dtet.c:173: for condition
	LDD	-2,U		variable blockY
	CMPD	#$03
	LBLE	L00258
* optim: branchToNextLocation
* Useless label L00261 removed
	LDB	#1
* optim: branchToNextLocation
L00128	EQU	*		end of shapeCanMove()
	LEAS	,U
	PULS	U,PC
* END FUNCTION shapeCanMove(): defined at dtet.c:170
funcend_shapeCanMove	EQU *
funcsize_shapeCanMove	EQU	funcend_shapeCanMove-_shapeCanMove
_drawNextShape	EXPORT


*******************************************************************************

* FUNCTION drawNextShape(): defined at dtet.c:197
_drawNextShape	EQU	*
* Prototype: void drawNextShape(unsigned char, unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-3,S
* Formal parameter(s):
*      5,U:    1 byte : y: unsigned char: line 197
*      7,U:    1 byte : i: unsigned char: line 197
* Local non-static variable(s):
*     -3,U:    1 byte : blockX: unsigned char: line 198
*     -2,U:    1 byte : blockY: unsigned char: line 198
*     -1,U:    1 byte : blockColour: unsigned char: line 198
* Line dtet.c:200: for init
* Line dtet.c:200: assignment: =
	CLRB
	STB	-2,U		variable blockY
	LBRA	L00283		jump to for condition
L00282	EQU	*
* Line dtet.c:200: for body
* Line dtet.c:201: for init
* Line dtet.c:201: assignment: =
	CLRB
	STB	-3,U		variable blockX
	LBRA	L00287		jump to for condition
L00286	EQU	*
* Line dtet.c:201: for body
* Line dtet.c:202: assignment: =
* optim: optimize8BitStackOps
* optim: optimize8BitStackOps
	LDB	-2,U		to be multiplied by 4
	LSLB
	LSLB
	ADDB	-3,U		optim: optimize8BitStackOps
	CLRA			extend byte index expression
	PSHS	B,A		preserve array index
	LDB	7,U		variable i
* optim: stripExtraClrA_B
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LEAX	_nextShapeMap+0,PCR	address of array nextShapeMap
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,X		get r-value
	STB	-1,U
* Line dtet.c:203: if
* optim: storeLoad
	CMPB	#$30
	BNE	L00291		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00290 removed
* Line dtet.c:203
* Line dtet.c:203: assignment: =
	LDB	#$31
	STB	-1,U		variable blockColour
	BRA	L00292		jump over else clause
L00291	EQU	*		else clause of if() started at dtet.c:203
* Line dtet.c:206
* Line dtet.c:204: if
	LDB	-1,U		variable blockColour
	CMPB	#$31
	BNE	L00294		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00293 removed
* Line dtet.c:204
* Line dtet.c:204: assignment: =
	LDB	#$35
	STB	-1,U		variable blockColour
L00294	EQU	*		else clause of if() started at dtet.c:204
* Useless label L00295 removed
L00292	EQU	*		end of if() started at dtet.c:203
* Line dtet.c:206: if
	LDB	7,U		variable `i', declared at dtet.c:197
* optim: loadCmpZeroBeqOrBne
	BNE	L00297		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00296 removed
* Line dtet.c:206
* Line dtet.c:206: function call: drawBlock()
	LDB	7,U		variable `i', declared at dtet.c:197
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 4 of drawBlock(): unsigned char
	LDB	-1,U		variable `blockColour', declared at dtet.c:198
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 3 of drawBlock(): unsigned char
	LDB	-2,U		variable blockY
	ADDB	5,U		variable y
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 2 of drawBlock(): unsigned char
	LDB	-3,U		variable blockX
	ADDB	#$11		17
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of drawBlock(): unsigned char
	LBSR	_drawBlock
	LEAS	8,S
	BRA	L00298		jump over else clause
L00297	EQU	*		else clause of if() started at dtet.c:206
* Line dtet.c:207
* Line dtet.c:207: function call: drawBlock()
	LDB	7,U		variable `i', declared at dtet.c:197
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 4 of drawBlock(): unsigned char
	LDB	-1,U		variable `blockColour', declared at dtet.c:198
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 3 of drawBlock(): unsigned char
	LDB	-2,U		variable blockY
	ADDB	5,U		variable y
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 2 of drawBlock(): unsigned char
	LDB	-3,U		variable blockX
	ADDB	#$FB		251
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of drawBlock(): unsigned char
	LBSR	_drawBlock
	LEAS	8,S
L00298	EQU	*		end of if() started at dtet.c:206
* Useless label L00288 removed
* Line dtet.c:201: for increment(s)
	INC	-3,U
L00287	EQU	*
* Line dtet.c:201: for condition
	LDB	-3,U		variable blockX
	CMPB	#$03
	LBLS	L00286
* optim: branchToNextLocation
* Useless label L00289 removed
* Useless label L00284 removed
* Line dtet.c:200: for increment(s)
	INC	-2,U
L00283	EQU	*
* Line dtet.c:200: for condition
	LDB	-2,U		variable blockY
	CMPB	#$03
	LBLS	L00282
* optim: branchToNextLocation
* Useless label L00285 removed
* Useless label L00129 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION drawNextShape(): defined at dtet.c:197
funcend_drawNextShape	EQU *
funcsize_drawNextShape	EQU	funcend_drawNextShape-_drawNextShape
_drawHeader	EXPORT


*******************************************************************************

* FUNCTION drawHeader(): defined at dtet.c:213
_drawHeader	EQU	*
* Prototype: void drawHeader(unsigned char, unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-13,S
* Formal parameter(s):
*      5,U:    1 byte : ingame: unsigned char: line 213
*      7,U:    1 byte : shift: unsigned char: line 213
* Local non-static variable(s):
*    -13,U:    1 byte : pos: unsigned char: line 221
*    -12,U:    1 byte : colour: unsigned char: line 214
*    -11,U:    7 bytes: colours: const unsigned char[]: line 215
*     -4,U:    1 byte : colourCount: unsigned char: line 216
*     -3,U:    1 byte : x: unsigned char: line 217
*     -2,U:    1 byte : y: unsigned char: line 218
*     -1,U:    1 byte : width: unsigned char: line 219
* Line dtet.c:215: init of variable colours
	LDB	#$02		decimal 2 signed
	STB	-11,U		offset in variable colours
	LDB	#$03		decimal 3 signed
	STB	-10,U		offset in variable colours
	LDB	#$04		decimal 4 signed
	STB	-9,U		offset in variable colours
	LDB	#$05		decimal 5 signed
	STB	-8,U		offset in variable colours
	LDB	#$06		decimal 6 signed
	STB	-7,U		offset in variable colours
	LDB	#$07		decimal 7 signed
	STB	-6,U		offset in variable colours
	LDB	#$08		decimal 8 signed
	STB	-5,U		offset in variable colours
* Line dtet.c:216: init of variable colourCount
	LDB	#$07		7
	STB	-4,U		variable colourCount
* Line dtet.c:217: init of variable x
* Line dtet.c:217: conditional expression
	LDB	5,U		variable `ingame', declared at dtet.c:213
* optim: loadCmpZeroBeqOrBne
	BEQ	L00300		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00299 removed
	CLRA
	LDB	#$0B		decimal 11 signed
	BRA	L00301		end of true expression of conditional
L00300	EQU	*
	CLRA
	LDB	#$08		decimal 8 signed
L00301	EQU	*
	STB	-3,U		variable x
* Line dtet.c:218: init of variable y
* Line dtet.c:218: conditional expression
	LDB	5,U		variable `ingame', declared at dtet.c:213
* optim: loadCmpZeroBeqOrBne
	BEQ	L00303		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00302 removed
	CLRA
	LDB	#$02		decimal 2 signed
	BRA	L00304		end of true expression of conditional
L00303	EQU	*
	CLRA
	LDB	#$01		decimal 1 signed
L00304	EQU	*
	STB	-2,U		variable y
* Line dtet.c:219: init of variable width
* Line dtet.c:219: conditional expression
	LDB	5,U		variable `ingame', declared at dtet.c:213
* optim: loadCmpZeroBeqOrBne
	BEQ	L00306		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00305 removed
	CLRA
	LDB	#$0A		decimal 10 signed
	BRA	L00307		end of true expression of conditional
L00306	EQU	*
	CLRA
	LDB	#$11		decimal 17 signed
L00307	EQU	*
	STB	-1,U		variable width
* Line dtet.c:221: for init
* Line dtet.c:221: init of variable pos
	CLR	-13,U		variable pos
	LBRA	L00309		jump to for condition
L00308	EQU	*
* Line dtet.c:221: for body
* Line dtet.c:223: assignment: =
	LDB	-13,U		variable pos
	ADDB	7,U		variable shift
	TFR	B,A		dividend expected in A
	LDB	-4,U		divisor
	LBSR	DIV8
	TFR	A,B		resulting modulo in B
	LEAX	-11,U		address of array colours
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	STB	-12,U
* Line dtet.c:224: function call: printBlock()
* optim: storeLoad
	ADDB	#$FF		255
	LSLB
	LSLB
	LSLB
	LSLB
	PSHS	B
	CLRA
	LDB	#$8F		decimal 143 signed
	ADDB	,S+
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 3 of printBlock(): unsigned char
	LDB	-2,U		variable `y', declared at dtet.c:218
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 2 of printBlock(): unsigned char
	LDB	-3,U		variable x
	ADDB	-13,U		variable pos
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of printBlock(): unsigned char
	LBSR	_printBlock
	LEAS	6,S
* Line dtet.c:226: assignment: =
	LDB	7,U		variable `shift', declared at dtet.c:213
	PSHS	B
	LDB	-13,U		variable pos
	ADDB	-4,U		variable colourCount
	SUBB	,S+
	TFR	B,A		dividend expected in A
	LDB	-4,U		divisor
	LBSR	DIV8
	TFR	A,B		resulting modulo in B
	LEAX	-11,U		address of array colours
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	STB	-12,U
* Line dtet.c:227: function call: printBlock()
* optim: storeLoad
	ADDB	#$FF		255
	LSLB
	LSLB
	LSLB
	LSLB
	PSHS	B
	CLRA
	LDB	#$8F		decimal 143 signed
	ADDB	,S+
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 3 of printBlock(): unsigned char
	LDB	-2,U		variable y
	ADDB	#$02		2
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 2 of printBlock(): unsigned char
	LDB	-3,U		variable x
	ADDB	-13,U		variable pos
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of printBlock(): unsigned char
	LBSR	_printBlock
	LEAS	6,S
* Useless label L00310 removed
* Line dtet.c:221: for increment(s)
	INC	-13,U
L00309	EQU	*
* Line dtet.c:221: for condition
	LDB	-13,U		variable pos
	CMPB	-1,U		variable width
	LBLO	L00308
* optim: branchToNextLocation
* Useless label L00311 removed
* Line dtet.c:229: if
	LDB	5,U		variable `ingame', declared at dtet.c:213
* optim: loadCmpZeroBeqOrBne
	BEQ	L00313		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00312 removed
* Line dtet.c:229
* Line dtet.c:230: function call: locate()
	LDB	-2,U		variable y
	ADDB	#$01		1
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of locate(): unsigned char
	LDB	-3,U		variable `x', declared at dtet.c:217
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of locate(): unsigned char
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:230: function call: printf()
	LEAX	S00162,PCR	"DRAGONTET!"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
	BRA	L00314		jump over else clause
L00313	EQU	*		else clause of if() started at dtet.c:229
* Line dtet.c:232
* Line dtet.c:233: function call: locate()
	LDB	-2,U		variable y
	ADDB	#$01		1
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of locate(): unsigned char
	LDB	-3,U		variable `x', declared at dtet.c:217
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of locate(): unsigned char
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:233: function call: printf()
	LEAX	S00163,PCR	"D R A G O N T E T"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:234: function call: locate()
	CLRA
	LDB	#$05		decimal 5 signed
	PSHS	B,A		C function argument 2 of locate(): int
	LDB	-3,U		variable `x', declared at dtet.c:217
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of locate(): unsigned char
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:234: function call: printf()
	LEAX	S00164,PCR	"SALVAKANTERO 2025"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
L00314	EQU	*		end of if() started at dtet.c:229
* Useless label L00130 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION drawHeader(): defined at dtet.c:213
funcend_drawHeader	EQU *
funcsize_drawHeader	EQU	funcend_drawHeader-_drawHeader
_drawPlayerStatus	EXPORT


*******************************************************************************

* FUNCTION drawPlayerStatus(): defined at dtet.c:240
_drawPlayerStatus	EQU	*
* Prototype: void drawPlayerStatus(unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-1,S
* Formal parameter(s):
*      5,U:    1 byte : i: unsigned char: line 240
* Local non-static variable(s):
*     -1,U:    1 byte : yOffset: unsigned char: line 241
* Line dtet.c:241: init of variable yOffset
* Line dtet.c:241: conditional expression
	LDB	5,U		variable `i', declared at dtet.c:240
* optim: loadCmpZeroBeqOrBne
	BNE	L00316		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00315 removed
	CLRA
	CLRB
	BRA	L00317		end of true expression of conditional
L00316	EQU	*
	CLRA
	LDB	#$08		decimal 8 signed
L00317	EQU	*
	STB	-1,U		variable yOffset
* Line dtet.c:242: function call: locate()
* optim: storeLoad
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of locate(): unsigned char
	LDB	#$0C		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:242: function call: printf()
	LDB	5,U		variable i
	ADDB	#$01		1
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of printf(): unsigned char
	LEAX	S00165,PCR	"DRAGON %u"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	4,S
* Line dtet.c:243: function call: locate()
	LDB	-1,U		variable yOffset
	ADDB	#$01		1
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of locate(): unsigned char
	LDB	#$0B		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:243: function call: printf()
	LDB	5,U		variable i
	LEAX	_level+0,PCR	address of array level
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of printf(): unsigned char
	LEAX	S00166,PCR	"LEVEL:  %2u"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	4,S
* Line dtet.c:244: function call: locate()
	LDB	-1,U		variable yOffset
	ADDB	#$02		2
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of locate(): unsigned char
	LDB	#$0B		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:244: function call: printf()
	LDB	5,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_lines+0,PCR	address of array lines
* optimizeLoadDX
	LDD	D,X		get r-value
	PSHS	B,A		C function argument 2 of printf(): int
	LEAX	S00167,PCR	"LINES: %3d"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	4,S
* Line dtet.c:245: function call: locate()
	LDB	-1,U		variable yOffset
	ADDB	#$03		3
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of locate(): unsigned char
	LDB	#$0B		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:245: function call: printf()
	LDB	5,U		variable i
	ADDB	#$06		6
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_scores+0,PCR	address of array scores
* optimizeLoadDX
	LDD	D,X		get r-value
	PSHS	B,A		C function argument 2 of printf(): unsigned int
	LEAX	S00168,PCR	"SC: %6u"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	4,S
* Line dtet.c:246: function call: locate()
	LDB	-1,U		variable yOffset
	ADDB	#$04		4
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of locate(): unsigned char
	LDB	#$0B		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:246: function call: printf()
	LEAX	S00169,PCR	"NEXT:"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:247: function call: drawNextShape()
	LDB	5,U		variable `i', declared at dtet.c:240
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawNextShape(): unsigned char
* Line dtet.c:247: conditional expression
	LDB	5,U		variable `i', declared at dtet.c:240
* optim: loadCmpZeroBeqOrBne
	BNE	L00319		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00318 removed
	CLRA
	LDB	#$04		decimal 4 signed
	BRA	L00320		end of true expression of conditional
L00319	EQU	*
	LDB	#$0C		optim: lddToLDB
L00320	EQU	*
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 1 of drawNextShape(): char
	LBSR	_drawNextShape
	LEAS	4,S
* Useless label L00131 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION drawPlayerStatus(): defined at dtet.c:240
funcend_drawPlayerStatus	EQU *
funcsize_drawPlayerStatus	EQU	funcend_drawPlayerStatus-_drawPlayerStatus
_displayStatus	EXPORT


*******************************************************************************

* FUNCTION displayStatus(): defined at dtet.c:251
_displayStatus	EQU	*
* Prototype: void displayStatus(...)
* Calling convention: 0 (CMOC Default)
* Line dtet.c:253: if
	LDB	_numPlayers+0,PCR	variable `numPlayers', declared at dtet.c:82
* optim: loadCmpZeroBeqOrBne
	LBNE	L00322		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00321 removed
* Line dtet.c:253
* Line dtet.c:254: function call: drawHeader()
	INC	_colourShift+0,PCR
	LDB	_colourShift+0,PCR
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawHeader(): unsigned char
	LDB	#$01		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of drawHeader(): int
	LBSR	_drawHeader
	LEAS	4,S
* Line dtet.c:255: function call: locate()
	CLRA
	LDB	#$06		decimal 6 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$0B		decimal 11 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:255: function call: printf()
	LDB	_level+0,PCR	index 0 in array level[]
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of printf(): unsigned char
	LEAX	S00166,PCR	"LEVEL:  %2u"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	4,S
* Line dtet.c:256: function call: locate()
	CLRA
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$0B		decimal 11 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:256: function call: printf()
	LDD	_lines+0,PCR	index 0 in array lines[]
	PSHS	B,A		C function argument 2 of printf(): int
	LEAX	S00167,PCR	"LINES: %3d"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	4,S
* Line dtet.c:257: function call: locate()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$0B		decimal 11 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:257: function call: printf()
	LDD	_scores+12,PCR	index 6 in array scores[]
	PSHS	B,A		C function argument 2 of printf(): unsigned int
	LEAX	S00168,PCR	"SC: %6u"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	4,S
* Line dtet.c:258: function call: locate()
	CLRA
	LDB	#$09		decimal 9 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$0B		decimal 11 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:258: function call: printf()
	LDD	_scores+0,PCR	index 0 in array scores[]
	PSHS	B,A		C function argument 2 of printf(): unsigned int
	LEAX	S00170,PCR	"HI: %6u"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	4,S
* Line dtet.c:259: function call: locate()
	CLRA
	LDB	#$0B		decimal 11 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$0B		decimal 11 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:259: function call: printf()
	LEAX	S00169,PCR	"NEXT:"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:260: function call: drawNextShape()
	CLRA
	CLRB
	PSHS	B,A		C function argument 2 of drawNextShape(): int
	LDB	#$0A		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of drawNextShape(): int
	LBSR	_drawNextShape
	LEAS	4,S
* Line dtet.c:262: function call: locate()
	CLRA
	LDB	#$0E		decimal 14 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$0B		decimal 11 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:263: if
	LDB	_lastLines+0,PCR	variable lastLines
* optim: removeCMPZeroAfterLDIfBHI (BHI->BNE)
	BEQ	L00324		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00323 removed
* Line dtet.c:263
* Line dtet.c:263: function call: printf()
	LDD	_lastPoints+0,PCR	variable `lastPoints', declared at dtet.c:103
	PSHS	B,A		C function argument 3 of printf(): unsigned int
	LDB	_lastLines+0,PCR	variable `lastLines', declared at dtet.c:102
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of printf(): unsigned char
	LEAX	S00171,PCR	"%uLIN +%4u"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	6,S
	BRA	L00325		jump over else clause
L00324	EQU	*		else clause of if() started at dtet.c:263
* Line dtet.c:265
* Line dtet.c:264: if
	LDD	_lastPoints+0,PCR	variable lastPoints
* optim: removeCMPZeroAfterLDIfBHI (BHI->BNE)
	BEQ	L00327		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00326 removed
* Line dtet.c:264
* Line dtet.c:264: function call: printf()
	LDD	_lastPoints+0,PCR	variable `lastPoints', declared at dtet.c:103
	PSHS	B,A		C function argument 2 of printf(): unsigned int
	LEAX	S00172,PCR	"DROP   +%2u"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	4,S
	BRA	L00328		jump over else clause
L00327	EQU	*		else clause of if() started at dtet.c:264
* Line dtet.c:265
* Line dtet.c:265: function call: printf()
	LEAX	S00173,PCR	"          "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
L00328	EQU	*		end of if() started at dtet.c:264
L00325	EQU	*		end of if() started at dtet.c:263
* Line dtet.c:266: assignment: =
	CLR	_lastLines+0,PCR	variable lastLines
* Line dtet.c:267: assignment: =
	CLRA
	CLRB
	STD	_lastPoints+0,PCR
	BRA	L00329		jump over else clause
L00322	EQU	*		else clause of if() started at dtet.c:253
* Line dtet.c:269
* Line dtet.c:270: function call: drawPlayerStatus()
	CLRA
	CLRB
	PSHS	B,A		C function argument 1 of drawPlayerStatus(): int
	LBSR	_drawPlayerStatus
	LEAS	2,S
* Line dtet.c:271: function call: drawPlayerStatus()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of drawPlayerStatus(): int
	LBSR	_drawPlayerStatus
	LEAS	2,S
L00329	EQU	*		end of if() started at dtet.c:253
* Line dtet.c:273: function call: locate()
	CLRA
	LDB	#$0F		decimal 15 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$0E		decimal 14 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Useless label L00132 removed
	RTS
* END FUNCTION displayStatus(): defined at dtet.c:251
funcend_displayStatus	EQU *
funcsize_displayStatus	EQU	funcend_displayStatus-_displayStatus
_getShapeMap	EXPORT


*******************************************************************************

* FUNCTION getShapeMap(): defined at dtet.c:277
_getShapeMap	EQU	*
* Prototype: const char *getShapeMap(unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
* Formal parameter(s):
*      5,U:    1 byte : shape: unsigned char: line 277
	TST	.local.static.getShapeMap.shapeMaps.initialized	has `shapeMaps' been initialized?
	BNE	L00330		if yes, skip init code
* Line dtet.c:278: init of variable shapeMaps
	LEAX	S00174,PCR	"0000444400000000"
	STX	.local.static.getShapeMap.shapeMaps+0,PCR	offset in variable shapeMaps
	LEAX	S00175,PCR	"0000222000200000"
	STX	.local.static.getShapeMap.shapeMaps+2,PCR	offset in variable shapeMaps
	LEAX	S00176,PCR	"0000777070000000"
	STX	.local.static.getShapeMap.shapeMaps+4,PCR	offset in variable shapeMaps
	LEAX	S00177,PCR	"0000033003300000"
	STX	.local.static.getShapeMap.shapeMaps+6,PCR	offset in variable shapeMaps
	LEAX	S00178,PCR	"0000066066000000"
	STX	.local.static.getShapeMap.shapeMaps+8,PCR	offset in variable shapeMaps
	LEAX	S00179,PCR	"0000880008800000"
	STX	.local.static.getShapeMap.shapeMaps+10,PCR	offset in variable shapeMaps
	LEAX	S00180,PCR	"0000111001000000"
	STX	.local.static.getShapeMap.shapeMaps+12,PCR	offset in variable shapeMaps
	INC	.local.static.getShapeMap.shapeMaps.initialized	mark `shapeMaps' as initialized
L00330	EQU	*
* Line dtet.c:287: return with value
	LDB	5,U		variable shape
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	.local.static.getShapeMap.shapeMaps+0,PCR	address of array shapeMaps
* optimizeLoadDX
	LDD	D,X		get r-value
* optim: branchToNextLocation
* Useless label L00133 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION getShapeMap(): defined at dtet.c:277
funcend_getShapeMap	EQU *
funcsize_getShapeMap	EQU	funcend_getShapeMap-_getShapeMap
_getRotatedShapeMap	EXPORT


*******************************************************************************

* FUNCTION getRotatedShapeMap(): defined at dtet.c:291
_getRotatedShapeMap	EQU	*
* Prototype: void getRotatedShapeMap(unsigned char, unsigned char, char *)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-12,S
* Formal parameter(s):
*      5,U:    1 byte : shape: unsigned char: line 291
*      7,U:    1 byte : angle: unsigned char: line 291
*      8,U:    2 bytes: rotatedMap: char *: line 291
* Local non-static variable(s):
*    -12,U:    2 bytes: blockX: int: line 302
*    -10,U:    2 bytes: blockY: int: line 303
*     -8,U:    2 bytes: newBlockX: int: line 304
*     -6,U:    2 bytes: newBlockY: int: line 304
*     -4,U:    2 bytes: i: int: line 301
*     -2,U:    2 bytes: map: const char *: line 292
* Line dtet.c:292: init of variable map
* Line dtet.c:292: function call: getShapeMap()
	LDB	5,U		variable `shape', declared at dtet.c:291
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 1 of getShapeMap(): unsigned char
	LBSR	_getShapeMap
	LEAS	2,S
	STD	-2,U		variable map
* Line dtet.c:294: if
	LDB	7,U		variable `angle', declared at dtet.c:291
* optim: loadCmpZeroBeqOrBne
	BNE	L00332		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00331 removed
* Line dtet.c:294
* Line dtet.c:295: function call: strncpy()
	CLRA
	LDB	#$10		decimal 16 signed
	PSHS	B,A		C function argument 3 of strncpy(): int
	LDD	-2,U		variable `map', declared at dtet.c:292
	PSHS	B,A		C function argument 2 of strncpy(): const char *
	LDD	8,U		variable `rotatedMap', declared at dtet.c:291
	PSHS	B,A		C function argument 1 of strncpy(): char *
	LBSR	_strncpy
	LEAS	6,S
	LBRA	L00134		return (dtet.c:296)
L00332	EQU	*		else clause of if() started at dtet.c:294
* Useless label L00333 removed
* Line dtet.c:299: function call: memset()
	CLRA
	LDB	#$10		decimal 16 signed
	PSHS	B,A		C function argument 3 of memset(): int
	LDB	#$30		decimal 48 signed
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 2 of memset(): char
	LDD	8,U		variable `rotatedMap', declared at dtet.c:291
	PSHS	B,A		C function argument 1 of memset(): char *
	LBSR	_memset
	LEAS	6,S
* Line dtet.c:301: for init
* Line dtet.c:301: init of variable i
	CLRA
	CLRB
	STD	-4,U		variable i
	LBRA	L00335		jump to for condition
L00334	EQU	*
* Line dtet.c:301: for body
* Line dtet.c:302: init of variable blockX
	LDX	-4,U		left
	CLRA
	LDB	#$04		right
	LBSR	SDIV16
	STD	-12,U		variable blockX
* Line dtet.c:303: init of variable blockY
	LDX	-4,U		left
	CLRA
	LDB	#$04		right
	LBSR	SDIV16
	TFR	X,D		quotient
	STD	-10,U		variable blockY
* Line dtet.c:304: init of variable newBlockX
	CLRA
	CLRB
	STD	-8,U		variable newBlockX
* Line dtet.c:304: init of variable newBlockY
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
	STD	-6,U		variable newBlockY
* Line dtet.c:305: switch
	LDB	7,U		variable `angle', declared at dtet.c:291
* Switch at dtet.c:305 has 3 non-ignored case values.
* Switch at dtet.c:305 uses if-else sequence: IF_ELSE=21, JUMP_TABLE=26
* Switch case at dtet.c:306
	CMPB	#$01		case 1
	BEQ	L00339
* Switch case at dtet.c:310
	CMPB	#$02		case 2
	BEQ	L00340
* Switch case at dtet.c:314
	CMPB	#$03		case 3
	BEQ	L00341
	BRA	L00338		switch default
L00339	EQU	*		case 1
* Line dtet.c:307: assignment: =
* optim: stripConsecutiveLoadsToSameReg
	LDD	-10,U
	STD	-8,U
* Line dtet.c:308: assignment: =
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	CLRA
	LDB	#$03		decimal 3 signed
	SUBD	-12,U		optim: optimizeStackOperations4
	STD	-6,U
	BRA	L00338		break
L00340	EQU	*		case 2
* Line dtet.c:311: assignment: =
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	CLRA
	LDB	#$03		decimal 3 signed
	SUBD	-12,U		optim: optimizeStackOperations4
	STD	-8,U
* Line dtet.c:312: assignment: =
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	CLRA
	LDB	#$03		decimal 3 signed
	SUBD	-10,U		optim: optimizeStackOperations4
	STD	-6,U
	BRA	L00338		break
L00341	EQU	*		case 3
* Line dtet.c:315: assignment: =
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	CLRA
	LDB	#$03		decimal 3 signed
	SUBD	-10,U		optim: optimizeStackOperations4
	STD	-8,U
* Line dtet.c:316: assignment: =
* optim: stripConsecutiveLoadsToSameReg
	LDD	-12,U
	STD	-6,U
* optim: branchToNextLocation
L00338	EQU	*		end of switch
* Line dtet.c:320: assignment: =
	LDD	-12,U		variable `blockX', declared at dtet.c:302
	PSHS	B,A
	LDX	-10,U		left
* optim: removeClrAFromArrayIndexMul
	LDB	#$04		right
	LBSR	MUL168
	ADDD	,S++
	LDX	-2,U		pointer map
* optimizeLoadDX
	LDB	D,X		get r-value
	PSHS	B
	LDD	-8,U		variable `newBlockX', declared at dtet.c:304
	PSHS	B,A
	LDX	-6,U		left
* optim: removeClrAFromArrayIndexMul
	LDB	#$04		right
	LBSR	MUL168
	ADDD	,S++
	LDX	8,U		pointer rotatedMap
	LEAX	D,X		add offset
	LDB	,S+
	STB	,X
* Useless label L00336 removed
* Line dtet.c:301: for increment(s)
	LDD	-4,U
	ADDD	#1
	STD	-4,U
L00335	EQU	*
* Line dtet.c:301: for condition
	LDD	-4,U		variable i
	CMPD	#$10
	LBLT	L00334
* optim: branchToNextLocation
* Useless label L00337 removed
L00134	EQU	*		end of getRotatedShapeMap()
	LEAS	,U
	PULS	U,PC
* END FUNCTION getRotatedShapeMap(): defined at dtet.c:291
funcend_getRotatedShapeMap	EQU *
funcsize_getRotatedShapeMap	EQU	funcend_getRotatedShapeMap-_getRotatedShapeMap
_createNextShape	EXPORT


*******************************************************************************

* FUNCTION createNextShape(): defined at dtet.c:325
_createNextShape	EQU	*
* Prototype: void createNextShape(unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
* Formal parameter(s):
*      5,U:    1 byte : i: unsigned char: line 325
* Line dtet.c:326: assignment: =
* Line dtet.c:326: function call: rand()
	LBSR	_rand
* Cast from `int' to byte: result already in B
	TFR	B,A		dividend expected in A by DIV8BY7
	LBSR	DIV8BY7
	TFR	A,B		resulting modulo in B
	PSHS	B
	LDB	5,U		variable i
	LEAX	_nextShape+0,PCR	address of array nextShape
	ABX			add unsigned 8-bit offset
	LDB	,S+
	STB	,X
* Line dtet.c:327: function call: memcpy()
	CLRA
	LDB	#$10		decimal 16 signed
	PSHS	B,A		C function argument 3 of memcpy(): int
* Line dtet.c:327: function call: getShapeMap()
	LDB	5,U		variable i
	LEAX	_nextShape+0,PCR	address of array nextShape
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of getShapeMap(): unsigned char
	LBSR	_getShapeMap
	LEAS	2,S
	PSHS	B,A		C function argument 2 of memcpy(): const char *
	LDB	5,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LEAX	_nextShapeMap+0,PCR	address of array nextShapeMap
	LEAX	D,X		add offset
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LBSR	_memcpy
	LEAS	6,S
* Useless label L00135 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION createNextShape(): defined at dtet.c:325
funcend_createNextShape	EQU *
funcsize_createNextShape	EQU	funcend_createNextShape-_createNextShape
_createShape	EXPORT


*******************************************************************************

* FUNCTION createShape(): defined at dtet.c:331
_createShape	EQU	*
* Prototype: void createShape(unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
* Formal parameter(s):
*      5,U:    1 byte : i: unsigned char: line 331
* Line dtet.c:334: assignment: =
* Line dtet.c:333: conditional expression
	CLRA
* optim: stripConsecutiveLoadsToSameReg
* PSHS B,A optim: optimizeStackOperations1
	LDB	5,U		variable i
	LEAX	_level+0,PCR	address of array level
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
* optim: stripExtraClrA_B
	CMPD	#9		optim: optimizeStackOperations1
	BHS	L00343		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00342 removed
	LDB	5,U		variable i
	LEAX	_level+0,PCR	address of array level
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	CLRA			promotion of binary operand
	PSHS	B,A
	LDB	#$04		optim: changeLoadDToLoadB
	LDA	1,S		load LSB of left side of multiplication
	LEAS	2,S		pop left side
	MUL			only LSB used, left in B
* optim: removePushBBeforeSubB
	CLRA
	NEGB			optim: removePushBBeforeSubB
	ADDB	#$28		optim: removePushBBeforeSubB
* optim: stripExtraClrA_B
	BRA	L00344		end of true expression of conditional
L00343	EQU	*
	LDB	#$06		optim: lddToLDB
L00344	EQU	*
	CLRA
	PSHS	B,A
	LDB	5,U		variable i
* optim: stripExtraClrA_B
	LSLB
	ROLA
	LEAX	_dropRate+0,PCR	address of array dropRate
	LEAX	D,X		add offset
	PULS	A,B		retrieve value to store
	STD	,X
* Line dtet.c:336: assignment: =
* Line dtet.c:336: conditional expression
	CLRA
* optim: stripConsecutiveLoadsToSameReg
* PSHS B,A optim: optimizeStackOperations1
	LDB	5,U		variable i
	LEAX	_nextShape+0,PCR	address of array nextShape
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
* optim: stripExtraClrA_B
	CMPD	#255		optim: optimizeStackOperations1
	BEQ	L00346		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00345 removed
	LDB	5,U		variable i
	LEAX	_nextShape+0,PCR	address of array nextShape
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	BRA	L00347		end of true expression of conditional
L00346	EQU	*
* Line dtet.c:336: function call: rand()
	LBSR	_rand
	TFR	D,X		optim: stripExtraPulsX
	CLRA
	LDB	#$07		decimal 7 signed
* optim: stripExtraPulsX
	LBSR	SDIV16
* Cast from `int' to byte: result already in B
L00347	EQU	*
	PSHS	B
	LDB	5,U		variable i
	LEAX	_shape+0,PCR	address of array shape
	ABX			add unsigned 8-bit offset
	LDB	,S+
	STB	,X
* Line dtet.c:338: assignment: =
	CLRA
	LDB	#$03		decimal 3 signed
	PSHS	B,A
	LDB	5,U		variable i
* optim: stripExtraClrA_B
	LSLB
	ROLA
	LEAX	_shapeX+0,PCR	address of array shapeX
	LEAX	D,X		add offset
	PULS	A,B		retrieve value to store
	STD	,X
* Line dtet.c:339: assignment: =
	LDD	#$FFFD		constant expression: 65533 decimal, signed
	PSHS	B,A
	LDB	5,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_shapeY+0,PCR	address of array shapeY
	LEAX	D,X		add offset
	PULS	A,B		retrieve value to store
	STD	,X
* Line dtet.c:340: assignment: =
	CLRA
	CLRB
	PSHS	B
	LDB	5,U		variable i
	LEAX	_shapeAngle+0,PCR	address of array shapeAngle
	ABX			add unsigned 8-bit offset
	LDB	,S+
	STB	,X
* Line dtet.c:341: function call: memcpy()
* optim: stripExtraClrA_B
	LDB	#$10		decimal 16 signed
	PSHS	B,A		C function argument 3 of memcpy(): int
* Line dtet.c:341: function call: getShapeMap()
	LDB	5,U		variable i
	LEAX	_shape+0,PCR	address of array shape
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
* optim: removeClr
	PSHS	B,A		C function argument 1 of getShapeMap(): unsigned char
	LBSR	_getShapeMap
	LEAS	2,S
	PSHS	B,A		C function argument 2 of memcpy(): const char *
	LDB	5,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LEAX	_shapeMap+0,PCR	address of array shapeMap
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	PSHS	B,A		C function argument 1 of memcpy(): char[]
	LBSR	_memcpy
	LEAS	6,S
* Line dtet.c:343: function call: createNextShape()
	LDB	5,U		variable `i', declared at dtet.c:331
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 1 of createNextShape(): unsigned char
	LBSR	_createNextShape
	LEAS	2,S
* Useless label L00136 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION createShape(): defined at dtet.c:331
funcend_createShape	EQU *
funcsize_createShape	EQU	funcend_createShape-_createShape
_drawShape	EXPORT


*******************************************************************************

* FUNCTION drawShape(): defined at dtet.c:347
_drawShape	EQU	*
* Prototype: void drawShape(unsigned char, unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-9,S
* Formal parameter(s):
*      5,U:    1 byte : eraseShape: unsigned char: line 347
*      7,U:    1 byte : i: unsigned char: line 347
* Local non-static variable(s):
*     -9,U:    2 bytes: x: int: line 348
*     -7,U:    2 bytes: y: int: line 348
*     -5,U:    2 bytes: blockX: int: line 348
*     -3,U:    2 bytes: blockY: int: line 348
*     -1,U:    1 byte : blockColour: char: line 349
* Line dtet.c:351: for init
* Line dtet.c:351: assignment: =
	CLRA
	CLRB
	STD	-5,U
	LBRA	L00349		jump to for condition
L00348	EQU	*
* Line dtet.c:351: for body
* Line dtet.c:352: for init
* Line dtet.c:352: assignment: =
	CLRA
	CLRB
	STD	-3,U
	LBRA	L00353		jump to for condition
L00352	EQU	*
* Line dtet.c:352: for body
* Line dtet.c:353: assignment: =
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDB	7,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_shapeX+0,PCR	address of array shapeX
* optimizeLoadDX
	LDD	D,X		get r-value
	ADDD	-5,U		optim: optimizeStackOperations4
	STD	-9,U
* Line dtet.c:354: assignment: =
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDB	7,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_shapeY+0,PCR	address of array shapeY
* optimizeLoadDX
	LDD	D,X		get r-value
	ADDD	-3,U		optim: optimizeStackOperations4
	STD	-7,U
* Line dtet.c:356: if
	LDD	-9,U		variable x
	ADDD	#0
	LBLT	L00357		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00360 removed
	LDD	-9,U		variable x
	CMPD	#$0A
	LBGE	L00357		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00359 removed
	LDD	-7,U		variable y
	ADDD	#0
	LBLT	L00357		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00358 removed
	LDD	-7,U		variable y
	CMPD	#$10
	LBGE	L00357		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00356 removed
* Line dtet.c:356
* Line dtet.c:357: if
	LDB	5,U		variable `eraseShape', declared at dtet.c:347
* optim: loadCmpZeroBeqOrBne
	BEQ	L00362		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00361 removed
* Line dtet.c:357
* Line dtet.c:359: assignment: =
	LDD	-9,U		variable `x', declared at dtet.c:348
	PSHS	B,A
	LDD	-7,U		variable `y', declared at dtet.c:348
	LBSR	MUL16BY10
	ADDD	,S++
	PSHS	B,A		preserve array index
	LDB	7,U		variable i
* optim: stripOpToDeadReg
	LDA	#160		size of array element
	MUL			get offset in bytes in D
	LEAX	_pit+0,PCR	address of array pit
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,X		get r-value
	STB	-1,U
	LBRA	L00363		jump over else clause
L00362	EQU	*		else clause of if() started at dtet.c:357
* Line dtet.c:360
* Line dtet.c:362: assignment: =
	LDD	-5,U		variable `blockX', declared at dtet.c:348
	PSHS	B,A
	LDX	-3,U		left
* optim: removeClrAFromArrayIndexMul
	LDB	#$04		right
	LBSR	MUL168
	ADDD	,S++
	PSHS	B,A		preserve array index
	LDB	7,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LEAX	_shapeMap+0,PCR	address of array shapeMap
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,X		get r-value
	STB	-1,U
* Line dtet.c:364: if
* optim: storeLoad
	CMPB	#$30
	BNE	L00365		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00364 removed
* Line dtet.c:365
* Line dtet.c:365: assignment: =
	LDD	-9,U		variable `x', declared at dtet.c:348
	PSHS	B,A
	LDD	-7,U		variable `y', declared at dtet.c:348
	LBSR	MUL16BY10
	ADDD	,S++
	PSHS	B,A		preserve array index
	LDB	7,U		variable i
* optim: stripOpToDeadReg
	LDA	#160		size of array element
	MUL			get offset in bytes in D
	LEAX	_pit+0,PCR	address of array pit
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,X		get r-value
	STB	-1,U
L00365	EQU	*		else clause of if() started at dtet.c:364
* Useless label L00366 removed
L00363	EQU	*		end of if() started at dtet.c:357
* Line dtet.c:368: function call: drawBlock()
	LDB	7,U		variable `i', declared at dtet.c:347
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 4 of drawBlock(): unsigned char
	LDB	-1,U		variable `blockColour', declared at dtet.c:349
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 3 of drawBlock(): char
	LDD	-7,U		variable `y', declared at dtet.c:348
* Cast from `int' to byte: result already in B
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawBlock(): unsigned char
	LDD	-9,U		variable `x', declared at dtet.c:348
* Cast from `int' to byte: result already in B
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 1 of drawBlock(): unsigned char
	LBSR	_drawBlock
	LEAS	8,S
L00357	EQU	*		else clause of if() started at dtet.c:356
* Useless label L00367 removed
* Useless label L00354 removed
* Line dtet.c:352: for increment(s)
	LDD	-3,U
	ADDD	#1
	STD	-3,U
L00353	EQU	*
* Line dtet.c:352: for condition
	LDD	-3,U		variable blockY
	CMPD	#$03
	LBLE	L00352
* optim: branchToNextLocation
* Useless label L00355 removed
* Useless label L00350 removed
* Line dtet.c:351: for increment(s)
	LDD	-5,U
	ADDD	#1
	STD	-5,U
L00349	EQU	*
* Line dtet.c:351: for condition
	LDD	-5,U		variable blockX
	CMPD	#$03
	LBLE	L00348
* optim: branchToNextLocation
* Useless label L00351 removed
* Useless label L00137 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION drawShape(): defined at dtet.c:347
funcend_drawShape	EQU *
funcsize_drawShape	EQU	funcend_drawShape-_drawShape
_removeFullRow	EXPORT


*******************************************************************************

* FUNCTION removeFullRow(): defined at dtet.c:375
_removeFullRow	EQU	*
* Prototype: void removeFullRow(unsigned char, unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-4,S
* Formal parameter(s):
*      5,U:    1 byte : removedRow: unsigned char: line 375
*      7,U:    1 byte : i: unsigned char: line 375
* Local non-static variable(s):
*     -4,U:    1 byte : j: unsigned char: line 385
*     -3,U:    1 byte : x: unsigned char: line 376
*     -2,U:    1 byte : y: unsigned char: line 376
*     -1,U:    1 byte : blockColour: char: line 377
* Line dtet.c:380: for init
* Line dtet.c:380: assignment: =
	LDB	7,U		variable i
	LEAX	_pitLeft+0,PCR	address of array pitLeft
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	PSHS	B
	CLRA
	CLRB
	ADDB	,S+
	STB	-3,U
	BRA	L00369		jump to for condition
L00368	EQU	*
* Line dtet.c:381: for body
* Line dtet.c:381: function call: printBlock()
	CLRA
	LDB	#$CF		decimal 207 signed
	PSHS	B,A		C function argument 3 of printBlock(): int
	LDB	5,U		variable `removedRow', declared at dtet.c:375
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 2 of printBlock(): unsigned char
	LDB	-3,U		variable `x', declared at dtet.c:376
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of printBlock(): unsigned char
	LBSR	_printBlock
	LEAS	6,S
* Useless label L00370 removed
* Line dtet.c:380: for increment(s)
	INC	-3,U
L00369	EQU	*
* Line dtet.c:380: for condition
	LDB	7,U		variable i
	LEAX	_pitLeft+0,PCR	address of array pitLeft
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	PSHS	B
	CLRA
	LDB	#$0A		decimal 10 signed
	ADDB	,S+
	PSHS	B
	LDB	-3,U		variable `x', declared at dtet.c:376
	CMPB	,S+		compare with LSB
	BLO	L00368
* optim: branchToNextLocation
* Useless label L00371 removed
* Line dtet.c:384: if
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:100
* optim: loadCmpZeroBeqOrBne
	BNE	L00373
* optim: branchToNextLocation
* Useless label L00372 removed
* Line dtet.c:386
* Line dtet.c:385: for init
* Line dtet.c:385: init of variable j
	LDB	#$FF		255
	STB	-4,U		variable j
	BRA	L00375		jump to for condition
L00374	EQU	*
* Line dtet.c:386: for body
* Line dtet.c:386: function call: sound()
	CLRA
	CLRB
	PSHS	B,A		C function argument 2 of sound(): int
	LDB	-4,U		variable `j', declared at dtet.c:385
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of sound(): unsigned char
	LBSR	_sound
	LEAS	4,S
* Useless label L00376 removed
* Line dtet.c:385: for increment(s)
* Line dtet.c:385: assignment: =
	LDB	-4,U		variable j
	ADDB	#$FB		251
	STB	-4,U
L00375	EQU	*
* Line dtet.c:385: for condition
	LDB	-4,U		variable j
	CMPB	#$3C
	BHI	L00374
* optim: branchToNextLocation
* Useless label L00377 removed
L00373	EQU	*		else clause of if() started at dtet.c:384
* Useless label L00378 removed
* Line dtet.c:389: for init
* Line dtet.c:389: assignment: =
	LDB	5,U		variable `removedRow', declared at dtet.c:375
	STB	-2,U
	LBRA	L00380		jump to for condition
L00379	EQU	*
* Line dtet.c:389: for body
* Line dtet.c:390: for init
* Line dtet.c:390: assignment: =
	CLRB
	STB	-3,U		variable x
	LBRA	L00384		jump to for condition
L00383	EQU	*
* Line dtet.c:390: for body
* Line dtet.c:392: assignment: =
	LDB	-3,U		variable `x', declared at dtet.c:376
	PSHS	B
	LDB	-2,U		variable y
	ADDB	#$FF		255
	CLRA			promotion of binary operand
	PSHS	B,A
	LDB	#$0A		optim: changeLoadDToLoadB
	LDA	1,S		load LSB of left side of multiplication
	LEAS	2,S		pop left side
	MUL			only LSB used, left in B
	ADDB	,S+
	CLRA			extend byte index expression
	PSHS	B,A		preserve array index
	LDB	7,U		variable i
* optim: stripExtraClrA_B
	LDA	#160		size of array element
	MUL			get offset in bytes in D
	LEAX	_pit+0,PCR	address of array pit
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,X		get r-value
	STB	-1,U
* Line dtet.c:393: assignment: =
* optim: storeLoad
	PSHS	B
	LDB	-3,U		variable `x', declared at dtet.c:376
	PSHS	B
	LDA	-2,U
	LDB	#$0A
	MUL			result of type byte in B
	ADDB	,S+
	CLRA			extend byte index expression
	PSHS	B,A		preserve array index
	LDB	7,U		variable i
* optim: stripExtraClrA_B
	LDA	#160		size of array element
	MUL			get offset in bytes in D
	LEAX	_pit+0,PCR	address of array pit
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,S+
	STB	,X
* Useless label L00385 removed
* Line dtet.c:390: for increment(s)
	INC	-3,U
L00384	EQU	*
* Line dtet.c:390: for condition
	LDB	-3,U		variable x
	CMPB	#$0A
	LBLO	L00383
* optim: branchToNextLocation
* Useless label L00386 removed
* Useless label L00381 removed
* Line dtet.c:389: for increment(s)
	DEC	-2,U
L00380	EQU	*
* Line dtet.c:389: for condition
	LDB	-2,U		variable y
* optim: removeCMPZeroAfterLDIfBHI (BHI->BNE)
	LBNE	L00379
* optim: branchToNextLocation
* Useless label L00382 removed
* Line dtet.c:397: for init
* Line dtet.c:397: assignment: =
	CLRB
	STB	-3,U		variable x
	BRA	L00388		jump to for condition
L00387	EQU	*
* Line dtet.c:398: for body
* Line dtet.c:398: assignment: =
* LDB #$30 optim: optimizeStackOperations1
* PSHS B optim: optimizeStackOperations1
	LDB	-3,U		variable x
	CLRA			extend byte index expression
	PSHS	B,A		preserve array index
	LDB	7,U		variable i
* optim: stripExtraClrA_B
	LDA	#160		size of array element
	MUL			get offset in bytes in D
	LEAX	_pit+0,PCR	address of array pit
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	#48		optim: optimizeStackOperations1
	STB	,X
* Useless label L00389 removed
* Line dtet.c:397: for increment(s)
	INC	-3,U
L00388	EQU	*
* Line dtet.c:397: for condition
	LDB	-3,U		variable x
	CMPB	#$0A
	BLO	L00387
* optim: branchToNextLocation
* Useless label L00390 removed
* Useless label L00138 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION removeFullRow(): defined at dtet.c:375
funcend_removeFullRow	EQU *
funcsize_removeFullRow	EQU	funcend_removeFullRow-_removeFullRow
_setTrapLine	EXPORT


*******************************************************************************

* FUNCTION setTrapLine(): defined at dtet.c:402
_setTrapLine	EQU	*
* Prototype: void setTrapLine(unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-3,S
* Formal parameter(s):
*      5,U:    1 byte : i: unsigned char: line 402
* Local non-static variable(s):
*     -3,U:    1 byte : x: unsigned char: line 403
*     -2,U:    1 byte : y: unsigned char: line 403
*     -1,U:    1 byte : emptyX: unsigned char: line 403
* Line dtet.c:406: if
	LDB	_numPlayers+0,PCR	variable numPlayers
	CMPB	#$01
	BNE	L00392		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00391 removed
* Line dtet.c:407
* Line dtet.c:407: assignment: =
* Line dtet.c:407: conditional expression
	LDB	5,U		variable `i', declared at dtet.c:402
* optim: loadCmpZeroBeqOrBne
	BNE	L00394		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00393 removed
	CLRA
	LDB	#$01		decimal 1 signed
	BRA	L00395		end of true expression of conditional
L00394	EQU	*
	CLRA
	CLRB
L00395	EQU	*
	STB	5,U
L00392	EQU	*		else clause of if() started at dtet.c:406
* Useless label L00396 removed
* Line dtet.c:410: assignment: =
* Line dtet.c:410: function call: rand()
	LBSR	_rand
* Cast from `int' to byte: result already in B
	TFR	B,A		dividend expected in A
	LDB	#$0A		divisor
	LBSR	DIV8
	TFR	A,B		resulting modulo in B
	STB	-1,U
* Line dtet.c:413: for init
* Line dtet.c:413: assignment: =
	LDB	#$01
	STB	-2,U		variable y
	LBRA	L00398		jump to for condition
L00397	EQU	*
* Line dtet.c:415: for body
* Line dtet.c:414: for init
* Line dtet.c:414: assignment: =
	CLRB
	STB	-3,U		variable x
	LBRA	L00402		jump to for condition
L00401	EQU	*
* Line dtet.c:415: for body
* Line dtet.c:415: assignment: =
	LDB	-3,U		variable `x', declared at dtet.c:403
	PSHS	B
	LDA	-2,U
	LDB	#$0A
	MUL			result of type byte in B
	ADDB	,S+
	CLRA			extend byte index expression
	PSHS	B,A		preserve array index
	LDB	5,U		variable i
* optim: stripExtraClrA_B
	LDA	#160		size of array element
	MUL			get offset in bytes in D
	LEAX	_pit+0,PCR	address of array pit
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,X		get r-value
	PSHS	B
	LDB	-3,U		variable `x', declared at dtet.c:403
	PSHS	B
	LDB	-2,U		variable y
	ADDB	#$FF		255
	CLRA			promotion of binary operand
	PSHS	B,A
	LDB	#$0A		optim: changeLoadDToLoadB
	LDA	1,S		load LSB of left side of multiplication
	LEAS	2,S		pop left side
	MUL			only LSB used, left in B
	ADDB	,S+
	CLRA			extend byte index expression
	PSHS	B,A		preserve array index
	LDB	5,U		variable i
* optim: stripExtraClrA_B
	LDA	#160		size of array element
	MUL			get offset in bytes in D
	LEAX	_pit+0,PCR	address of array pit
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,S+
	STB	,X
* Useless label L00403 removed
* Line dtet.c:414: for increment(s)
	INC	-3,U
L00402	EQU	*
* Line dtet.c:414: for condition
	LDB	-3,U		variable x
	CMPB	#$0A
	LBLO	L00401
* optim: branchToNextLocation
* Useless label L00404 removed
* Useless label L00399 removed
* Line dtet.c:413: for increment(s)
	INC	-2,U
L00398	EQU	*
* Line dtet.c:413: for condition
	LDB	-2,U		variable y
	CMPB	#$10
	LBLO	L00397
* optim: branchToNextLocation
* Useless label L00400 removed
* Line dtet.c:418: for init
* Line dtet.c:418: assignment: =
	CLRB
	STB	-3,U		variable x
	BRA	L00406		jump to for condition
L00405	EQU	*
* Line dtet.c:419: for body
* Line dtet.c:419: assignment: =
* Line dtet.c:419: conditional expression
	LDB	-3,U		variable x
	CMPB	-1,U		variable emptyX
	BNE	L00410		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00409 removed
	LDB	#$30		decimal 48 signed
	BRA	L00411		end of true expression of conditional
L00410	EQU	*
	LDB	#$35		decimal 53 signed
L00411	EQU	*
	PSHS	B
	LDB	-3,U		variable x
	ADDB	#$96		150
	CLRA			extend byte index expression
	PSHS	B,A		preserve array index
	LDB	5,U		variable i
* optim: stripExtraClrA_B
	LDA	#160		size of array element
	MUL			get offset in bytes in D
	LEAX	_pit+0,PCR	address of array pit
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,S+
	STB	,X
* Useless label L00407 removed
* Line dtet.c:418: for increment(s)
	INC	-3,U
L00406	EQU	*
* Line dtet.c:418: for condition
	LDB	-3,U		variable x
	CMPB	#$0A
	BLO	L00405
* optim: branchToNextLocation
* Useless label L00408 removed
* Line dtet.c:422: if
	LDB	_numPlayers+0,PCR	variable numPlayers
* optim: removeCMPZeroAfterLDIfBHI (BHI->BNE)
	BEQ	L00413		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00412 removed
* Line dtet.c:422
* Line dtet.c:422: function call: drawPit()
	LDB	5,U		variable `i', declared at dtet.c:402
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 1 of drawPit(): unsigned char
	LBSR	_drawPit
	LEAS	2,S
L00413	EQU	*		else clause of if() started at dtet.c:422
* Useless label L00414 removed
* Line dtet.c:424: if
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:100
* optim: loadCmpZeroBeqOrBne
	BNE	L00416
* optim: branchToNextLocation
* Useless label L00415 removed
* Line dtet.c:424
* Line dtet.c:424: function call: sound()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 2 of sound(): int
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of sound(): int
	LBSR	_sound
	LEAS	4,S
L00416	EQU	*		else clause of if() started at dtet.c:424
* Useless label L00417 removed
* Useless label L00139 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION setTrapLine(): defined at dtet.c:402
funcend_setTrapLine	EQU *
funcsize_setTrapLine	EQU	funcend_setTrapLine-_setTrapLine
_setTrapBlock	EXPORT


*******************************************************************************

* FUNCTION setTrapBlock(): defined at dtet.c:428
_setTrapBlock	EQU	*
* Prototype: void setTrapBlock(unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-6,S
* Formal parameter(s):
*      5,U:    1 byte : i: unsigned char: line 428
* Local non-static variable(s):
*     -6,U:    2 bytes: x: int: line 429
*     -4,U:    2 bytes: y: int: line 429
*     -2,U:    1 byte : rowEmpty: unsigned char: line 430
*     -1,U:    1 byte : attempts: unsigned char: line 430
* Line dtet.c:430: init of variable attempts
	LDB	#$05		5
	STB	-1,U		variable attempts
* Line dtet.c:433: if
	LDB	_numPlayers+0,PCR	variable numPlayers
	CMPB	#$01
	LBNE	L00425		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00418 removed
* Line dtet.c:434
* Line dtet.c:434: assignment: =
* Line dtet.c:434: conditional expression
	LDB	5,U		variable `i', declared at dtet.c:428
* optim: loadCmpZeroBeqOrBne
	BNE	L00421		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00420 removed
	CLRA
	LDB	#$01		decimal 1 signed
	BRA	L00422		end of true expression of conditional
L00421	EQU	*
	CLRA
	CLRB
L00422	EQU	*
	STB	5,U
* Useless label L00419 removed
* Useless label L00423 removed
* Line dtet.c:436: while
	LBRA	L00425		jump to while condition
L00424	EQU	*		while body
* Line dtet.c:438: assignment: =
* Line dtet.c:438: function call: rand()
	LBSR	_rand
	TFR	D,X		optim: stripExtraPulsX
	CLRA
	LDB	#$0B		constant expression: 11 decimal, signed
* optim: stripExtraPulsX
	LBSR	SDIV16
	ADDD	#$05		optim: pushDLoadAdd
* 
* 
	STD	-4,U
* Line dtet.c:440: assignment: =
	LDB	#$01
	STB	-2,U		variable rowEmpty
* Line dtet.c:441: for init
* Line dtet.c:441: assignment: =
	CLRA
	CLRB
	STD	-6,U
	BRA	L00428		jump to for condition
L00427	EQU	*
* Line dtet.c:447: for body
* Line dtet.c:442: if
	LDD	-6,U		variable `x', declared at dtet.c:429
	PSHS	B,A
	LDD	-4,U		variable `y', declared at dtet.c:429
	LBSR	MUL16BY10
	ADDD	,S++
	PSHS	B,A		preserve array index
	LDB	5,U		variable i
* optim: stripOpToDeadReg
	LDA	#160		size of array element
	MUL			get offset in bytes in D
	LEAX	_pit+0,PCR	address of array pit
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,X		get r-value
	CMPB	#48
	BEQ	L00432		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00431 removed
* Line dtet.c:442
* Line dtet.c:443: assignment: =
	CLR	-2,U		variable rowEmpty
	BRA	L00430		break
L00432	EQU	*		else clause of if() started at dtet.c:442
* Useless label L00433 removed
* Useless label L00429 removed
* Line dtet.c:441: for increment(s)
	LDD	-6,U
	ADDD	#1
	STD	-6,U
L00428	EQU	*
* Line dtet.c:441: for condition
	LDD	-6,U		variable x
	CMPD	#$0A
	BLT	L00427
* optim: branchToNextLocation
L00430	EQU	*		end for
* Line dtet.c:447: if
	LDB	-2,U		variable `rowEmpty', declared at dtet.c:430
* optim: loadCmpZeroBeqOrBne
	LBEQ	L00435		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00434 removed
* Line dtet.c:447
* Line dtet.c:448: assignment: =
* Line dtet.c:448: function call: rand()
	LBSR	_rand
	TFR	D,X		optim: stripExtraPulsX
	CLRA
	LDB	#$0A		decimal 10 signed
* optim: stripExtraPulsX
	LBSR	SDIV16
	STD	-6,U
* Line dtet.c:449: assignment: =
	CLRA
	LDB	#$05		decimal 5 signed
	PSHS	B
	LDD	-6,U		variable `x', declared at dtet.c:429
	PSHS	B,A
	LDD	-4,U		variable `y', declared at dtet.c:429
	LBSR	MUL16BY10
	ADDD	,S++
	PSHS	B,A		preserve array index
	LDB	5,U		variable i
* optim: stripOpToDeadReg
	LDA	#160		size of array element
	MUL			get offset in bytes in D
	LEAX	_pit+0,PCR	address of array pit
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,S+
	STB	,X
* Line dtet.c:451: if
	LDB	_numPlayers+0,PCR	variable numPlayers
* optim: removeCMPZeroAfterLDIfBHI (BHI->BNE)
	BEQ	L00437		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00436 removed
* Line dtet.c:451
* Line dtet.c:451: function call: printBlock()
	LDX	#$CF		optim: transformPshsDPshsD
* optim: mergePushXPushD
	LDD	-4,U		variable `y', declared at dtet.c:429
	PSHS	X,B,A		optim: mergePushXPushD
	LDB	5,U		variable i
	LEAX	_pitLeft+0,PCR	address of array pitLeft
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	CLRA			promotion of binary operand
	ADDD	-6,U		optim: pushDLoadAdd
* 
* 
	PSHS	B,A		C function argument 1 of printBlock(): int
	LBSR	_printBlock
	LEAS	6,S
L00437	EQU	*		else clause of if() started at dtet.c:451
* Useless label L00438 removed
* Line dtet.c:453: if
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:100
* optim: loadCmpZeroBeqOrBne
	BNE	L00140
* optim: branchToNextLocation
* Useless label L00439 removed
* Line dtet.c:453
* Line dtet.c:453: function call: sound()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 2 of sound(): int
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of sound(): int
	LBSR	_sound
	LEAS	4,S
* Useless label L00440 removed
* Useless label L00441 removed
	BRA	L00140		return (dtet.c:454)
L00435	EQU	*		else clause of if() started at dtet.c:447
* Useless label L00442 removed
* Line dtet.c:456: post-decrement
	DEC	-1,U
L00425	EQU	*		while condition at dtet.c:436
	LDB	-1,U		variable attempts
* optim: removeCMPZeroAfterLDIfBHI (BHI->BNE)
	LBNE	L00424
* optim: branchToNextLocation
* Useless label L00426 removed
L00140	EQU	*		end of setTrapBlock()
	LEAS	,U
	PULS	U,PC
* END FUNCTION setTrapBlock(): defined at dtet.c:428
funcend_setTrapBlock	EQU *
funcsize_setTrapBlock	EQU	funcend_setTrapBlock-_setTrapBlock
_checkForFullRows	EXPORT


*******************************************************************************

* FUNCTION checkForFullRows(): defined at dtet.c:461
_checkForFullRows	EQU	*
* Prototype: void checkForFullRows(unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-13,S
* Formal parameter(s):
*      5,U:    1 byte : i: unsigned char: line 461
* Local non-static variable(s):
*    -13,U:    8 bytes: pointsPerLine: const int[]: line 486
*     -5,U:    1 byte : fullRow: unsigned char: line 462
*     -4,U:    1 byte : numLines: unsigned char: line 463
*     -3,U:    1 byte : x: unsigned char: line 464
*     -2,U:    1 byte : y: unsigned char: line 464
*     -1,U:    1 byte : j: unsigned char: line 465
* Line dtet.c:463: init of variable numLines
	CLR	-4,U		variable numLines
* Line dtet.c:465: init of variable j
	LDB	5,U		variable i
	ADDB	#$06		6
	STB	-1,U		variable j
* Line dtet.c:467: for init
* Line dtet.c:467: assignment: =
	CLRB
	STB	-2,U		variable y
	LBRA	L00444		jump to for condition
L00443	EQU	*
* Line dtet.c:467: for body
* Line dtet.c:468: assignment: =
	LDB	#$01
	STB	-5,U		variable fullRow
* Line dtet.c:470: for init
* Line dtet.c:470: assignment: =
	CLRB
	STB	-3,U		variable x
	BRA	L00448		jump to for condition
L00447	EQU	*
* Line dtet.c:470: for body
* Line dtet.c:471: if
* optim: optimize8BitStackOps
* optim: optimize8BitStackOps
	LDA	-2,U
	LDB	#$0A
	MUL			result of type byte in B
	ADDB	-3,U		optim: optimize8BitStackOps
	CLRA			extend byte index expression
	PSHS	B,A		preserve array index
	LDB	5,U		variable i
* optim: stripExtraClrA_B
	LDA	#160		size of array element
	MUL			get offset in bytes in D
	LEAX	_pit+0,PCR	address of array pit
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,X		get r-value
	CMPB	#48
	BNE	L00452		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00451 removed
* Line dtet.c:471
* Line dtet.c:472: assignment: =
	CLR	-5,U		variable fullRow
	BRA	L00450		break
L00452	EQU	*		else clause of if() started at dtet.c:471
* Useless label L00453 removed
* Useless label L00449 removed
* Line dtet.c:470: for increment(s)
	INC	-3,U
L00448	EQU	*
* Line dtet.c:470: for condition
	LDB	-3,U		variable x
	CMPB	#$0A
	BLO	L00447
* optim: branchToNextLocation
L00450	EQU	*		end for
* Line dtet.c:477: if
	LDB	-5,U		variable `fullRow', declared at dtet.c:462
* optim: loadCmpZeroBeqOrBne
	BEQ	L00455		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00454 removed
* Line dtet.c:477
* Line dtet.c:478: function call: removeFullRow()
	LDB	5,U		variable `i', declared at dtet.c:461
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of removeFullRow(): unsigned char
	LDB	-2,U		variable `y', declared at dtet.c:464
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of removeFullRow(): unsigned char
	LBSR	_removeFullRow
	LEAS	4,S
* Line dtet.c:479: post-increment
	INC	-4,U
* Line dtet.c:480: if
	LDB	_numPlayers+0,PCR	variable numPlayers
* optim: removeCMPZeroAfterLDIfBHI (BHI->BNE)
	BEQ	L00457		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00458 removed
	CLRA
* optim: stripConsecutiveLoadsToSameReg
* PSHS B,A optim: optimizeStackOperations1
	LDB	5,U		variable i
	LEAX	_level+0,PCR	address of array level
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
* optim: stripExtraClrA_B
	CMPD	#3		optim: optimizeStackOperations1
	BLS	L00457		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00456 removed
* Line dtet.c:481
* Line dtet.c:481: post-increment
	LDB	5,U		variable i
	LEAX	_linesPiecesPlayed+0,PCR	address of array linesPiecesPlayed
	ABX			add unsigned 8-bit offset
	INC	,X
L00457	EQU	*		else clause of if() started at dtet.c:480
* Useless label L00459 removed
L00455	EQU	*		else clause of if() started at dtet.c:477
* Useless label L00460 removed
* Useless label L00445 removed
* Line dtet.c:467: for increment(s)
	INC	-2,U
L00444	EQU	*
* Line dtet.c:467: for condition
	LDB	-2,U		variable y
	CMPB	#$10
	LBLO	L00443
* optim: branchToNextLocation
* Useless label L00446 removed
* Line dtet.c:485: if
	LDB	-4,U		variable numLines
* optim: removeCMPZeroAfterLDIfBHI (BHI->BNE)
	LBEQ	L00462		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00461 removed
* Line dtet.c:485
* Line dtet.c:486: init of variable pointsPerLine
	CLRA
	LDB	#$64		decimal 100 signed
	STD	-13,U		offset in variable pointsPerLine
	LDD	#$012C		decimal 300 signed
	STD	-11,U		offset in variable pointsPerLine
	LDD	#$01F4		decimal 500 signed
	STD	-9,U		offset in variable pointsPerLine
	LDD	#$0320		decimal 800 signed
	STD	-7,U		offset in variable pointsPerLine
* Line dtet.c:487: assignment: =
	LDB	-4,U		variable numLines
	ADDB	#$FF		255
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	-13,U		address of array pointsPerLine
* optimizeLoadDX
	LDD	D,X		get r-value
	PSHS	B,A
	LDB	5,U		variable i
	LEAX	_level+0,PCR	address of array level
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	CLRA			promotion of binary operand
	PULS	X
	LBSR	MUL16
	STD	_lastPoints+0,PCR
* Line dtet.c:490: assignment: +=
* optim: storeLoad
	PSHS	B,A
	LDB	-1,U		variable j
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_scores+0,PCR	address of array scores
	LEAX	D,X		add offset
	LDD	,X
	ADDD	,S++
	STD	,X
* Line dtet.c:491: assignment: +=
	LDB	-4,U		variable `numLines', declared at dtet.c:463
	CLRA
	PSHS	B,A
	LDB	5,U		variable i
* optim: stripExtraClrA_B
	LSLB
	ROLA
	LEAX	_lines+0,PCR	address of array lines
	LEAX	D,X		add offset
	LDD	,X
	ADDD	,S++
	STD	,X
* Line dtet.c:492: assignment: =
	LDB	-4,U		variable `numLines', declared at dtet.c:463
	STB	_lastLines+0,PCR
* Line dtet.c:493: assignment: =
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B
	LDB	5,U		variable i
* optim: stripExtraClrA_B
	LSLB
	ROLA
	LEAX	_lines+0,PCR	address of array lines
* optimizeLoadDX
	LDD	D,X		get r-value
	TFR	D,X		optim: stripExtraPulsX
	CLRA
	LDB	#$0A		decimal 10 signed
* optim: stripExtraPulsX
	LBSR	SDIV16
	TFR	X,D		quotient
* Cast from `int' to byte: result already in B
	ADDB	,S+
	PSHS	B
	LDB	5,U		variable i
	LEAX	_level+0,PCR	address of array level
	ABX			add unsigned 8-bit offset
	LDB	,S+
	STB	,X
* Line dtet.c:496: if
	LDB	5,U		variable i
	LEAX	_level+0,PCR	address of array level
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	PSHS	B
	LDB	5,U		variable i
	LEAX	_previousLevel+0,PCR	address of array previousLevel
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	CMPB	,S+		compare with LSB
	LBHS	L00464		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00463 removed
* Line dtet.c:496
* Line dtet.c:497: assignment: =
	LDB	5,U		variable i
	LEAX	_level+0,PCR	address of array level
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	PSHS	B
	LDB	5,U		variable i
	LEAX	_previousLevel+0,PCR	address of array previousLevel
	ABX			add unsigned 8-bit offset
	LDB	,S+
	STB	,X
* Line dtet.c:499: if
	LDB	_emptyBackground+0,PCR	variable `emptyBackground', declared at dtet.c:99
* optim: loadCmpZeroBeqOrBne
	BNE	L00466
* optim: branchToNextLocation
* Useless label L00467 removed
	CLRA
* optim: stripConsecutiveLoadsToSameReg
* PSHS B,A optim: optimizeStackOperations1
	LDB	5,U		variable i
	LEAX	_level+0,PCR	address of array level
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
* optim: stripExtraClrA_B
	CMPD	#9		optim: optimizeStackOperations1
	BHS	L00466		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00465 removed
* Line dtet.c:500
* Line dtet.c:500: assignment: =
	CLRA
* LDB #$01 optim: optimizeStackOperations1
* PSHS B optim: optimizeStackOperations1
	LDB	5,U		variable i
	LEAX	_level+0,PCR	address of array level
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	SUBB	#1		optim: optimizeStackOperations1
	LEAX	_backgroundCharList+0,PCR	address of array backgroundCharList
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	PSHS	B
	LDB	5,U		variable i
	LEAX	_backgroundChar+0,PCR	address of array backgroundChar
	ABX			add unsigned 8-bit offset
	LDB	,S+
	STB	,X
L00466	EQU	*		else clause of if() started at dtet.c:499
* Useless label L00468 removed
* Line dtet.c:502: if
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:100
* optim: loadCmpZeroBeqOrBne
	BNE	L00470
* optim: branchToNextLocation
* Useless label L00469 removed
* Line dtet.c:502
* Line dtet.c:503: function call: sound()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 2 of sound(): int
* optim: stripExtraClrA_B
	LDB	#$E6		decimal 230 signed
	PSHS	B,A		C function argument 1 of sound(): int
	LBSR	_sound
	LEAS	4,S
* Line dtet.c:504: function call: sound()
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A		C function argument 2 of sound(): int
* optim: stripExtraClrA_B
	LDB	#$DC		decimal 220 signed
	PSHS	B,A		C function argument 1 of sound(): int
	LBSR	_sound
	LEAS	4,S
L00470	EQU	*		else clause of if() started at dtet.c:502
* Useless label L00471 removed
L00464	EQU	*		else clause of if() started at dtet.c:496
* Useless label L00472 removed
L00462	EQU	*		else clause of if() started at dtet.c:485
* Useless label L00473 removed
* Line dtet.c:509: if
	LDB	_numPlayers+0,PCR	variable `numPlayers', declared at dtet.c:82
* optim: loadCmpZeroBeqOrBne
	BNE	L00475		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00476 removed
	CLRA
* optim: stripConsecutiveLoadsToSameReg
* PSHS B,A optim: optimizeStackOperations1
	LDB	_linesPiecesPlayed+0,PCR	index 0 in array linesPiecesPlayed[]
* optim: stripExtraClrA_B
	CMPD	#12		optim: optimizeStackOperations1
	BLO	L00475		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00474 removed
* Line dtet.c:509
* Line dtet.c:510: if
	CLRA
* optim: stripConsecutiveLoadsToSameReg
* PSHS B,A optim: optimizeStackOperations1
	LDB	_level+0,PCR	index 0 in array level[]
* optim: stripExtraClrA_B
	CMPD	#5		optim: optimizeStackOperations1
	BLS	L00478		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00477 removed
* Line dtet.c:510
* Line dtet.c:510: function call: setTrapBlock()
	CLRA
	CLRB
	PSHS	B,A		C function argument 1 of setTrapBlock(): int
	LBSR	_setTrapBlock
	LEAS	2,S
	BRA	L00479		jump over else clause
L00478	EQU	*		else clause of if() started at dtet.c:510
* Line dtet.c:512
* Line dtet.c:511: if
	CLRA
* optim: stripConsecutiveLoadsToSameReg
* PSHS B,A optim: optimizeStackOperations1
	LDB	_level+0,PCR	index 0 in array level[]
* optim: stripExtraClrA_B
	CMPD	#3		optim: optimizeStackOperations1
	BLS	L00481		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00480 removed
* Line dtet.c:511
* Line dtet.c:511: function call: setTrapLine()
	CLRA
	CLRB
	PSHS	B,A		C function argument 1 of setTrapLine(): int
	LBSR	_setTrapLine
	LEAS	2,S
L00481	EQU	*		else clause of if() started at dtet.c:511
* Useless label L00482 removed
L00479	EQU	*		end of if() started at dtet.c:510
* Line dtet.c:512: assignment: =
	CLRA
* CLRB  optim: optimizeStackOperations1
* PSHS B optim: optimizeStackOperations1
* optim: optimizeLeax
	LDB	#0		optim: optimizeStackOperations1
	STB	_linesPiecesPlayed+0,PCR	optim: optimizeLeax
	LBRA	L00483		jump over else clause
L00475	EQU	*		else clause of if() started at dtet.c:509
* Line dtet.c:520
* Line dtet.c:515: if
	LDB	_numPlayers+0,PCR	variable numPlayers
* optim: removeCMPZeroAfterLDIfBHI (BHI->BNE)
	LBEQ	L00485		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00486 removed
	CLRA
* optim: stripConsecutiveLoadsToSameReg
* PSHS B,A optim: optimizeStackOperations1
	LDB	5,U		variable i
	LEAX	_linesPiecesPlayed+0,PCR	address of array linesPiecesPlayed
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
* optim: stripExtraClrA_B
	CMPD	#3		optim: optimizeStackOperations1
	BLO	L00485		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00484 removed
* Line dtet.c:515
* Line dtet.c:516: if
	CLRA
* optim: stripConsecutiveLoadsToSameReg
* PSHS B,A optim: optimizeStackOperations1
	LDB	5,U		variable i
	LEAX	_level+0,PCR	address of array level
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
* optim: stripExtraClrA_B
	CMPD	#5		optim: optimizeStackOperations1
	BLS	L00488		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00487 removed
* Line dtet.c:516
* Line dtet.c:516: function call: setTrapBlock()
	LDB	5,U		variable `i', declared at dtet.c:461
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 1 of setTrapBlock(): unsigned char
	LBSR	_setTrapBlock
	LEAS	2,S
	BRA	L00489		jump over else clause
L00488	EQU	*		else clause of if() started at dtet.c:516
* Line dtet.c:518
* Line dtet.c:517: if
	CLRA
* optim: stripConsecutiveLoadsToSameReg
* PSHS B,A optim: optimizeStackOperations1
	LDB	5,U		variable i
	LEAX	_level+0,PCR	address of array level
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
* optim: stripExtraClrA_B
	CMPD	#3		optim: optimizeStackOperations1
	BLS	L00491		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00490 removed
* Line dtet.c:517
* Line dtet.c:517: function call: setTrapLine()
	LDB	5,U		variable `i', declared at dtet.c:461
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 1 of setTrapLine(): unsigned char
	LBSR	_setTrapLine
	LEAS	2,S
L00491	EQU	*		else clause of if() started at dtet.c:517
* Useless label L00492 removed
L00489	EQU	*		end of if() started at dtet.c:516
* Line dtet.c:518: assignment: =
	CLRA
* CLRB  optim: optimizeStackOperations1
* PSHS B optim: optimizeStackOperations1
	LDB	5,U		variable i
	LEAX	_linesPiecesPlayed+0,PCR	address of array linesPiecesPlayed
	ABX			add unsigned 8-bit offset
	LDB	#0		optim: optimizeStackOperations1
	STB	,X
L00485	EQU	*		else clause of if() started at dtet.c:515
* Useless label L00493 removed
L00483	EQU	*		end of if() started at dtet.c:509
* Useless label L00141 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION checkForFullRows(): defined at dtet.c:461
funcend_checkForFullRows	EQU *
funcsize_checkForFullRows	EQU	funcend_checkForFullRows-_checkForFullRows
_settleActiveShapeInPit	EXPORT


*******************************************************************************

* FUNCTION settleActiveShapeInPit(): defined at dtet.c:523
_settleActiveShapeInPit	EQU	*
* Prototype: void settleActiveShapeInPit(unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-9,S
* Formal parameter(s):
*      5,U:    1 byte : i: unsigned char: line 523
* Local non-static variable(s):
*     -9,U:    2 bytes: x: int: line 524
*     -7,U:    2 bytes: y: int: line 524
*     -5,U:    2 bytes: blockX: int: line 524
*     -3,U:    2 bytes: blockY: int: line 524
*     -1,U:    1 byte : blockColour: char: line 525
* Line dtet.c:526: for init
* Line dtet.c:526: assignment: =
	CLRA
	CLRB
	STD	-3,U
	LBRA	L00495		jump to for condition
L00494	EQU	*
* Line dtet.c:526: for body
* Line dtet.c:527: for init
* Line dtet.c:527: assignment: =
	CLRA
	CLRB
	STD	-5,U
	LBRA	L00499		jump to for condition
L00498	EQU	*
* Line dtet.c:527: for body
* Line dtet.c:528: assignment: =
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDB	5,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_shapeX+0,PCR	address of array shapeX
* optimizeLoadDX
	LDD	D,X		get r-value
	ADDD	-5,U		optim: optimizeStackOperations4
	STD	-9,U
* Line dtet.c:529: assignment: =
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDB	5,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_shapeY+0,PCR	address of array shapeY
* optimizeLoadDX
	LDD	D,X		get r-value
	ADDD	-3,U		optim: optimizeStackOperations4
	STD	-7,U
* Line dtet.c:530: assignment: =
	LDD	-5,U		variable `blockX', declared at dtet.c:524
	PSHS	B,A
	LDX	-3,U		left
* optim: removeClrAFromArrayIndexMul
	LDB	#$04		right
	LBSR	MUL168
	ADDD	,S++
	PSHS	B,A		preserve array index
	LDB	5,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LEAX	_shapeMap+0,PCR	address of array shapeMap
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,X		get r-value
	STB	-1,U
* Line dtet.c:532: if
* optim: storeLoad
	CMPB	#$30
	BEQ	L00503		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00507 removed
	LDD	-9,U		variable x
	ADDD	#0
	BLT	L00503		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00506 removed
	LDD	-9,U		variable x
	CMPD	#$0A
	BGE	L00503		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00505 removed
	LDD	-7,U		variable y
	ADDD	#0
	BLT	L00503		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00504 removed
	LDD	-7,U		variable y
	CMPD	#$10
	BGE	L00503		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00502 removed
* Line dtet.c:534
* Line dtet.c:534: assignment: =
	LDB	-1,U		variable `blockColour', declared at dtet.c:525
	PSHS	B
	LDD	-9,U		variable `x', declared at dtet.c:524
	PSHS	B,A
	LDD	-7,U		variable `y', declared at dtet.c:524
	LBSR	MUL16BY10
	ADDD	,S++
	PSHS	B,A		preserve array index
	LDB	5,U		variable i
* optim: stripOpToDeadReg
	LDA	#160		size of array element
	MUL			get offset in bytes in D
	LEAX	_pit+0,PCR	address of array pit
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,S+
	STB	,X
L00503	EQU	*		else clause of if() started at dtet.c:532
* Useless label L00508 removed
* Useless label L00500 removed
* Line dtet.c:527: for increment(s)
	LDD	-5,U
	ADDD	#1
	STD	-5,U
L00499	EQU	*
* Line dtet.c:527: for condition
	LDD	-5,U		variable blockX
	CMPD	#$03
	LBLE	L00498
* optim: branchToNextLocation
* Useless label L00501 removed
* Useless label L00496 removed
* Line dtet.c:526: for increment(s)
	LDD	-3,U
	ADDD	#1
	STD	-3,U
L00495	EQU	*
* Line dtet.c:526: for condition
	LDD	-3,U		variable blockY
	CMPD	#$03
	LBLE	L00494
* optim: branchToNextLocation
* Useless label L00497 removed
* Line dtet.c:537: if
	LDB	_numPlayers+0,PCR	variable `numPlayers', declared at dtet.c:82
* optim: loadCmpZeroBeqOrBne
	BNE	L00510		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00511 removed
	CLRA
* optim: stripConsecutiveLoadsToSameReg
* PSHS B,A optim: optimizeStackOperations1
	LDB	_level+0,PCR	index 0 in array level[]
* optim: stripExtraClrA_B
	CMPD	#3		optim: optimizeStackOperations1
	BLS	L00510		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00509 removed
* Line dtet.c:538
* Line dtet.c:538: post-increment
* optim: optimizeLeax
	INC	_linesPiecesPlayed+0,PCR	optim: optimizeLeax
L00510	EQU	*		else clause of if() started at dtet.c:537
* Useless label L00512 removed
* Useless label L00142 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION settleActiveShapeInPit(): defined at dtet.c:523
funcend_settleActiveShapeInPit	EQU *
funcsize_settleActiveShapeInPit	EQU	funcend_settleActiveShapeInPit-_settleActiveShapeInPit
_dropShape	EXPORT


*******************************************************************************

* FUNCTION dropShape(): defined at dtet.c:542
_dropShape	EQU	*
* Prototype: void dropShape(unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
* Formal parameter(s):
*      5,U:    1 byte : i: unsigned char: line 542
* Line dtet.c:544: if
* Line dtet.c:544: function call: shapeCanMove()
	LDB	5,U		variable `i', declared at dtet.c:542
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 4 of shapeCanMove(): unsigned char
	LDB	#$01		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 3 of shapeCanMove(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 2 of shapeCanMove(): int
	LDB	5,U		variable i
* optim: removeClr
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LEAX	_shapeMap+0,PCR	address of array shapeMap
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	PSHS	B,A		C function argument 1 of shapeCanMove(): char[]
	LBSR	_shapeCanMove
	LEAS	8,S
	TSTB
	LBEQ	L00514		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00513 removed
* Line dtet.c:544
* Line dtet.c:545: function call: drawShape()
	LDB	5,U		variable `i', declared at dtet.c:542
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawShape(): unsigned char
	LDB	#$01		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of drawShape(): int
	LBSR	_drawShape
	LEAS	4,S
* Line dtet.c:546: assignment: +=
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A
	LDB	5,U		variable i
* optim: stripExtraClrA_B
	LSLB
	ROLA
	LEAX	_shapeY+0,PCR	address of array shapeY
	LEAX	D,X		add offset
	LDD	,X
	ADDD	,S++
	STD	,X
* Line dtet.c:547: function call: drawShape()
	LDB	5,U		variable `i', declared at dtet.c:542
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawShape(): unsigned char
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of drawShape(): int
	LBSR	_drawShape
	LEAS	4,S
* Line dtet.c:549: if
	LDB	5,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_dropRate+0,PCR	address of array dropRate
* optimizeLoadDX
	LDD	D,X		get r-value
* optim: loadCmpZeroBeqOrBne
	LBNE	L00518		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00515 removed
* Line dtet.c:549
* Line dtet.c:550: post-increment
	LDB	5,U		variable i
	ADDB	#$06		6
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_scores+0,PCR	address of array scores
	LEAX	D,X		add offset
	LDD	,X
	ADDD	#1
	STD	,X
* Line dtet.c:551: post-increment
	LDX	_lastPoints+0,PCR	variable `lastPoints', declared at dtet.c:551
	LEAX	1,X
	STX	_lastPoints+0,PCR
* Useless label L00516 removed
* Useless label L00517 removed
	LBRA	L00518		jump over else clause
L00514	EQU	*		else clause of if() started at dtet.c:544
* Line dtet.c:553
* Line dtet.c:554: function call: settleActiveShapeInPit()
	LDB	5,U		variable `i', declared at dtet.c:542
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 1 of settleActiveShapeInPit(): unsigned char
	LBSR	_settleActiveShapeInPit
	LEAS	2,S
* Line dtet.c:555: if
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:100
* optim: loadCmpZeroBeqOrBne
	BNE	L00520
* optim: branchToNextLocation
* Useless label L00519 removed
* Line dtet.c:555
* Line dtet.c:555: function call: sound()
	CLRA
	CLRB
	PSHS	B,A		C function argument 2 of sound(): int
	LDB	#$F5		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of sound(): int
	LBSR	_sound
	LEAS	4,S
L00520	EQU	*		else clause of if() started at dtet.c:555
* Useless label L00521 removed
* Line dtet.c:557: if
	LDB	5,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_shapeY+0,PCR	address of array shapeY
* optimizeLoadDX
	LDD	D,X		get r-value
	CMPD	#0
	BGE	L00523		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00522 removed
* Line dtet.c:557
* Line dtet.c:558: assignment: =
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B
	LDB	5,U		variable i
	LEAX	_gameOver+0,PCR	address of array gameOver
	ABX			add unsigned 8-bit offset
	LDB	,S+
	STB	,X
* Line dtet.c:559: function call: locate()
* optim: stripExtraClrA_B
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of locate(): int
	LDB	5,U		variable i
	LEAX	_pitLeft+0,PCR	address of array pitLeft
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of locate(): const unsigned char
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:559: function call: printf()
	LEAX	S00181,PCR	"GAME OVER!"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:560: function call: playTune()
	CLRA
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 3 of playTune(): int
	LEAX	_tune3Durations+0,PCR	address of array tune3Durations
	PSHS	X		C function argument 2 of playTune(): const unsigned char[]
	LEAX	_tune3Notes+0,PCR	address of array tune3Notes
	PSHS	X		C function argument 1 of playTune(): const unsigned char[]
	LBSR	_playTune
	LEAS	6,S
	BRA	L00524		jump over else clause
L00523	EQU	*		else clause of if() started at dtet.c:557
* Line dtet.c:562
* Line dtet.c:563: function call: checkForFullRows()
	LDB	5,U		variable `i', declared at dtet.c:542
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 1 of checkForFullRows(): unsigned char
	LBSR	_checkForFullRows
	LEAS	2,S
* Line dtet.c:564: function call: drawPit()
	LDB	5,U		variable `i', declared at dtet.c:542
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 1 of drawPit(): unsigned char
	LBSR	_drawPit
	LEAS	2,S
* Line dtet.c:565: function call: createShape()
	LDB	5,U		variable `i', declared at dtet.c:542
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 1 of createShape(): unsigned char
	LBSR	_createShape
	LEAS	2,S
* Line dtet.c:566: function call: drawShape()
	LDB	5,U		variable `i', declared at dtet.c:542
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawShape(): unsigned char
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of drawShape(): int
	LBSR	_drawShape
	LEAS	4,S
L00524	EQU	*		end of if() started at dtet.c:557
* Line dtet.c:569: function call: displayStatus()
	LBSR	_displayStatus
L00518	EQU	*		end of if() started at dtet.c:544
* Useless label L00143 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION dropShape(): defined at dtet.c:542
funcend_dropShape	EQU *
funcsize_dropShape	EQU	funcend_dropShape-_dropShape
_roundWindow	EXPORT


*******************************************************************************

* FUNCTION roundWindow(): defined at dtet.c:576
_roundWindow	EQU	*
* Prototype: void roundWindow(int, int, int, int, unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
* Formal parameter(s):
*      4,U:    2 bytes: ulx: int: line 576
*      6,U:    2 bytes: uly: int: line 576
*      8,U:    2 bytes: brx: int: line 576
*     10,U:    2 bytes: bry: int: line 576
*     13,U:    1 byte : offset: unsigned char: line 576
* Line dtet.c:577: function call: printBlock()
	LDB	13,U		variable offset
	ADDB	#$81		129
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 3 of printBlock(): unsigned char
	LDD	6,U		variable `uly', declared at dtet.c:576
	PSHS	B,A		C function argument 2 of printBlock(): int
	LDD	4,U		variable `ulx', declared at dtet.c:576
	PSHS	B,A		C function argument 1 of printBlock(): int
	LBSR	_printBlock
	LEAS	6,S
* Line dtet.c:578: function call: printBlock()
	LDB	13,U		variable offset
	ADDB	#$82		130
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 3 of printBlock(): unsigned char
	LDD	6,U		variable `uly', declared at dtet.c:576
	PSHS	B,A		C function argument 2 of printBlock(): int
	LDD	8,U		variable `brx', declared at dtet.c:576
	PSHS	B,A		C function argument 1 of printBlock(): int
	LBSR	_printBlock
	LEAS	6,S
* Line dtet.c:579: function call: printBlock()
	LDB	13,U		variable offset
	ADDB	#$84		132
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 3 of printBlock(): unsigned char
	LDD	10,U		variable `bry', declared at dtet.c:576
	PSHS	B,A		C function argument 2 of printBlock(): int
	LDD	4,U		variable `ulx', declared at dtet.c:576
	PSHS	B,A		C function argument 1 of printBlock(): int
	LBSR	_printBlock
	LEAS	6,S
* Line dtet.c:580: function call: printBlock()
	LDB	13,U		variable offset
	ADDB	#$88		136
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 3 of printBlock(): unsigned char
	LDD	10,U		variable `bry', declared at dtet.c:576
	PSHS	B,A		C function argument 2 of printBlock(): int
	LDD	8,U		variable `brx', declared at dtet.c:576
	PSHS	B,A		C function argument 1 of printBlock(): int
	LBSR	_printBlock
	LEAS	6,S
* Useless label L00144 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION roundWindow(): defined at dtet.c:576
funcend_roundWindow	EQU *
funcsize_roundWindow	EQU	funcend_roundWindow-_roundWindow
_drawHighScores	EXPORT


*******************************************************************************

* FUNCTION drawHighScores(): defined at dtet.c:584
_drawHighScores	EQU	*
* Prototype: void drawHighScores(...)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-1,S
* Local non-static variable(s):
*     -1,U:    1 byte : pos: unsigned char: line 589
* Line dtet.c:585: function call: cls()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of cls(): int
	LBSR	_cls
	LEAS	2,S
* Line dtet.c:586: function call: roundWindow()
	CLRA
	LDB	#$50		decimal 80 signed
	PSHS	B,A		C function argument 5 of roundWindow(): int
* optim: stripExtraClrA_B
	LDB	#$0F		decimal 15 signed
	PSHS	B,A		C function argument 4 of roundWindow(): int
* optim: stripExtraClrA_B
	LDB	#$1F		decimal 31 signed
	PSHS	B,A		C function argument 3 of roundWindow(): int
* optim: removeClr
	CLRB
	PSHS	B,A		C function argument 2 of roundWindow(): int
* optim: removeClr
* optim: removeClr
	PSHS	B,A		C function argument 1 of roundWindow(): int
	LBSR	_roundWindow
	LEAS	10,S
* Line dtet.c:587: function call: drawHeader()
	LDB	_colourShift+0,PCR
	INC	_colourShift+0,PCR
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawHeader(): unsigned char
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of drawHeader(): int
	LBSR	_drawHeader
	LEAS	4,S
* Line dtet.c:589: for init
* Line dtet.c:589: init of variable pos
	CLR	-1,U		variable pos
	LBRA	L00526		jump to for condition
L00525	EQU	*
* Line dtet.c:589: for body
* Line dtet.c:590: function call: locate()
	LDB	-1,U		variable pos
	ADDB	#$07		7
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of locate(): unsigned char
	LDB	#$08		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:590: function call: printf()
	LEAX	S00182,PCR	"............."
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:591: function call: locate()
	LDB	-1,U		variable pos
	ADDB	#$07		7
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of locate(): unsigned char
	LDB	#$07		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:591: function call: printf()
	LDB	-1,U		variable pos
* optim: stripOpToDeadReg
	LDA	#11		size of array element
	MUL			get offset in bytes in D
	LEAX	_names+0,PCR	address of array names
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	PSHS	B,A		C function argument 2 of printf(): char[]
	LEAX	S00183,PCR	"%s"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	4,S
* Line dtet.c:592: function call: locate()
	LDB	-1,U		variable pos
	ADDB	#$07		7
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of locate(): unsigned char
	LDB	#$14		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:592: function call: printf()
	LDB	-1,U		variable pos
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_scores+0,PCR	address of array scores
* optimizeLoadDX
	LDD	D,X		get r-value
	PSHS	B,A		C function argument 2 of printf(): unsigned int
	LEAX	S00184,PCR	"%5u"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	4,S
* Useless label L00527 removed
* Line dtet.c:589: for increment(s)
	INC	-1,U
L00526	EQU	*
* Line dtet.c:589: for condition
	LDB	-1,U		variable pos
	CMPB	#$06
	LBLO	L00525
* optim: branchToNextLocation
* Useless label L00528 removed
* Line dtet.c:594: function call: locate()
	CLRA
	LDB	#$0E		decimal 14 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$03		decimal 3 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:594: function call: printf()
	LEAX	S00185,PCR	"PRESS ANY KEY TO CONTINUE!"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:595: function call: playTune()
	CLRA
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 3 of playTune(): int
	LEAX	_tune1Durations+0,PCR	address of array tune1Durations
	PSHS	X		C function argument 2 of playTune(): const unsigned char[]
	LEAX	_tune1Notes+0,PCR	address of array tune1Notes
	PSHS	X		C function argument 1 of playTune(): const unsigned char[]
	LBSR	_playTune
	LEAS	6,S
* Line dtet.c:596: while
* optim: branchToNextLocation
L00529	EQU	*		while body
* Line dtet.c:597: if
* Line dtet.c:597: function call: inkey()
	LBSR	_inkey
	TSTB
	BNE	L00531		 (optim: condBranchOverUncondBranch) (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00532 removed
* Line dtet.c:597
* optim: condBranchOverUncondBranch
* Useless label L00533 removed
* Useless label L00534 removed
* Line dtet.c:598: function call: drawHeader()
	LDB	_colourShift+0,PCR
	INC	_colourShift+0,PCR
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawHeader(): unsigned char
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of drawHeader(): int
	LBSR	_drawHeader
	LEAS	4,S
* Line dtet.c:599: function call: delay()
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A		C function argument 1 of delay(): int
	LBSR	_delay
	LEAS	2,S
* Useless label L00530 removed
	BRA	L00529		go to start of while body
L00531	EQU	*		after end of while starting at dtet.c:596
* Useless label L00145 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION drawHighScores(): defined at dtet.c:584
funcend_drawHighScores	EQU *
funcsize_drawHighScores	EQU	funcend_drawHighScores-_drawHighScores
_drawHelp	EXPORT


*******************************************************************************

* FUNCTION drawHelp(): defined at dtet.c:604
_drawHelp	EQU	*
* Prototype: void drawHelp(...)
* Calling convention: 0 (CMOC Default)
* Line dtet.c:605: function call: cls()
	CLRA
	CLRB
	PSHS	B,A		C function argument 1 of cls(): int
	LBSR	_cls
	LEAS	2,S
* Line dtet.c:606: function call: printf()
	LEAX	S00186,PCR	"  =DRAGON 1=  "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:607: function call: locate()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:607: function call: printf()
	LEAX	S00187,PCR	"              "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:608: function call: locate()
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:608: function call: printf()
	LEAX	S00188,PCR	" w ROTATE     "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:609: function call: locate()
	CLRA
	LDB	#$03		decimal 3 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:609: function call: printf()
	LEAX	S00189,PCR	" s DROP       "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:610: function call: locate()
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:610: function call: printf()
	LEAX	S00190,PCR	" a MOVE LEFT  "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:611: function call: locate()
	CLRA
	LDB	#$05		decimal 5 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:611: function call: printf()
	LEAX	S00191,PCR	" d MOVE RIGHT "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:612: function call: locate()
	CLRA
	LDB	#$06		decimal 6 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:612: function call: printf()
	LEAX	S00187,PCR	"              "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:613: function call: locate()
	CLRA
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:613: function call: printf()
	LEAX	S00192,PCR	" + CURSORS    "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:614: function call: locate()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:614: function call: printf()
	LEAX	S00193,PCR	" + JOYSTICK1  "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:615: function call: locate()
	CLRA
	LDB	#$09		decimal 9 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:615: function call: printf()
	LEAX	S00187,PCR	"              "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:617: function call: locate()
	CLRA
	CLRB
	PSHS	B,A		C function argument 2 of locate(): int
	LDB	#$12		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:617: function call: printf()
	LEAX	S00194,PCR	"  =DRAGON 2=  "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:618: function call: locate()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$12		decimal 18 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:618: function call: printf()
	LEAX	S00187,PCR	"              "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:619: function call: locate()
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$12		decimal 18 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:619: function call: printf()
	LEAX	S00195,PCR	" i ROTATE     "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:620: function call: locate()
	CLRA
	LDB	#$03		decimal 3 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$12		decimal 18 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:620: function call: printf()
	LEAX	S00196,PCR	" k DROP       "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:621: function call: locate()
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$12		decimal 18 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:621: function call: printf()
	LEAX	S00197,PCR	" j MOVE LEFT  "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:622: function call: locate()
	CLRA
	LDB	#$05		decimal 5 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$12		decimal 18 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:622: function call: printf()
	LEAX	S00198,PCR	" l MOVE RIGHT "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:623: function call: locate()
	CLRA
	LDB	#$06		decimal 6 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$12		decimal 18 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:623: function call: printf()
	LEAX	S00187,PCR	"              "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:624: function call: locate()
	CLRA
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$12		decimal 18 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:624: function call: printf()
	LEAX	S00199,PCR	" + JOYSTICK2  "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:625: function call: locate()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$12		decimal 18 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:625: function call: printf()
	LEAX	S00187,PCR	"              "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:627: function call: locate()
	CLRA
	LDB	#$0B		decimal 11 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:627: function call: printf()
	LEAX	S00200,PCR	" X = CANCEL/RETURN TO MAIN MENU "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:628: function call: locate()
	CLRA
	LDB	#$0C		decimal 12 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:628: function call: printf()
	LEAX	S00201,PCR	" H = PAUSE THE GAME             "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:629: function call: locate()
	CLRA
	LDB	#$0E		decimal 14 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:629: function call: printf()
	LEAX	S00202,PCR	"   PRESS ANY KEY TO CONTINUE!   "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:631: function call: roundWindow()
	CLRA
	LDB	#$70		decimal 112 signed
	PSHS	B,A		C function argument 5 of roundWindow(): int
* optim: stripExtraClrA_B
	LDB	#$09		decimal 9 signed
	PSHS	B,A		C function argument 4 of roundWindow(): int
* optim: stripExtraClrA_B
	LDB	#$0D		decimal 13 signed
	PSHS	B,A		C function argument 3 of roundWindow(): int
* optim: removeClr
	CLRB
	PSHS	B,A		C function argument 2 of roundWindow(): int
* optim: removeClr
* optim: removeClr
	PSHS	B,A		C function argument 1 of roundWindow(): int
	LBSR	_roundWindow
	LEAS	10,S
* Line dtet.c:632: function call: roundWindow()
	CLRA
	LDB	#$70		decimal 112 signed
	PSHS	B,A		C function argument 5 of roundWindow(): int
* optim: stripExtraClrA_B
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 4 of roundWindow(): int
* optim: stripExtraClrA_B
	LDB	#$1F		decimal 31 signed
	PSHS	B,A		C function argument 3 of roundWindow(): int
* optim: removeClr
	CLRB
	PSHS	B,A		C function argument 2 of roundWindow(): int
	LDB	#$12		optim: removeAndOrMulAddSub
	PSHS	B,A		C function argument 1 of roundWindow(): int
	LBSR	_roundWindow
	LEAS	10,S
* Line dtet.c:633: function call: screen()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 2 of screen(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of screen(): int
	LBSR	_screen
	LEAS	4,S
* Line dtet.c:634: function call: waitkey()
	CLRA
	CLRB
	PSHS	B,A		C function argument 1 of waitkey(): int
	LBSR	_waitkey
	LEAS	2,S
* Line dtet.c:636: function call: cls()
	CLRA
	CLRB
	PSHS	B,A		C function argument 1 of cls(): int
	LBSR	_cls
	LEAS	2,S
* Line dtet.c:637: function call: locate()
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:637: function call: printf()
	LEAX	S00203,PCR	"                             "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:638: function call: locate()
	CLRA
	LDB	#$03		decimal 3 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:638: function call: printf()
	LEAX	S00204,PCR	"        = s c o r e =        "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:639: function call: locate()
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:639: function call: printf()
	LEAX	S00203,PCR	"                             "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:640: function call: locate()
	CLRA
	LDB	#$05		decimal 5 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:640: function call: printf()
	LEAX	S00205,PCR	" 1 LINE:  100 * LEVEL NUMBER "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:641: function call: locate()
	CLRA
	LDB	#$06		decimal 6 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:641: function call: printf()
	LEAX	S00206,PCR	" 2 LINES: 300 * LEVEL NUMBER "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:642: function call: locate()
	CLRA
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:642: function call: printf()
	LEAX	S00207,PCR	" 3 LINES: 500 * LEVEL NUMBER "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:643: function call: locate()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:643: function call: printf()
	LEAX	S00208,PCR	" 4 LINES: 800 * LEVEL NUMBER "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:644: function call: locate()
	CLRA
	LDB	#$09		decimal 9 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:644: function call: printf()
	LEAX	S00203,PCR	"                             "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:645: function call: locate()
	CLRA
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:645: function call: printf()
	LEAX	S00209,PCR	"  SOFT DROP:  1 POINT * ROW  "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:647: function call: locate()
	CLRA
	LDB	#$0E		decimal 14 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:647: function call: printf()
	LEAX	S00202,PCR	"   PRESS ANY KEY TO CONTINUE!   "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:649: function call: roundWindow()
	CLRA
	LDB	#$70		decimal 112 signed
	PSHS	B,A		C function argument 5 of roundWindow(): int
* optim: stripExtraClrA_B
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 4 of roundWindow(): int
	LDB	#$1D		optim: removeAndOrMulAddSub
	PSHS	B,A		C function argument 3 of roundWindow(): int
	LDB	#$02		optim: removeAndOrMulAddSub
	PSHS	B,A		C function argument 2 of roundWindow(): int
	LDB	#$01		optim: removeAndOrMulAddSub
	PSHS	B,A		C function argument 1 of roundWindow(): int
	LBSR	_roundWindow
	LEAS	10,S
* Line dtet.c:650: function call: screen()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 2 of screen(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of screen(): int
	LBSR	_screen
	LEAS	4,S
* Line dtet.c:651: function call: waitkey()
	CLRA
	CLRB
	PSHS	B,A		C function argument 1 of waitkey(): int
	LBSR	_waitkey
	LEAS	2,S
* Useless label L00146 removed
	RTS
* END FUNCTION drawHelp(): defined at dtet.c:604
funcend_drawHelp	EQU *
funcsize_drawHelp	EQU	funcend_drawHelp-_drawHelp
_drawMenuPtr	EXPORT


*******************************************************************************

* FUNCTION drawMenuPtr(): defined at dtet.c:655
_drawMenuPtr	EQU	*
* Prototype: void drawMenuPtr(unsigned char, unsigned char, unsigned char, unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-1,S
* Formal parameter(s):
*      5,U:    1 byte : x: unsigned char: line 655
*      7,U:    1 byte : y: unsigned char: line 655
*      9,U:    1 byte : offset: unsigned char: line 655
*     11,U:    1 byte : delete: unsigned char: line 655
* Local non-static variable(s):
*     -1,U:    1 byte : pointer: unsigned char: line 656
* Line dtet.c:656: init of variable pointer
* Line dtet.c:656: conditional expression
	LDB	11,U		variable `delete', declared at dtet.c:655
* optim: loadCmpZeroBeqOrBne
	BEQ	L00536		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00535 removed
	CLRA
	LDB	#$8F		decimal 143 signed
	BRA	L00537		end of true expression of conditional
L00536	EQU	*
	CLRA
	LDB	#$3E		decimal 62 signed
L00537	EQU	*
	STB	-1,U		variable pointer
* Line dtet.c:657: function call: printBlock()
* optim: storeLoad
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 3 of printBlock(): unsigned char
	LDB	7,U		variable y
	ADDB	9,U		variable offset
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 2 of printBlock(): unsigned char
	LDB	5,U		variable `x', declared at dtet.c:655
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of printBlock(): unsigned char
	LBSR	_printBlock
	LEAS	6,S
* Useless label L00147 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION drawMenuPtr(): defined at dtet.c:655
funcend_drawMenuPtr	EQU *
funcsize_drawMenuPtr	EQU	funcend_drawMenuPtr-_drawMenuPtr
_drawOptionsMenu	EXPORT


*******************************************************************************

* FUNCTION drawOptionsMenu(): defined at dtet.c:661
_drawOptionsMenu	EQU	*
* Prototype: void drawOptionsMenu(...)
* Calling convention: 0 (CMOC Default)
* Line dtet.c:662: function call: cls()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of cls(): int
	LBSR	_cls
	LEAS	2,S
* Line dtet.c:663: function call: roundWindow()
	CLRA
	LDB	#$50		decimal 80 signed
	PSHS	B,A		C function argument 5 of roundWindow(): int
* optim: stripExtraClrA_B
	LDB	#$0F		decimal 15 signed
	PSHS	B,A		C function argument 4 of roundWindow(): int
* optim: stripExtraClrA_B
	LDB	#$1F		decimal 31 signed
	PSHS	B,A		C function argument 3 of roundWindow(): int
* optim: removeClr
	CLRB
	PSHS	B,A		C function argument 2 of roundWindow(): int
* optim: removeClr
* optim: removeClr
	PSHS	B,A		C function argument 1 of roundWindow(): int
	LBSR	_roundWindow
	LEAS	10,S
* Line dtet.c:664: function call: locate()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:664: function call: printf()
	LEAX	S00210,PCR	"EMPTY BACKGROUND:"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:665: function call: locate()
	CLRA
	LDB	#$09		decimal 9 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:665: function call: printf()
	LEAX	S00211,PCR	"MUTED:"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:666: function call: locate()
	CLRA
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:666: function call: printf()
	LEAX	S00212,PCR	"BACK"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:667: function call: locate()
	CLRA
	LDB	#$0E		decimal 14 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$02		decimal 2 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:667: function call: printf()
	LEAX	S00213,PCR	"SELECT OPTION (CURSOR/ENTER)"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:669: function call: locate()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$19		decimal 25 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:670: if
	LDB	_emptyBackground+0,PCR	variable `emptyBackground', declared at dtet.c:99
* optim: loadCmpZeroBeqOrBne
	BEQ	L00539		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00538 removed
* Line dtet.c:670
* Line dtet.c:670: function call: printf()
	LEAX	S00214,PCR	"on "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
	BRA	L00540		jump over else clause
L00539	EQU	*		else clause of if() started at dtet.c:670
* Line dtet.c:671
* Line dtet.c:671: function call: printf()
	LEAX	S00215,PCR	"off"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
L00540	EQU	*		end of if() started at dtet.c:670
* Line dtet.c:672: function call: locate()
	CLRA
	LDB	#$09		decimal 9 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$19		decimal 25 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:673: if
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:100
* optim: loadCmpZeroBeqOrBne
	BEQ	L00542		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00541 removed
* Line dtet.c:673
* Line dtet.c:673: function call: printf()
	LEAX	S00214,PCR	"on "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
	BRA	L00543		jump over else clause
L00542	EQU	*		else clause of if() started at dtet.c:673
* Line dtet.c:674
* Line dtet.c:674: function call: printf()
	LEAX	S00215,PCR	"off"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
L00543	EQU	*		end of if() started at dtet.c:673
* Useless label L00148 removed
	RTS
* END FUNCTION drawOptionsMenu(): defined at dtet.c:661
funcend_drawOptionsMenu	EQU *
funcsize_drawOptionsMenu	EQU	funcend_drawOptionsMenu-_drawOptionsMenu
_optionsMenu	EXPORT


*******************************************************************************

* FUNCTION optionsMenu(): defined at dtet.c:678
_optionsMenu	EQU	*
* Prototype: void optionsMenu(...)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-1,S
* Local non-static variable(s):
*     -1,U:    1 byte : optNumber: char: line 679
* Line dtet.c:679: init of variable optNumber
	CLR	-1,U		variable optNumber
* Line dtet.c:680: function call: drawOptionsMenu()
	LBSR	_drawOptionsMenu
* Line dtet.c:681: function call: drawMenuPtr()
	CLRA
	CLRB
	PSHS	B,A		C function argument 4 of drawMenuPtr(): int
	LDB	-1,U		variable `optNumber', declared at dtet.c:679
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 3 of drawMenuPtr(): char
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of drawMenuPtr(): int
* optim: stripExtraClrA_B
	LDB	#$05		decimal 5 signed
	PSHS	B,A		C function argument 1 of drawMenuPtr(): int
	LBSR	_drawMenuPtr
	LEAS	8,S
* Line dtet.c:713: do-while
L00544	EQU	*		do-while body
* Line dtet.c:683: function call: drawHeader()
	LDB	_colourShift+0,PCR
	INC	_colourShift+0,PCR
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawHeader(): unsigned char
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of drawHeader(): int
	LBSR	_drawHeader
	LEAS	4,S
* Line dtet.c:684: assignment: =
* Line dtet.c:684: function call: inkey()
	LBSR	_inkey
	STB	_key+0,PCR
* Line dtet.c:685: if
* optim: storeLoad
	CMPB	#$0A
	LBNE	L00548		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00547 removed
* Line dtet.c:685
* Line dtet.c:686: function call: drawMenuPtr()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 4 of drawMenuPtr(): int
	LDB	-1,U		variable `optNumber', declared at dtet.c:679
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 3 of drawMenuPtr(): char
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of drawMenuPtr(): int
* optim: stripExtraClrA_B
	LDB	#$05		decimal 5 signed
	PSHS	B,A		C function argument 1 of drawMenuPtr(): int
	LBSR	_drawMenuPtr
	LEAS	8,S
* Line dtet.c:687: if
	LDB	-1,U
	INC	-1,U
	CMPB	#2
	BNE	L00550		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00549 removed
* Line dtet.c:687
* Line dtet.c:687: assignment: =
	CLR	-1,U		variable optNumber
L00550	EQU	*		else clause of if() started at dtet.c:687
* Useless label L00551 removed
* Line dtet.c:688: function call: drawMenuPtr()
	CLRA
	CLRB
	PSHS	B,A		C function argument 4 of drawMenuPtr(): int
	LDB	-1,U		variable `optNumber', declared at dtet.c:679
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 3 of drawMenuPtr(): char
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of drawMenuPtr(): int
* optim: stripExtraClrA_B
	LDB	#$05		decimal 5 signed
	PSHS	B,A		C function argument 1 of drawMenuPtr(): int
	LBSR	_drawMenuPtr
	LEAS	8,S
* Line dtet.c:689: if
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:100
* optim: loadCmpZeroBeqOrBne
	LBNE	L00555
* optim: branchToNextLocation
* Useless label L00552 removed
* Line dtet.c:689
* Line dtet.c:689: function call: sound()
	CLRA
	CLRB
	PSHS	B,A		C function argument 2 of sound(): int
	LDB	#$C8		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of sound(): int
	LBSR	_sound
	LEAS	4,S
* Useless label L00553 removed
* Useless label L00554 removed
	LBRA	L00555		jump over else clause
L00548	EQU	*		else clause of if() started at dtet.c:685
* Line dtet.c:712
* Line dtet.c:691: if
	LDB	_key+0,PCR	variable key
	CMPB	#$5E
	LBNE	L00557		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00556 removed
* Line dtet.c:691
* Line dtet.c:692: function call: drawMenuPtr()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 4 of drawMenuPtr(): int
	LDB	-1,U		variable `optNumber', declared at dtet.c:679
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 3 of drawMenuPtr(): char
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of drawMenuPtr(): int
* optim: stripExtraClrA_B
	LDB	#$05		decimal 5 signed
	PSHS	B,A		C function argument 1 of drawMenuPtr(): int
	LBSR	_drawMenuPtr
	LEAS	8,S
* Line dtet.c:693: if
	LDB	-1,U
	DEC	-1,U
	TSTB
	BNE	L00559		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00558 removed
* Line dtet.c:693
* Line dtet.c:693: assignment: =
	LDB	#$02
	STB	-1,U		variable optNumber
L00559	EQU	*		else clause of if() started at dtet.c:693
* Useless label L00560 removed
* Line dtet.c:694: function call: drawMenuPtr()
	CLRA
	CLRB
	PSHS	B,A		C function argument 4 of drawMenuPtr(): int
	LDB	-1,U		variable `optNumber', declared at dtet.c:679
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 3 of drawMenuPtr(): char
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of drawMenuPtr(): int
* optim: stripExtraClrA_B
	LDB	#$05		decimal 5 signed
	PSHS	B,A		C function argument 1 of drawMenuPtr(): int
	LBSR	_drawMenuPtr
	LEAS	8,S
* Line dtet.c:695: if
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:100
* optim: loadCmpZeroBeqOrBne
	LBNE	L00564
* optim: branchToNextLocation
* Useless label L00561 removed
* Line dtet.c:695
* Line dtet.c:695: function call: sound()
	CLRA
	CLRB
	PSHS	B,A		C function argument 2 of sound(): int
	LDB	#$C8		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of sound(): int
	LBSR	_sound
	LEAS	4,S
* Useless label L00562 removed
* Useless label L00563 removed
	LBRA	L00564		jump over else clause
L00557	EQU	*		else clause of if() started at dtet.c:691
* Line dtet.c:712
* Line dtet.c:697: if
	LDB	_key+0,PCR	variable key
	CMPB	#$0D
	BEQ	L00565
* optim: branchToNextLocation
* Useless label L00567 removed
* optim: removeLoadInComparisonWithTwoValues
	CMPB	#$20
	LBNE	L00566		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
L00565	EQU	*		then clause of if() started at dtet.c:697
* Line dtet.c:697
* Line dtet.c:698: if
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:100
* optim: loadCmpZeroBeqOrBne
	BNE	L00569
* optim: branchToNextLocation
* Useless label L00568 removed
* Line dtet.c:698
* Line dtet.c:698: function call: sound()
	CLRA
	CLRB
	PSHS	B,A		C function argument 2 of sound(): int
	LDB	#$64		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of sound(): int
	LBSR	_sound
	LEAS	4,S
L00569	EQU	*		else clause of if() started at dtet.c:698
* Useless label L00570 removed
* Line dtet.c:699: switch
	LDB	-1,U		variable `optNumber', declared at dtet.c:679
* Switch at dtet.c:699 has 3 non-ignored case values.
* Switch at dtet.c:699 uses if-else sequence: IF_ELSE=21, JUMP_TABLE=26
* Switch case at dtet.c:700
* optim: loadCmpZeroBeqOrBne
	BEQ	L00572
* Switch case at dtet.c:703
	CMPB	#$01		case 1
	BEQ	L00573
* Switch case at dtet.c:706
	CMPB	#$02		case 2
	BEQ	L00149
	BRA	L00571		switch default
L00572	EQU	*		case 0
* Line dtet.c:701: assignment: =
	LDB	_emptyBackground+0,PCR	variable `emptyBackground', declared at dtet.c:99
* optim: optimizeLoadTest
	LBSR	tfrZtoB
	STB	_emptyBackground+0,PCR
	BRA	L00571		break
L00573	EQU	*		case 1
* Line dtet.c:704: assignment: =
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:100
* optim: optimizeLoadTest
	LBSR	tfrZtoB
	STB	_muted+0,PCR
	BRA	L00571		break
* Useless label L00574 removed
	BRA	L00149		return (dtet.c:707)
L00571	EQU	*		end of switch
* Line dtet.c:709: function call: drawOptionsMenu()
	LBSR	_drawOptionsMenu
* Line dtet.c:710: function call: drawMenuPtr()
	CLRA
	CLRB
	PSHS	B,A		C function argument 4 of drawMenuPtr(): int
	LDB	-1,U		variable `optNumber', declared at dtet.c:679
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 3 of drawMenuPtr(): char
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of drawMenuPtr(): int
* optim: stripExtraClrA_B
	LDB	#$05		decimal 5 signed
	PSHS	B,A		C function argument 1 of drawMenuPtr(): int
	LBSR	_drawMenuPtr
	LEAS	8,S
L00566	EQU	*		else clause of if() started at dtet.c:697
* Useless label L00575 removed
L00564	EQU	*		end of if() started at dtet.c:691
L00555	EQU	*		end of if() started at dtet.c:685
* Line dtet.c:712: function call: delay()
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A		C function argument 1 of delay(): int
	LBSR	_delay
	LEAS	2,S
* Useless label L00545 removed
	LBRA	L00544		go to start of do-while body
* Useless label L00546 removed
L00149	EQU	*		end of optionsMenu()
	LEAS	,U
	PULS	U,PC
* END FUNCTION optionsMenu(): defined at dtet.c:678
funcend_optionsMenu	EQU *
funcsize_optionsMenu	EQU	funcend_optionsMenu-_optionsMenu
_drawMenu	EXPORT


*******************************************************************************

* FUNCTION drawMenu(): defined at dtet.c:717
_drawMenu	EQU	*
* Prototype: void drawMenu(...)
* Calling convention: 0 (CMOC Default)
* Line dtet.c:718: function call: cls()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of cls(): int
	LBSR	_cls
	LEAS	2,S
* Line dtet.c:719: function call: roundWindow()
	CLRA
	LDB	#$50		decimal 80 signed
	PSHS	B,A		C function argument 5 of roundWindow(): int
* optim: stripExtraClrA_B
	LDB	#$0F		decimal 15 signed
	PSHS	B,A		C function argument 4 of roundWindow(): int
* optim: stripExtraClrA_B
	LDB	#$1F		decimal 31 signed
	PSHS	B,A		C function argument 3 of roundWindow(): int
* optim: removeClr
	CLRB
	PSHS	B,A		C function argument 2 of roundWindow(): int
* optim: removeClr
* optim: removeClr
	PSHS	B,A		C function argument 1 of roundWindow(): int
	LBSR	_roundWindow
	LEAS	10,S
* Line dtet.c:720: function call: locate()
	CLRA
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:720: function call: printf()
	LEAX	S00216,PCR	"1 DRAGON GAME"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:721: function call: locate()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:721: function call: printf()
	LEAX	S00217,PCR	"2 DRAGONS GAME"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:722: function call: locate()
	CLRA
	LDB	#$09		decimal 9 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:722: function call: printf()
	LEAX	S00218,PCR	"HIGH SCORES"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:723: function call: locate()
	CLRA
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:723: function call: printf()
	LEAX	S00219,PCR	"OPTIONS"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:724: function call: locate()
	CLRA
	LDB	#$0B		decimal 11 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:724: function call: printf()
	LEAX	S00220,PCR	"HELP"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:725: function call: locate()
	CLRA
	LDB	#$0C		decimal 12 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:725: function call: printf()
	LEAX	S00221,PCR	"EXIT"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:726: function call: locate()
	CLRA
	LDB	#$0E		decimal 14 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$02		decimal 2 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:726: function call: printf()
	LEAX	S00213,PCR	"SELECT OPTION (CURSOR/ENTER)"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Useless label L00150 removed
	RTS
* END FUNCTION drawMenu(): defined at dtet.c:717
funcend_drawMenu	EQU *
funcsize_drawMenu	EQU	funcend_drawMenu-_drawMenu
_menu	EXPORT


*******************************************************************************

* FUNCTION menu(): defined at dtet.c:730
_menu	EQU	*
* Prototype: void menu(...)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-1,S
* Local non-static variable(s):
*     -1,U:    1 byte : optNumber: char: line 731
* Line dtet.c:731: init of variable optNumber
	CLR	-1,U		variable optNumber
* Line dtet.c:732: function call: drawMenu()
	LBSR	_drawMenu
* Line dtet.c:733: function call: drawMenuPtr()
	CLRA
	CLRB
	PSHS	B,A		C function argument 4 of drawMenuPtr(): int
	LDB	-1,U		variable `optNumber', declared at dtet.c:731
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 3 of drawMenuPtr(): char
	CLRA
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 2 of drawMenuPtr(): int
* optim: stripExtraClrA_B
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 1 of drawMenuPtr(): int
	LBSR	_drawMenuPtr
	LEAS	8,S
* Line dtet.c:786: do-while
L00576	EQU	*		do-while body
* Line dtet.c:736: function call: drawHeader()
	LDB	_colourShift+0,PCR
	INC	_colourShift+0,PCR
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawHeader(): unsigned char
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of drawHeader(): int
	LBSR	_drawHeader
	LEAS	4,S
* Line dtet.c:737: assignment: =
* Line dtet.c:737: function call: inkey()
	LBSR	_inkey
	STB	_key+0,PCR
* Line dtet.c:738: if
* optim: storeLoad
	CMPB	#$0A
	LBNE	L00580		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00579 removed
* Line dtet.c:738
* Line dtet.c:739: function call: drawMenuPtr()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 4 of drawMenuPtr(): int
	LDB	-1,U		variable `optNumber', declared at dtet.c:731
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 3 of drawMenuPtr(): char
	CLRA
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 2 of drawMenuPtr(): int
* optim: stripExtraClrA_B
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 1 of drawMenuPtr(): int
	LBSR	_drawMenuPtr
	LEAS	8,S
* Line dtet.c:740: if
	LDB	-1,U
	INC	-1,U
	CMPB	#5
	BNE	L00582		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00581 removed
* Line dtet.c:740
* Line dtet.c:740: assignment: =
	CLR	-1,U		variable optNumber
L00582	EQU	*		else clause of if() started at dtet.c:740
* Useless label L00583 removed
* Line dtet.c:741: function call: drawMenuPtr()
	CLRA
	CLRB
	PSHS	B,A		C function argument 4 of drawMenuPtr(): int
	LDB	-1,U		variable `optNumber', declared at dtet.c:731
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 3 of drawMenuPtr(): char
	CLRA
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 2 of drawMenuPtr(): int
* optim: stripExtraClrA_B
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 1 of drawMenuPtr(): int
	LBSR	_drawMenuPtr
	LEAS	8,S
* Line dtet.c:742: if
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:100
* optim: loadCmpZeroBeqOrBne
	LBNE	L00587
* optim: branchToNextLocation
* Useless label L00584 removed
* Line dtet.c:742
* Line dtet.c:742: function call: sound()
	CLRA
	CLRB
	PSHS	B,A		C function argument 2 of sound(): int
	LDB	#$C8		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of sound(): int
	LBSR	_sound
	LEAS	4,S
* Useless label L00585 removed
* Useless label L00586 removed
	LBRA	L00587		jump over else clause
L00580	EQU	*		else clause of if() started at dtet.c:738
* Line dtet.c:785
* Line dtet.c:744: if
	LDB	_key+0,PCR	variable key
	CMPB	#$5E
	LBNE	L00589		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00588 removed
* Line dtet.c:744
* Line dtet.c:745: function call: drawMenuPtr()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 4 of drawMenuPtr(): int
	LDB	-1,U		variable `optNumber', declared at dtet.c:731
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 3 of drawMenuPtr(): char
	CLRA
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 2 of drawMenuPtr(): int
* optim: stripExtraClrA_B
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 1 of drawMenuPtr(): int
	LBSR	_drawMenuPtr
	LEAS	8,S
* Line dtet.c:746: if
	LDB	-1,U
	DEC	-1,U
	TSTB
	BNE	L00591		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00590 removed
* Line dtet.c:746
* Line dtet.c:746: assignment: =
	LDB	#$05
	STB	-1,U		variable optNumber
L00591	EQU	*		else clause of if() started at dtet.c:746
* Useless label L00592 removed
* Line dtet.c:747: function call: drawMenuPtr()
	CLRA
	CLRB
	PSHS	B,A		C function argument 4 of drawMenuPtr(): int
	LDB	-1,U		variable `optNumber', declared at dtet.c:731
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 3 of drawMenuPtr(): char
	CLRA
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 2 of drawMenuPtr(): int
* optim: stripExtraClrA_B
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 1 of drawMenuPtr(): int
	LBSR	_drawMenuPtr
	LEAS	8,S
* Line dtet.c:748: if
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:100
* optim: loadCmpZeroBeqOrBne
	LBNE	L00596
* optim: branchToNextLocation
* Useless label L00593 removed
* Line dtet.c:748
* Line dtet.c:748: function call: sound()
	CLRA
	CLRB
	PSHS	B,A		C function argument 2 of sound(): int
	LDB	#$C8		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of sound(): int
	LBSR	_sound
	LEAS	4,S
* Useless label L00594 removed
* Useless label L00595 removed
	LBRA	L00596		jump over else clause
L00589	EQU	*		else clause of if() started at dtet.c:744
* Line dtet.c:785
* Line dtet.c:750: if
	LDB	_key+0,PCR	variable key
	CMPB	#$0D
	BEQ	L00597
* optim: branchToNextLocation
* Useless label L00599 removed
* optim: removeLoadInComparisonWithTwoValues
	CMPB	#$20
	LBNE	L00598		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
L00597	EQU	*		then clause of if() started at dtet.c:750
* Line dtet.c:750
* Line dtet.c:751: if
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:100
* optim: loadCmpZeroBeqOrBne
	BNE	L00601
* optim: branchToNextLocation
* Useless label L00600 removed
* Line dtet.c:751
* Line dtet.c:751: function call: sound()
	CLRA
	CLRB
	PSHS	B,A		C function argument 2 of sound(): int
	LDB	#$64		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of sound(): int
	LBSR	_sound
	LEAS	4,S
L00601	EQU	*		else clause of if() started at dtet.c:751
* Useless label L00602 removed
* Line dtet.c:752: function call: drawMenuPtr()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 4 of drawMenuPtr(): int
	LDB	-1,U		variable `optNumber', declared at dtet.c:731
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 3 of drawMenuPtr(): char
	CLRA
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 2 of drawMenuPtr(): int
* optim: stripExtraClrA_B
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 1 of drawMenuPtr(): int
	LBSR	_drawMenuPtr
	LEAS	8,S
* Line dtet.c:753: switch
	LDB	-1,U		variable `optNumber', declared at dtet.c:731
* Switch at dtet.c:753 has 6 non-ignored case values.
* Switch at dtet.c:753 uses jump table: IF_ELSE=39, JUMP_TABLE=32
	SEX
	LEAX	L00611,PCR	jump table for switch at dtet.c:753
signedJumpTableSwitch	IMPORT
	LBRA	signedJumpTableSwitch
	FDB	0		minimum case value
	FDB	5		maximum case value
	FDB	L00610-L00611	offset of default label
L00611	EQU	*
	FDB	L00604-L00611
	FDB	L00605-L00611
	FDB	L00606-L00611
	FDB	L00607-L00611
	FDB	L00608-L00611
	FDB	L00609-L00611
L00604	EQU	*		case 0
* Line dtet.c:755: assignment: =
	CLR	_numPlayers+0,PCR	variable numPlayers
* Line dtet.c:756: assignment: =
	CLRA
* CLRB  optim: optimizeStackOperations1
* PSHS B optim: optimizeStackOperations1
* optim: optimizeLeax
	LDB	#0		optim: optimizeStackOperations1
	STB	_gameOver+0,PCR	optim: optimizeLeax
* Line dtet.c:757: assignment: =
* LDD #$01 optim: optimizeStackOperations1
* PSHS B optim: optimizeStackOperations1
* optim: optimizeLeax
	LDB	#1		optim: optimizeStackOperations1
	STB	_gameOver+1,PCR	optim: optimizeLeax
	LBRA	L00151		return (dtet.c:758)
L00605	EQU	*		case 1
* Line dtet.c:760: assignment: =
	LDB	#$01
	STB	_numPlayers+0,PCR	variable numPlayers
* Line dtet.c:761: assignment: =
	CLRA
* CLRB  optim: optimizeStackOperations1
* PSHS B optim: optimizeStackOperations1
* optim: optimizeLeax
	LDB	#0		optim: optimizeStackOperations1
	STB	_gameOver+0,PCR	optim: optimizeLeax
* Line dtet.c:762: assignment: =
* optim: stripExtraClrA_B
* CLRB  optim: optimizeStackOperations1
* PSHS B optim: optimizeStackOperations1
* optim: optimizeLeax
	LDB	#0		optim: optimizeStackOperations1
	STB	_gameOver+1,PCR	optim: optimizeLeax
	LBRA	L00151		return (dtet.c:763)
L00606	EQU	*		case 2
* Line dtet.c:765: function call: drawHighScores()
	LBSR	_drawHighScores
* Line dtet.c:766: if
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:100
* optim: loadCmpZeroBeqOrBne
	BNE	L00603
* optim: branchToNextLocation
* Useless label L00612 removed
* Line dtet.c:766
* Line dtet.c:766: function call: sound()
	CLRA
	CLRB
	PSHS	B,A		C function argument 2 of sound(): int
	LDB	#$64		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of sound(): int
	LBSR	_sound
	LEAS	4,S
* Useless label L00613 removed
* Useless label L00614 removed
	BRA	L00603		break
L00607	EQU	*		case 3
* Line dtet.c:769: function call: optionsMenu()
	LBSR	_optionsMenu
	BRA	L00603		break
L00608	EQU	*		case 4
* Line dtet.c:772: function call: drawHelp()
	LBSR	_drawHelp
* Line dtet.c:773: if
	LDB	_muted+0,PCR	variable `muted', declared at dtet.c:100
* optim: loadCmpZeroBeqOrBne
	BNE	L00603
* optim: branchToNextLocation
* Useless label L00615 removed
* Line dtet.c:773
* Line dtet.c:773: function call: sound()
	CLRA
	CLRB
	PSHS	B,A		C function argument 2 of sound(): int
	LDB	#$64		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of sound(): int
	LBSR	_sound
	LEAS	4,S
* Useless label L00616 removed
* Useless label L00617 removed
	BRA	L00603		break
L00609	EQU	*		case 5
* Line dtet.c:776: function call: cls()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of cls(): int
	LBSR	_cls
	LEAS	2,S
* Line dtet.c:777: function call: printf()
	LEAX	S00222,PCR	"THANKS FOR PLAYING DRAGONTET!\n"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:778: function call: exit()
	CLRA
	CLRB
	PSHS	B,A		C function argument 1 of exit(): int
	LBSR	_exit
	LEAS	2,S
L00610	EQU	*		default
* optim: branchToNextLocation
L00603	EQU	*		end of switch
* Line dtet.c:782: function call: drawMenu()
	LBSR	_drawMenu
* Line dtet.c:783: function call: drawMenuPtr()
	CLRA
	CLRB
	PSHS	B,A		C function argument 4 of drawMenuPtr(): int
	LDB	-1,U		variable `optNumber', declared at dtet.c:731
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 3 of drawMenuPtr(): char
	CLRA
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 2 of drawMenuPtr(): int
* optim: stripExtraClrA_B
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 1 of drawMenuPtr(): int
	LBSR	_drawMenuPtr
	LEAS	8,S
L00598	EQU	*		else clause of if() started at dtet.c:750
* Useless label L00618 removed
L00596	EQU	*		end of if() started at dtet.c:744
L00587	EQU	*		end of if() started at dtet.c:738
* Line dtet.c:785: function call: delay()
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A		C function argument 1 of delay(): int
	LBSR	_delay
	LEAS	2,S
* Useless label L00577 removed
	LBRA	L00576		go to start of do-while body
* Useless label L00578 removed
L00151	EQU	*		end of menu()
	LEAS	,U
	PULS	U,PC
* END FUNCTION menu(): defined at dtet.c:730
funcend_menu	EQU *
funcsize_menu	EQU	funcend_menu-_menu
_init	EXPORT


*******************************************************************************

* FUNCTION init(): defined at dtet.c:791
_init	EQU	*
* Prototype: void init(...)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-1,S
* Local non-static variable(s):
*     -1,U:    1 byte : i: unsigned char: line 792
* Line dtet.c:793: assignment: =
	CLRA
	CLRB
	STD	$0112
* Line dtet.c:794: function call: menu()
	LBSR	_menu
* Line dtet.c:795: function call: cls()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of cls(): int
	LBSR	_cls
	LEAS	2,S
* Line dtet.c:796: function call: roundWindow()
	CLRA
	CLRB
	PSHS	B,A		C function argument 5 of roundWindow(): int
	LDB	#$0F		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 4 of roundWindow(): int
	LDB	#$01		optim: changeLoadDToLoadB
* optim: removePushBBeforeSubB
	NEGB			optim: removePushBBeforeSubB
	ADDB	_pitLeft+1,PCR	optim: removePushBBeforeSubB
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 3 of roundWindow(): unsigned char
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 2 of roundWindow(): int
* optim: stripExtraClrA_B
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 1 of roundWindow(): int
	LBSR	_roundWindow
	LEAS	10,S
* Line dtet.c:798: for init
* Line dtet.c:798: assignment: =
	LDB	#$01
	STB	-1,U		variable i
	BRA	L00620		jump to for condition
L00619	EQU	*
* Line dtet.c:798: for body
* Line dtet.c:799: function call: printBlock()
	CLRA
	LDB	#$85		decimal 133 signed
	PSHS	B,A		C function argument 3 of printBlock(): int
	LDB	-1,U		variable `i', declared at dtet.c:792
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 2 of printBlock(): unsigned char
	LDB	#$0A		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of printBlock(): int
	LBSR	_printBlock
	LEAS	6,S
* Line dtet.c:800: function call: printBlock()
	CLRA
	LDB	#$8A		decimal 138 signed
	PSHS	B,A		C function argument 3 of printBlock(): int
	LDB	-1,U		variable `i', declared at dtet.c:792
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 2 of printBlock(): unsigned char
	LDB	#$15		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of printBlock(): int
	LBSR	_printBlock
	LEAS	6,S
* Useless label L00621 removed
* Line dtet.c:798: for increment(s)
	INC	-1,U
L00620	EQU	*
* Line dtet.c:798: for condition
	LDB	-1,U		variable i
	CMPB	#$0F
	BLO	L00619
* optim: branchToNextLocation
* Useless label L00622 removed
* Line dtet.c:803: for init
* Line dtet.c:803: assignment: =
	CLRB
	STB	-1,U		variable i
	LBRA	L00624		jump to for condition
L00623	EQU	*
* Line dtet.c:803: for body
* Line dtet.c:804: assignment: =
* Line dtet.c:804: assignment: =
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B
	LDB	-1,U		variable i
	LEAX	_previousLevel+0,PCR	address of array previousLevel
	ABX			add unsigned 8-bit offset
	LDB	,S+
	STB	,X
	PSHS	B
	LDB	-1,U		variable i
	LEAX	_level+0,PCR	address of array level
	ABX			add unsigned 8-bit offset
	LDB	,S+
	STB	,X
* Line dtet.c:805: assignment: =
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A
	LDB	-1,U		variable i
* optim: stripExtraClrA_B
	LSLB
	ROLA
	LEAX	_lines+0,PCR	address of array lines
	LEAX	D,X		add offset
	PULS	A,B		retrieve value to store
	STD	,X
* Line dtet.c:806: assignment: =
	CLRA
	CLRB
	PSHS	B,A
	LDB	-1,U		variable i
	ADDB	#$06		6
* optim: stripExtraClrA_B
	LSLB
	ROLA
	LEAX	_scores+0,PCR	address of array scores
	LEAX	D,X		add offset
	PULS	A,B		retrieve value to store
	STD	,X
* Line dtet.c:807: assignment: =
	CLRA
	LDB	#$FF		decimal 255 signed
	PSHS	B
	LDB	-1,U		variable i
	LEAX	_nextShape+0,PCR	address of array nextShape
	ABX			add unsigned 8-bit offset
	LDB	,S+
	STB	,X
* Line dtet.c:808: assignment: =
	LDB	_backgroundCharList+0,PCR	index 0 in array backgroundCharList[]
	PSHS	B
	LDB	-1,U		variable i
	LEAX	_backgroundChar+0,PCR	address of array backgroundChar
	ABX			add unsigned 8-bit offset
	LDB	,S+
	STB	,X
* Line dtet.c:809: assignment: =
* optim: stripExtraClrA_B
	CLRB
	PSHS	B
	LDB	-1,U		variable i
	LEAX	_linesPiecesPlayed+0,PCR	address of array linesPiecesPlayed
	ABX			add unsigned 8-bit offset
	LDB	,S+
	STB	,X
* Line dtet.c:810: function call: createShape()
	LDB	-1,U		variable `i', declared at dtet.c:792
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of createShape(): unsigned char
	LBSR	_createShape
	LEAS	2,S
* Line dtet.c:811: function call: memset()
	CLRA
	LDB	#$A0		constant expression: 160 decimal, signed
	PSHS	B,A		C function argument 3 of memset(): int
	LDB	#$30		decimal 48 signed
	SEX			promoting byte argument to word
	PSHS	B,A		C function argument 2 of memset(): char
	LDB	-1,U		variable i
* optim: stripOpToDeadReg
	LDA	#160		size of array element
	MUL			get offset in bytes in D
	LEAX	_pit+0,PCR	address of array pit
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	PSHS	B,A		C function argument 1 of memset(): char[]
	LBSR	_memset
	LEAS	6,S
* Line dtet.c:812: function call: drawPit()
	LDB	-1,U		variable `i', declared at dtet.c:792
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 1 of drawPit(): unsigned char
	LBSR	_drawPit
	LEAS	2,S
* Useless label L00625 removed
* Line dtet.c:803: for increment(s)
	INC	-1,U
L00624	EQU	*
* Line dtet.c:803: for condition
	LDB	-1,U		variable i
	CMPB	#$02
	LBLO	L00623
* optim: branchToNextLocation
* Useless label L00626 removed
* Line dtet.c:814: assignment: =
	CLR	_cancelled+0,PCR	variable cancelled
* Line dtet.c:815: assignment: =
	CLR	_lastLines+0,PCR	variable lastLines
* Line dtet.c:816: assignment: =
	CLRA
	CLRB
	STD	_lastPoints+0,PCR
* Line dtet.c:817: function call: displayStatus()
	LBSR	_displayStatus
* Line dtet.c:818: if
	LDB	_numPlayers+0,PCR	variable `numPlayers', declared at dtet.c:82
* optim: loadCmpZeroBeqOrBne
	LBNE	L00628		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00627 removed
* Line dtet.c:818
* Line dtet.c:819: function call: locate()
	CLRA
	LDB	#$06		decimal 6 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$17		decimal 23 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:819: function call: printf()
	LEAX	S00223,PCR	" PLEASE "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:820: function call: locate()
	CLRA
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$17		decimal 23 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:820: function call: printf()
	LEAX	S00224,PCR	"  WAIT  "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:821: function call: locate()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$17		decimal 23 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:821: function call: printf()
	LEAX	S00225,PCR	" DRAGON "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:822: function call: locate()
	CLRA
	LDB	#$09		decimal 9 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$17		decimal 23 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:822: function call: printf()
	LEAX	S00226,PCR	"   2!   "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
L00628	EQU	*		else clause of if() started at dtet.c:818
* Useless label L00629 removed
* Useless label L00152 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION init(): defined at dtet.c:791
funcend_init	EQU *
funcsize_init	EQU	funcend_init-_init
_rotateKeyPressed	EXPORT


*******************************************************************************

* FUNCTION rotateKeyPressed(): defined at dtet.c:827
_rotateKeyPressed	EQU	*
* Prototype: void rotateKeyPressed(unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-1,S
* Formal parameter(s):
*      5,U:    1 byte : i: unsigned char: line 827
* Local non-static variable(s):
*     -1,U:    1 byte : nextAngle: unsigned char: line 828
* Line dtet.c:828: init of variable nextAngle
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B
	LDB	5,U		variable i
	LEAX	_shapeAngle+0,PCR	address of array shapeAngle
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	ADDB	,S+
	ANDB	#$03		modulo 4
	STB	-1,U		variable nextAngle
* Line dtet.c:829: function call: getRotatedShapeMap()
	LDB	5,U		variable i
* optim: stripExtraClrA_B
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LEAX	_rotatedMap+0,PCR	address of array rotatedMap
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	PSHS	B,A		C function argument 3 of getRotatedShapeMap(): char[]
	LDB	-1,U		variable `nextAngle', declared at dtet.c:828
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of getRotatedShapeMap(): unsigned char
	LDB	5,U		variable i
	LEAX	_shape+0,PCR	address of array shape
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of getRotatedShapeMap(): unsigned char
	LBSR	_getRotatedShapeMap
	LEAS	6,S
* Line dtet.c:830: if
* Line dtet.c:830: function call: shapeCanMove()
	LDB	5,U		variable `i', declared at dtet.c:827
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 4 of shapeCanMove(): unsigned char
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 3 of shapeCanMove(): int
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 2 of shapeCanMove(): int
	LDB	5,U		variable i
* optim: stripExtraClrA_B
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LEAX	_rotatedMap+0,PCR	address of array rotatedMap
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	PSHS	B,A		C function argument 1 of shapeCanMove(): char[]
	LBSR	_shapeCanMove
	LEAS	8,S
	TSTB
	LBEQ	L00631		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00630 removed
* Line dtet.c:830
* Line dtet.c:831: assignment: =
	LDB	-1,U		variable `nextAngle', declared at dtet.c:828
	PSHS	B
	LDB	5,U		variable i
	LEAX	_shapeAngle+0,PCR	address of array shapeAngle
	ABX			add unsigned 8-bit offset
	LDB	,S+
	STB	,X
* Line dtet.c:832: function call: drawShape()
	LDB	5,U		variable `i', declared at dtet.c:827
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawShape(): unsigned char
	LDB	#$01		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of drawShape(): int
	LBSR	_drawShape
	LEAS	4,S
* Line dtet.c:833: function call: strncpy()
	CLRA
	LDB	#$10		decimal 16 signed
	PSHS	B,A		C function argument 3 of strncpy(): int
	LDB	5,U		variable i
* optim: stripExtraClrA_B
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LEAX	_rotatedMap+0,PCR	address of array rotatedMap
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	PSHS	B,A		C function argument 2 of strncpy(): char[]
	LDB	5,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LEAX	_shapeMap+0,PCR	address of array shapeMap
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	PSHS	B,A		C function argument 1 of strncpy(): char[]
	LBSR	_strncpy
	LEAS	6,S
* Line dtet.c:834: function call: drawShape()
	LDB	5,U		variable `i', declared at dtet.c:827
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawShape(): unsigned char
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of drawShape(): int
	LBSR	_drawShape
	LEAS	4,S
L00631	EQU	*		else clause of if() started at dtet.c:830
* Useless label L00632 removed
* Useless label L00153 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION rotateKeyPressed(): defined at dtet.c:827
funcend_rotateKeyPressed	EQU *
funcsize_rotateKeyPressed	EQU	funcend_rotateKeyPressed-_rotateKeyPressed
_moveLeftKeyPressed	EXPORT


*******************************************************************************

* FUNCTION moveLeftKeyPressed(): defined at dtet.c:839
_moveLeftKeyPressed	EQU	*
* Prototype: void moveLeftKeyPressed(unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
* Formal parameter(s):
*      5,U:    1 byte : i: unsigned char: line 839
* Line dtet.c:840: if
* Line dtet.c:840: function call: shapeCanMove()
	LDB	5,U		variable `i', declared at dtet.c:839
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 4 of shapeCanMove(): unsigned char
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 3 of shapeCanMove(): int
	LDD	#$FFFF		constant expression: 65535 decimal, signed
	PSHS	B,A		C function argument 2 of shapeCanMove(): int
	LDB	5,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LEAX	_shapeMap+0,PCR	address of array shapeMap
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	PSHS	B,A		C function argument 1 of shapeCanMove(): char[]
	LBSR	_shapeCanMove
	LEAS	8,S
	TSTB
	BEQ	L00634		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00633 removed
* Line dtet.c:840
* Line dtet.c:841: function call: drawShape()
	LDB	5,U		variable `i', declared at dtet.c:839
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawShape(): unsigned char
	LDB	#$01		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of drawShape(): int
	LBSR	_drawShape
	LEAS	4,S
* Line dtet.c:842: post-decrement
	LDB	5,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_shapeX+0,PCR	address of array shapeX
	LEAX	D,X		add offset
	LDD	,X
	ADDD	#-1
	STD	,X
* Line dtet.c:843: function call: drawShape()
	LDB	5,U		variable `i', declared at dtet.c:839
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawShape(): unsigned char
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of drawShape(): int
	LBSR	_drawShape
	LEAS	4,S
L00634	EQU	*		else clause of if() started at dtet.c:840
* Useless label L00635 removed
* Useless label L00154 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION moveLeftKeyPressed(): defined at dtet.c:839
funcend_moveLeftKeyPressed	EQU *
funcsize_moveLeftKeyPressed	EQU	funcend_moveLeftKeyPressed-_moveLeftKeyPressed
_moveRightKeyPressed	EXPORT


*******************************************************************************

* FUNCTION moveRightKeyPressed(): defined at dtet.c:848
_moveRightKeyPressed	EQU	*
* Prototype: void moveRightKeyPressed(unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
* Formal parameter(s):
*      5,U:    1 byte : i: unsigned char: line 848
* Line dtet.c:849: if
* Line dtet.c:849: function call: shapeCanMove()
	LDB	5,U		variable `i', declared at dtet.c:848
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 4 of shapeCanMove(): unsigned char
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 3 of shapeCanMove(): int
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 2 of shapeCanMove(): int
	LDB	5,U		variable i
* optim: removeClr
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LSLB
	ROLA
	LEAX	_shapeMap+0,PCR	address of array shapeMap
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	PSHS	B,A		C function argument 1 of shapeCanMove(): char[]
	LBSR	_shapeCanMove
	LEAS	8,S
	TSTB
	BEQ	L00637		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00636 removed
* Line dtet.c:849
* Line dtet.c:850: function call: drawShape()
	LDB	5,U		variable `i', declared at dtet.c:848
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawShape(): unsigned char
	LDB	#$01		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of drawShape(): int
	LBSR	_drawShape
	LEAS	4,S
* Line dtet.c:851: post-increment
	LDB	5,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_shapeX+0,PCR	address of array shapeX
	LEAX	D,X		add offset
	LDD	,X
	ADDD	#1
	STD	,X
* Line dtet.c:852: function call: drawShape()
	LDB	5,U		variable `i', declared at dtet.c:848
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawShape(): unsigned char
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of drawShape(): int
	LBSR	_drawShape
	LEAS	4,S
L00637	EQU	*		else clause of if() started at dtet.c:849
* Useless label L00638 removed
* Useless label L00155 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION moveRightKeyPressed(): defined at dtet.c:848
funcend_moveRightKeyPressed	EQU *
funcsize_moveRightKeyPressed	EQU	funcend_moveRightKeyPressed-_moveRightKeyPressed
_canProcessInput	EXPORT


*******************************************************************************

* FUNCTION canProcessInput(): defined at dtet.c:861
_canProcessInput	EQU	*
* Prototype: unsigned char canProcessInput(unsigned char, unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-2,S
* Formal parameter(s):
*      5,U:    1 byte : i: unsigned char: line 861
*      7,U:    1 byte : action: unsigned char: line 861
* Local non-static variable(s):
*     -2,U:    2 bytes: currentTime: unsigned int: line 862
* Line dtet.c:862: init of variable currentTime
	LDD	$0112		decimal 274
	STD	-2,U		variable currentTime
* Line dtet.c:863: if
	CLRA
* optim: stripConsecutiveLoadsToSameReg
* PSHS B,A optim: optimizeStackOperations1
	LDB	7,U		variable action
* optim: stripExtraClrA_B
	LSLB
	ROLA
	PSHS	B,A		preserve array index
	LDB	5,U		variable i
* optim: stripOpToDeadReg
	LDA	#6		size of array element
	MUL			get offset in bytes in D
	LEAX	_lastInputTime+0,PCR	address of array lastInputTime
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDD	-2,U		variable `currentTime', declared at dtet.c:862
	SUBD	,X		optim: optimizeStackOperations4
	CMPD	#6		optim: optimizeStackOperations1
	BLO	L00640		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00639 removed
* Line dtet.c:863
* Line dtet.c:864: assignment: =
	LDD	-2,U		variable `currentTime', declared at dtet.c:862
	PSHS	B,A
	LDB	7,U		variable action
	CLRA			index expression is of byte type
	LSLB
	ROLA
	PSHS	B,A		preserve array index
	LDB	5,U		variable i
* optim: stripOpToDeadReg
	LDA	#6		size of array element
	MUL			get offset in bytes in D
	LEAX	_lastInputTime+0,PCR	address of array lastInputTime
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	PULS	A,B		retrieve value to store
	STD	,X
	LDB	#1
	BRA	L00156		return (dtet.c:865)
L00640	EQU	*		else clause of if() started at dtet.c:863
* Useless label L00641 removed
	CLRB
* optim: branchToNextLocation
L00156	EQU	*		end of canProcessInput()
	LEAS	,U
	PULS	U,PC
* END FUNCTION canProcessInput(): defined at dtet.c:861
funcend_canProcessInput	EQU *
funcsize_canProcessInput	EQU	funcend_canProcessInput-_canProcessInput
_mainLoop	EXPORT


*******************************************************************************

* FUNCTION mainLoop(): defined at dtet.c:871
_mainLoop	EQU	*
* Prototype: void mainLoop(...)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-3,S
* Local non-static variable(s):
*     -3,U:    2 bytes: joystickPositions: const unsigned char *: line 880
*     -1,U:    1 byte : i: unsigned char: line 872
* Line dtet.c:874: function call: playTune()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 3 of playTune(): int
	LEAX	_tune2Durations+0,PCR	address of array tune2Durations
	PSHS	X		C function argument 2 of playTune(): const unsigned char[]
	LEAX	_tune2Notes+0,PCR	address of array tune2Notes
	PSHS	X		C function argument 1 of playTune(): const unsigned char[]
	LBSR	_playTune
	LEAS	6,S
* Line dtet.c:877: assignment: =
* Line dtet.c:877: assignment: =
	LDD	$0112		decimal 274
* optim: stripUselessPushPull
* optim: optimizeLeax
* optim: stripUselessPushPull
	STD	_startTime+2,PCR	optim: optimizeLeax
* optim: stripUselessPushPull
* optim: optimizeLeax
* optim: stripUselessPushPull
	STD	_startTime+0,PCR	optim: optimizeLeax
* Line dtet.c:879: while
	LBRA	L00643		jump to while condition
L00642	EQU	*		while body
* Line dtet.c:880: init of variable joystickPositions
* Line dtet.c:880: function call: readJoystickPositions()
	LBSR	_readJoystickPositions
	STD	-3,U		variable joystickPositions
* Line dtet.c:910: if
* Line dtet.c:910: function call: isKeyPressed()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$FE		decimal 254 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BEQ	L00646		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00645 removed
* Line dtet.c:910
* Line dtet.c:911: while
	BRA	L00648		jump to while condition
L00647	EQU	*		while body
L00648	EQU	*		while condition at dtet.c:911
* Line dtet.c:911: function call: inkey()
	LBSR	_inkey
	TSTB
	BNE	L00647
* optim: branchToNextLocation
* Useless label L00649 removed
* Line dtet.c:912: while
	BRA	L00651		jump to while condition
L00650	EQU	*		while body
* Line dtet.c:912: function call: delay()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of delay(): int
	LBSR	_delay
	LEAS	2,S
L00651	EQU	*		while condition at dtet.c:912
* Line dtet.c:912: function call: inkey()
	LBSR	_inkey
	TSTB
	BEQ	L00650
* optim: branchToNextLocation
* Useless label L00652 removed
* Line dtet.c:913: assignment: =
* Line dtet.c:913: assignment: =
	LDD	$0112		decimal 274
* optim: stripUselessPushPull
* optim: optimizeLeax
* optim: stripUselessPushPull
	STD	_startTime+2,PCR	optim: optimizeLeax
* optim: stripUselessPushPull
* optim: optimizeLeax
* optim: stripUselessPushPull
	STD	_startTime+0,PCR	optim: optimizeLeax
	LBRA	L00643		continue
	LBRA	L00653		jump over else clause
L00646	EQU	*		else clause of if() started at dtet.c:910
* Line dtet.c:928
* Line dtet.c:916: if
* Line dtet.c:916: function call: isKeyPressed()
	CLRA
	LDB	#$20		decimal 32 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$FE		decimal 254 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BEQ	L00655		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00654 removed
* Line dtet.c:916
* Line dtet.c:917: if
	LDB	_gameOver+0,PCR	index 0 in array gameOver[]
* optim: loadCmpZeroBeqOrBne
	BEQ	L00656		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00658 removed
	LDB	_gameOver+1,PCR	index 1 in array gameOver[]
* optim: loadCmpZeroBeqOrBne
	LBNE	L00644
* optim: branchToNextLocation
L00656	EQU	*		then clause of if() started at dtet.c:917
* Line dtet.c:918
* Line dtet.c:918: assignment: =
	LDB	#$01
	STB	_cancelled+0,PCR	variable cancelled
* Useless label L00657 removed
* Useless label L00659 removed
	LBRA	L00644		break
	BRA	L00660		jump over else clause
L00655	EQU	*		else clause of if() started at dtet.c:916
* Line dtet.c:928
* Line dtet.c:923: if
* Line dtet.c:921: function call: isKeyPressed()
	CLRA
	LDB	#$40		decimal 64 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$FE		decimal 254 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BNE	L00663
* optim: branchToNextLocation
* Useless label L00664 removed
* Line dtet.c:922: function call: isKeyPressed()
	CLRA
	LDB	#$20		decimal 32 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$7F		decimal 127 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BEQ	L00662		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
L00663	EQU	*
	LDB	_gameOver+0,PCR	index 0 in array gameOver[]
* optim: loadCmpZeroBeqOrBne
	BEQ	L00662		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00665 removed
	LDB	_gameOver+1,PCR	index 1 in array gameOver[]
* optim: loadCmpZeroBeqOrBne
	LBNE	L00644		 (optim: condBranchOverUncondBranch) (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00661 removed
* Line dtet.c:923
* optim: condBranchOverUncondBranch
L00662	EQU	*		else clause of if() started at dtet.c:923
* Useless label L00666 removed
L00660	EQU	*		end of if() started at dtet.c:916
L00653	EQU	*		end of if() started at dtet.c:910
* Line dtet.c:930: if
* Line dtet.c:928: function call: isKeyPressed()
	CLRA
	LDB	#$10		decimal 16 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$7F		decimal 127 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BNE	L00667
* optim: branchToNextLocation
* Useless label L00670 removed
* Line dtet.c:929: function call: isKeyPressed()
	CLRA
	LDB	#$20		decimal 32 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$F7		decimal 247 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BNE	L00667
* optim: branchToNextLocation
* Useless label L00669 removed
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
	LDX	-3,U		get pointer value
* optim: optimizeLeax
	LDB	3,X		optim: optimizeLeax
* optim: stripExtraClrA_B
	CMPD	#16		optim: optimizeStackOperations1
	BHS	L00668		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
L00667	EQU	*		then clause of if() started at dtet.c:930
* Line dtet.c:933
* Line dtet.c:931: if
* Line dtet.c:931: function call: canProcessInput()
	CLRA
	CLRB
	PSHS	B,A		C function argument 2 of canProcessInput(): int
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
	PSHS	B,A		C function argument 1 of canProcessInput(): int
	LBSR	_canProcessInput
	LEAS	4,S
	TSTB
	BEQ	L00672		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00671 removed
* Line dtet.c:931
* Line dtet.c:931: function call: rotateKeyPressed()
	CLRA
	CLRB
	PSHS	B,A		C function argument 1 of rotateKeyPressed(): int
	LBSR	_rotateKeyPressed
	LEAS	2,S
L00672	EQU	*		else clause of if() started at dtet.c:931
* Useless label L00673 removed
L00668	EQU	*		else clause of if() started at dtet.c:930
* Useless label L00674 removed
* Line dtet.c:935: if
* Line dtet.c:933: function call: isKeyPressed()
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$FD		decimal 253 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BNE	L00675
* optim: branchToNextLocation
* Useless label L00678 removed
* Line dtet.c:934: function call: isKeyPressed()
	CLRA
	LDB	#$20		decimal 32 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$DF		decimal 223 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BNE	L00675
* optim: branchToNextLocation
* Useless label L00677 removed
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
	LDX	-3,U		get pointer value
* optim: optimizeLeax
	LDB	2,X		optim: optimizeLeax
* optim: stripExtraClrA_B
	CMPD	#16		optim: optimizeStackOperations1
	BHS	L00676		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
L00675	EQU	*		then clause of if() started at dtet.c:935
* Line dtet.c:938
* Line dtet.c:936: if
* Line dtet.c:936: function call: canProcessInput()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 2 of canProcessInput(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of canProcessInput(): int
	LBSR	_canProcessInput
	LEAS	4,S
	TSTB
	BEQ	L00680		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00679 removed
* Line dtet.c:936
* Line dtet.c:936: function call: moveLeftKeyPressed()
	CLRA
	CLRB
	PSHS	B,A		C function argument 1 of moveLeftKeyPressed(): int
	LBSR	_moveLeftKeyPressed
	LEAS	2,S
L00680	EQU	*		else clause of if() started at dtet.c:936
* Useless label L00681 removed
L00676	EQU	*		else clause of if() started at dtet.c:935
* Useless label L00682 removed
* Line dtet.c:940: if
* Line dtet.c:938: function call: isKeyPressed()
	CLRA
	LDB	#$10		decimal 16 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$F7		decimal 247 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BNE	L00683
* optim: branchToNextLocation
* Useless label L00686 removed
* Line dtet.c:939: function call: isKeyPressed()
	CLRA
	LDB	#$20		decimal 32 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$EF		decimal 239 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BNE	L00683
* optim: branchToNextLocation
* Useless label L00685 removed
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
	LDX	-3,U		get pointer value
* optim: optimizeLeax
	LDB	3,X		optim: optimizeLeax
* optim: stripExtraClrA_B
	CMPD	#48		optim: optimizeStackOperations1
	BLS	L00684		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
L00683	EQU	*		then clause of if() started at dtet.c:940
* Line dtet.c:941
* Line dtet.c:941: assignment: =
	CLRA
	CLRB
* optim: stripUselessPushPull
	LEAX	_dropRate+0,PCR	index 0 in array dropRate[]
* optim: stripUselessPushPull
	STD	,X
L00684	EQU	*		else clause of if() started at dtet.c:940
* Useless label L00687 removed
* Line dtet.c:945: if
* Line dtet.c:943: function call: isKeyPressed()
	CLRA
	LDB	#$04		decimal 4 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$EF		decimal 239 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BNE	L00688
* optim: branchToNextLocation
* Useless label L00691 removed
* Line dtet.c:944: function call: isKeyPressed()
	CLRA
	LDB	#$20		decimal 32 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$BF		decimal 191 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BNE	L00688
* optim: branchToNextLocation
* Useless label L00690 removed
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
	LDX	-3,U		get pointer value
* optim: optimizeLeax
	LDB	2,X		optim: optimizeLeax
* optim: stripExtraClrA_B
	CMPD	#48		optim: optimizeStackOperations1
	BLS	L00689		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
L00688	EQU	*		then clause of if() started at dtet.c:945
* Line dtet.c:949
* Line dtet.c:946: if
* Line dtet.c:946: function call: canProcessInput()
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A		C function argument 2 of canProcessInput(): int
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of canProcessInput(): int
	LBSR	_canProcessInput
	LEAS	4,S
	TSTB
	BEQ	L00693		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00692 removed
* Line dtet.c:946
* Line dtet.c:946: function call: moveRightKeyPressed()
	CLRA
	CLRB
	PSHS	B,A		C function argument 1 of moveRightKeyPressed(): int
	LBSR	_moveRightKeyPressed
	LEAS	2,S
L00693	EQU	*		else clause of if() started at dtet.c:946
* Useless label L00694 removed
L00689	EQU	*		else clause of if() started at dtet.c:945
* Useless label L00695 removed
* Line dtet.c:949: if
	LDB	_numPlayers+0,PCR	variable numPlayers
* optim: removeCMPZeroAfterLDIfBHI (BHI->BNE)
	LBEQ	L00697		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00696 removed
* Line dtet.c:949
* Line dtet.c:952: if
* Line dtet.c:951: function call: isKeyPressed()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$FD		decimal 253 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BNE	L00698
* optim: branchToNextLocation
* Useless label L00700 removed
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
	LDX	-3,U		get pointer value
* optim: optimizeLeax
	LDB	1,X		optim: optimizeLeax
* optim: stripExtraClrA_B
	CMPD	#16		optim: optimizeStackOperations1
	BHS	L00699		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
L00698	EQU	*		then clause of if() started at dtet.c:952
* Line dtet.c:955
* Line dtet.c:953: if
* Line dtet.c:953: function call: canProcessInput()
	CLRA
	CLRB
	PSHS	B,A		C function argument 2 of canProcessInput(): int
	LDB	#$01		optim: changeLoadDToLoadB
	PSHS	B,A		C function argument 1 of canProcessInput(): int
	LBSR	_canProcessInput
	LEAS	4,S
	TSTB
	BEQ	L00702		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00701 removed
* Line dtet.c:953
* Line dtet.c:953: function call: rotateKeyPressed()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of rotateKeyPressed(): int
	LBSR	_rotateKeyPressed
	LEAS	2,S
L00702	EQU	*		else clause of if() started at dtet.c:953
* Useless label L00703 removed
L00699	EQU	*		else clause of if() started at dtet.c:952
* Useless label L00704 removed
* Line dtet.c:956: if
* Line dtet.c:955: function call: isKeyPressed()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$FB		decimal 251 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BNE	L00705
* optim: branchToNextLocation
* Useless label L00707 removed
	CLRA
	LDB	#$10		decimal 16 signed
	PSHS	B,A
* optim: optimizeLdx
	LDB	[-3,U]		optim: optimizeLdx
* optim: stripExtraClrA_B
	CMPD	,S++
	BHS	L00706		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
L00705	EQU	*		then clause of if() started at dtet.c:956
* Line dtet.c:959
* Line dtet.c:957: if
* Line dtet.c:957: function call: canProcessInput()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 2 of canProcessInput(): int
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of canProcessInput(): int
	LBSR	_canProcessInput
	LEAS	4,S
	TSTB
	BEQ	L00709		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00708 removed
* Line dtet.c:957
* Line dtet.c:957: function call: moveLeftKeyPressed()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of moveLeftKeyPressed(): int
	LBSR	_moveLeftKeyPressed
	LEAS	2,S
L00709	EQU	*		else clause of if() started at dtet.c:957
* Useless label L00710 removed
L00706	EQU	*		else clause of if() started at dtet.c:956
* Useless label L00711 removed
* Line dtet.c:960: if
* Line dtet.c:959: function call: isKeyPressed()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$F7		decimal 247 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BNE	L00712
* optim: branchToNextLocation
* Useless label L00714 removed
	CLRA
* optim: removeUselessOps
* PSHS B,A optim: optimizeStackOperations1
	LDX	-3,U		get pointer value
* optim: optimizeLeax
	LDB	1,X		optim: optimizeLeax
* optim: stripExtraClrA_B
	CMPD	#48		optim: optimizeStackOperations1
	BLS	L00713		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
L00712	EQU	*		then clause of if() started at dtet.c:960
* Line dtet.c:961
* Line dtet.c:961: assignment: =
	CLRA
	CLRB
* optim: stripUselessPushPull
	LEAX	_dropRate+2,PCR	index 1 in array dropRate[]
* optim: stripUselessPushPull
	STD	,X
L00713	EQU	*		else clause of if() started at dtet.c:960
* Useless label L00715 removed
* Line dtet.c:964: if
* Line dtet.c:963: function call: isKeyPressed()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of isKeyPressed(): int
* optim: stripExtraClrA_B
	LDB	#$EF		decimal 239 signed
	PSHS	B,A		C function argument 1 of isKeyPressed(): int
	LBSR	_isKeyPressed
	LEAS	4,S
	TSTB
	BNE	L00716
* optim: branchToNextLocation
* Useless label L00718 removed
	CLRA
	LDB	#$30		decimal 48 signed
	PSHS	B,A
* optim: optimizeLdx
	LDB	[-3,U]		optim: optimizeLdx
* optim: stripExtraClrA_B
	CMPD	,S++
	BLS	L00717		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
L00716	EQU	*		then clause of if() started at dtet.c:964
* Line dtet.c:966
* Line dtet.c:965: if
* Line dtet.c:965: function call: canProcessInput()
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A		C function argument 2 of canProcessInput(): int
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of canProcessInput(): int
	LBSR	_canProcessInput
	LEAS	4,S
	TSTB
	BEQ	L00720		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00719 removed
* Line dtet.c:965
* Line dtet.c:965: function call: moveRightKeyPressed()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of moveRightKeyPressed(): int
	LBSR	_moveRightKeyPressed
	LEAS	2,S
L00720	EQU	*		else clause of if() started at dtet.c:965
* Useless label L00721 removed
L00717	EQU	*		else clause of if() started at dtet.c:964
* Useless label L00722 removed
L00697	EQU	*		else clause of if() started at dtet.c:949
* Useless label L00723 removed
* Line dtet.c:1031: for init
* Line dtet.c:1031: assignment: =
	CLRB
	STB	-1,U		variable i
	LBRA	L00725		jump to for condition
L00724	EQU	*
* Line dtet.c:1031: for body
* Line dtet.c:1032: if
	LDB	-1,U		variable i
	LEAX	_gameOver+0,PCR	address of array gameOver
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
* optim: loadCmpZeroBeqOrBne
	BNE	L00729
* optim: branchToNextLocation
* Useless label L00730 removed
	LDB	-1,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_dropRate+0,PCR	address of array dropRate
* optimizeLoadDX
	LDD	D,X		get r-value
	PSHS	B,A
	LDB	-1,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_startTime+0,PCR	address of array startTime
* optimizeLoadDX
	LDD	D,X		get r-value
	ADDD	,S++
	PSHS	B,A
	LDD	$0112		decimal 274
	CMPD	,S++
	BLO	L00729		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00728 removed
* Line dtet.c:1032
* Line dtet.c:1033: function call: dropShape()
	LDB	-1,U		variable `i', declared at dtet.c:872
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 1 of dropShape(): unsigned char
	LBSR	_dropShape
	LEAS	2,S
* Line dtet.c:1034: assignment: =
	LDD	$0112		decimal 274
	PSHS	B,A
	LDB	-1,U		variable i
	CLRA			index expression is of byte type
	LSLB
	ROLA
	LEAX	_startTime+0,PCR	address of array startTime
	LEAX	D,X		add offset
	PULS	A,B		retrieve value to store
	STD	,X
L00729	EQU	*		else clause of if() started at dtet.c:1032
* Useless label L00731 removed
* Useless label L00726 removed
* Line dtet.c:1031: for increment(s)
	INC	-1,U
L00725	EQU	*
* Line dtet.c:1031: for condition
	LDB	-1,U		variable i
	CMPB	_numPlayers+0,PCR	variable numPlayers
	LBLS	L00724
* optim: branchToNextLocation
* Useless label L00727 removed
L00643	EQU	*		while condition at dtet.c:879
	LBRA	L00642		go to start of while body
L00644	EQU	*		after end of while starting at dtet.c:879
* Useless label L00157 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION mainLoop(): defined at dtet.c:871
funcend_mainLoop	EQU *
funcsize_mainLoop	EQU	funcend_mainLoop-_mainLoop
_checkScore	EXPORT


*******************************************************************************

* FUNCTION checkScore(): defined at dtet.c:1042
_checkScore	EQU	*
* Prototype: void checkScore(unsigned char)
* Calling convention: 0 (CMOC Default)
	PSHS	U
	LEAU	,S
	LEAS	-6,S
* Formal parameter(s):
*      5,U:    1 byte : player: unsigned char: line 1042
* Local non-static variable(s):
*     -6,U:    2 bytes: response: char *: line 1055
*     -4,U:    2 bytes: i: int: line 1044
*     -2,U:    2 bytes: j: int: line 1045
* Line dtet.c:1044: init of variable i
	LDB	5,U		variable player
	ADDB	#$06		6
	CLRA
	STD	-4,U		variable i
* Line dtet.c:1046: assignment: =
* optim: stripExtraClrA_B
* CLRB  optim: optimizeStackOperations1
* PSHS B optim: optimizeStackOperations1
	LDB	5,U		variable player
	LEAX	_newScore+0,PCR	address of array newScore
	ABX			add unsigned 8-bit offset
	LDB	#0		optim: optimizeStackOperations1
	STB	,X
* Line dtet.c:1047: if
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDD	-4,U		variable i
	LSLB
	ROLA
	LEAX	_scores+0,PCR	address of array scores
* optimizeLoadDX
	LDD	D,X		get r-value
	CMPD	_scores+10,PCR	optim: optimizeStackOperations4
	LBLS	L00733		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00732 removed
* Line dtet.c:1047
* Line dtet.c:1048: function call: cls()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of cls(): int
	LBSR	_cls
	LEAS	2,S
* Line dtet.c:1049: function call: roundWindow()
	CLRA
	LDB	#$50		decimal 80 signed
	PSHS	B,A		C function argument 5 of roundWindow(): int
* optim: stripExtraClrA_B
	LDB	#$0F		decimal 15 signed
	PSHS	B,A		C function argument 4 of roundWindow(): int
* optim: stripExtraClrA_B
	LDB	#$1F		decimal 31 signed
	PSHS	B,A		C function argument 3 of roundWindow(): int
* optim: removeClr
	CLRB
	PSHS	B,A		C function argument 2 of roundWindow(): int
* optim: removeClr
* optim: removeClr
	PSHS	B,A		C function argument 1 of roundWindow(): int
	LBSR	_roundWindow
	LEAS	10,S
* Line dtet.c:1050: function call: drawHeader()
	INC	_colourShift+0,PCR
	LDB	_colourShift+0,PCR
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawHeader(): unsigned char
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of drawHeader(): int
	LBSR	_drawHeader
	LEAS	4,S
* Line dtet.c:1051: function call: locate()
	CLRA
	LDB	#$08		decimal 8 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:1051: function call: printf()
	LDD	-4,U		variable i
	LSLB
	ROLA
	LEAX	_scores+0,PCR	address of array scores
* optimizeLoadDX
	LDD	D,X		get r-value
	PSHS	B,A		C function argument 2 of printf(): unsigned int
	LEAX	S00227,PCR	"*** %u ***"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	4,S
* Line dtet.c:1052: function call: locate()
	CLRA
	LDB	#$0B		decimal 11 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:1052: function call: printf()
	LDB	5,U		variable player
	ADDB	#$01		1
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of printf(): unsigned char
	LEAX	S00228,PCR	"GOOD SCORE DRAGON %d"
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	4,S
* Line dtet.c:1053: function call: locate()
	CLRA
	LDB	#$0C		decimal 12 signed
	PSHS	B,A		C function argument 2 of locate(): int
* optim: stripExtraClrA_B
	LDB	#$07		decimal 7 signed
	PSHS	B,A		C function argument 1 of locate(): int
	LBSR	_locate
	LEAS	4,S
* Line dtet.c:1053: function call: printf()
	LEAX	S00229,PCR	"NAME?: "
	PSHS	X		C function argument 1 of printf(): const char[]
	LBSR	_printf
	LEAS	2,S
* Line dtet.c:1055: init of variable response
* Line dtet.c:1055: function call: readline()
	LBSR	_readline
	STD	-6,U		variable response
* Line dtet.c:1057: if
* optim: stripOpToDeadReg
* optim: stripOpToDeadReg
* Emitted no code to cast `int' to `void *'
* PSHS B,A optim: optimizeStackOperations1
* optim: storeLoad
* optim: loadCmpZeroBeqOrBne
	BEQ	L00734
* optim: branchToNextLocation
* Useless label L00736 removed
* optim: optimizeIndexedX
	LDB	[-6,U]		optim: optimizeIndexedX
* optim: loadCmpZeroBeqOrBne
	BNE	L00735		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
L00734	EQU	*		then clause of if() started at dtet.c:1057
* Line dtet.c:1057
* Line dtet.c:1058: function call: strncpy()
	CLRA
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 3 of strncpy(): int
	LEAX	S00230,PCR	"?"
	PSHS	X		C function argument 2 of strncpy(): const char[]
	LDX	-4,U		variable i
	LDB	#11		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LEAX	_names+0,PCR	address of array names
	LEAX	D,X		add offset
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LBSR	_strncpy
	LEAS	6,S
	BRA	L00737		jump over else clause
L00735	EQU	*		else clause of if() started at dtet.c:1057
* Line dtet.c:1059
* Line dtet.c:1060: function call: strncpy()
	LDX	#$0A		optim: transformPshsDPshsD
* optim: mergePushXPushD
	LDD	-6,U		variable `response', declared at dtet.c:1055
	PSHS	X,B,A		optim: mergePushXPushD
	LDX	-4,U		variable i
	LDB	#11		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LEAX	_names+0,PCR	address of array names
	LEAX	D,X		add offset
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LBSR	_strncpy
	LEAS	6,S
L00737	EQU	*		end of if() started at dtet.c:1057
* Line dtet.c:1062: assignment: =
	CLRB
	PSHS	B
	LDX	-4,U		variable i
	LDB	#11		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LEAX	_names+0,PCR	address of array names
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
* optim: stripConsecOppositeTFRs
* optim: optimizeLeax
	LDB	,S+
	STB	10,X		optim: optimizeLeax
* Line dtet.c:1065: for init
* Line dtet.c:1065: assignment: =
	CLRA
	LDB	#$05		decimal 5 signed
	STD	-2,U
	LBRA	L00739		jump to for condition
L00738	EQU	*
* Line dtet.c:1065: for body
* Line dtet.c:1066: if
	LDD	-2,U		variable j
	LSLB
	ROLA
	LEAX	_scores+0,PCR	address of array scores
* optimizeLoadDX
	LDD	D,X		get r-value
	PSHS	B,A
	LDD	-4,U		variable i
	LSLB
	ROLA
	LEAX	_scores+0,PCR	address of array scores
* optimizeLoadDX
	LDD	D,X		get r-value
	CMPD	,S++
	LBLS	L00741		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00742 removed
* Line dtet.c:1066
* Line dtet.c:1068: if
	LDD	-2,U		variable j
	CMPD	#$05
	BGE	L00747		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00744 removed
* Line dtet.c:1068
* Line dtet.c:1069: assignment: =
	LDD	-2,U		variable j
	LSLB
	ROLA
	LEAX	_scores+0,PCR	address of array scores
* optimizeLoadDX
	LDD	D,X		get r-value
	PSHS	B,A
	LDD	-2,U		variable j
	ADDD	#$01		1
	LSLB
	ROLA
	LEAX	_scores+0,PCR	address of array scores
	LEAX	D,X		add offset
	PULS	A,B		retrieve value to store
	STD	,X
* Line dtet.c:1070: function call: strncpy()
	CLRA
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 3 of strncpy(): int
	LDX	-2,U		variable j
	LDB	#11		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LEAX	_names+0,PCR	address of array names
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	PSHS	B,A		C function argument 2 of strncpy(): char[]
	LDD	-2,U		variable j
	ADDD	#$01		1
	LDX	#11		size of array element
	LBSR	MUL16		get offset in bytes in D
	LEAX	_names+0,PCR	address of array names
	LEAX	D,X		add offset
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LBSR	_strncpy
	LEAS	6,S
* Useless label L00745 removed
* Useless label L00746 removed
	BRA	L00747		jump over else clause
* Useless label L00743 removed
* Line dtet.c:1073
	BRA	L00741		break
L00747	EQU	*		end of if() started at dtet.c:1066
* Useless label L00740 removed
* Line dtet.c:1065: for increment(s)
	LDD	-2,U
	SUBD	#1
	STD	-2,U
L00739	EQU	*
* Line dtet.c:1065: for condition
	LDD	-2,U		variable j
	ADDD	#0
	LBGE	L00738
* optim: branchToNextLocation
L00741	EQU	*		end for
* Line dtet.c:1076: assignment: =
	LDD	-4,U		variable i
	LSLB
	ROLA
	LEAX	_scores+0,PCR	address of array scores
* optimizeLoadDX
	LDD	D,X		get r-value
	PSHS	B,A
	LDD	-2,U		variable j
	ADDD	#$01		1
	LSLB
	ROLA
	LEAX	_scores+0,PCR	address of array scores
	LEAX	D,X		add offset
	PULS	A,B		retrieve value to store
	STD	,X
* Line dtet.c:1077: function call: strncpy()
	CLRA
	LDB	#$0A		decimal 10 signed
	PSHS	B,A		C function argument 3 of strncpy(): int
	LDX	-4,U		variable i
	LDB	#11		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LEAX	_names+0,PCR	address of array names
	LEAX	D,X		add offset
	TFR	X,D		array address as r-value
	PSHS	B,A		C function argument 2 of strncpy(): char[]
	LDD	-2,U		variable j
	ADDD	#$01		1
	LDX	#11		size of array element
	LBSR	MUL16		get offset in bytes in D
	LEAX	_names+0,PCR	address of array names
	LEAX	D,X		add offset
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LBSR	_strncpy
	LEAS	6,S
* Line dtet.c:1078: assignment: =
	CLRA
* LDB #$01 optim: optimizeStackOperations1
* PSHS B optim: optimizeStackOperations1
	LDB	5,U		variable player
	LEAX	_newScore+0,PCR	address of array newScore
	ABX			add unsigned 8-bit offset
	LDB	#1		optim: optimizeStackOperations1
	STB	,X
L00733	EQU	*		else clause of if() started at dtet.c:1047
* Useless label L00748 removed
* Useless label L00158 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION checkScore(): defined at dtet.c:1042
funcend_checkScore	EQU *
funcsize_checkScore	EQU	funcend_checkScore-_checkScore
_main	EXPORT


*******************************************************************************

* FUNCTION main(): defined at dtet.c:1083
_main	EQU	*
* Prototype: int main(...)
* Calling convention: 0 (CMOC Default)
* Line dtet.c:1084: while
* optim: branchToNextLocation
L00749	EQU	*		while body
* Line dtet.c:1085: function call: srand()
	LDD	$0112		decimal 274
	PSHS	B,A		C function argument 1 of srand(): unsigned int
	LBSR	_srand
	LEAS	2,S
* Line dtet.c:1086: function call: init()
	LBSR	_init
* Line dtet.c:1087: function call: mainLoop()
	LBSR	_mainLoop
* Line dtet.c:1088: while
	BRA	L00753		jump to while condition
L00752	EQU	*		while body
L00753	EQU	*		while condition at dtet.c:1088
* Line dtet.c:1088: function call: inkey()
	LBSR	_inkey
	TSTB
	BNE	L00752
* optim: branchToNextLocation
* Useless label L00754 removed
* Line dtet.c:1090: if
	LDB	_cancelled+0,PCR	variable `cancelled', declared at dtet.c:101
* optim: loadCmpZeroBeqOrBne
	BNE	L00749
* optim: branchToNextLocation
* Useless label L00755 removed
* Line dtet.c:1090
* Line dtet.c:1091: function call: checkScore()
	CLRA
	CLRB
	PSHS	B,A		C function argument 1 of checkScore(): int
	LBSR	_checkScore
	LEAS	2,S
* Line dtet.c:1092: if
	LDB	_numPlayers+0,PCR	variable numPlayers
* optim: removeCMPZeroAfterLDIfBHI (BHI->BNE)
	BEQ	L00758		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00757 removed
* Line dtet.c:1093
* Line dtet.c:1093: function call: checkScore()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of checkScore(): int
	LBSR	_checkScore
	LEAS	2,S
L00758	EQU	*		else clause of if() started at dtet.c:1092
* Useless label L00759 removed
* Line dtet.c:1095: if
	LDB	_newScore+0,PCR	index 0 in array newScore[]
* optim: loadCmpZeroBeqOrBne
	BNE	L00760
* optim: branchToNextLocation
* Useless label L00762 removed
	LDB	_newScore+1,PCR	index 1 in array newScore[]
* optim: loadCmpZeroBeqOrBne
	BEQ	L00749		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
L00760	EQU	*		then clause of if() started at dtet.c:1095
* Line dtet.c:1095
* Line dtet.c:1096: function call: cls()
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A		C function argument 1 of cls(): int
	LBSR	_cls
	LEAS	2,S
* Line dtet.c:1097: function call: drawHeader()
	LDB	_colourShift+0,PCR	variable `colourShift', declared at dtet.c:98
	CLRA			promoting byte argument to word
	PSHS	B,A		C function argument 2 of drawHeader(): unsigned char
* optim: stripExtraClrA_B
	CLRB
	PSHS	B,A		C function argument 1 of drawHeader(): int
	LBSR	_drawHeader
	LEAS	4,S
* Line dtet.c:1098: function call: drawHighScores()
	LBSR	_drawHighScores
* Useless label L00761 removed
* Useless label L00763 removed
* Useless label L00756 removed
* Useless label L00764 removed
* Useless label L00750 removed
	LBRA	L00749		go to start of while body
* Useless label L00751 removed
* Line dtet.c:1102: return with value
	CLRA
	CLRB
* optim: branchToNextLocation
* Useless label L00159 removed
	RTS
* END FUNCTION main(): defined at dtet.c:1083
funcend_main	EQU *
funcsize_main	EQU	funcend_main-_main


	ENDSECTION




	SECTION	initgl_start


INITGL	EXPORT
INITGL	EQU	*


	ENDSECTION




	SECTION	initgl




*******************************************************************************

* Initialize global variables.


	ENDSECTION




	SECTION	rodata


string_literals_start	EQU	*


*******************************************************************************

* STRING LITERALS
S00160	EQU	*
	FCC	"DRAGON"
	FCB	0
S00161	EQU	*
	FCB	0
S00162	EQU	*
	FCC	"DRAGONTET!"
	FCB	0
S00163	EQU	*
	FCC	"D R A G O N T E T"
	FCB	0
S00164	EQU	*
	FCC	"SALVAKANTERO 2025"
	FCB	0
S00165	EQU	*
	FCC	"DRAGON %u"
	FCB	0
S00166	EQU	*
	FCC	"LEVEL:  %2u"
	FCB	0
S00167	EQU	*
	FCC	"LINES: %3d"
	FCB	0
S00168	EQU	*
	FCC	"SC: %6u"
	FCB	0
S00169	EQU	*
	FCC	"NEXT:"
	FCB	0
S00170	EQU	*
	FCC	"HI: %6u"
	FCB	0
S00171	EQU	*
	FCC	"%uLIN +%4u"
	FCB	0
S00172	EQU	*
	FCC	"DROP   +%2u"
	FCB	0
S00173	EQU	*
	FCC	"          "
	FCB	0
S00174	EQU	*
	FCC	"0000444400000000"
	FCB	0
S00175	EQU	*
	FCC	"0000222000200000"
	FCB	0
S00176	EQU	*
	FCC	"0000777070000000"
	FCB	0
S00177	EQU	*
	FCC	"0000033003300000"
	FCB	0
S00178	EQU	*
	FCC	"0000066066000000"
	FCB	0
S00179	EQU	*
	FCC	"0000880008800000"
	FCB	0
S00180	EQU	*
	FCC	"0000111001000000"
	FCB	0
S00181	EQU	*
	FCC	"GAME OVER!"
	FCB	0
S00182	EQU	*
	FCC	"............."
	FCB	0
S00183	EQU	*
	FCC	"%s"
	FCB	0
S00184	EQU	*
	FCC	"%5u"
	FCB	0
S00185	EQU	*
	FCC	"PRESS ANY KEY TO CONTINUE!"
	FCB	0
S00186	EQU	*
	FCC	"  =DRAGON 1=  "
	FCB	0
S00187	EQU	*
	FCC	"              "
	FCB	0
S00188	EQU	*
	FCC	" w ROTATE     "
	FCB	0
S00189	EQU	*
	FCC	" s DROP       "
	FCB	0
S00190	EQU	*
	FCC	" a MOVE LEFT  "
	FCB	0
S00191	EQU	*
	FCC	" d MOVE RIGHT "
	FCB	0
S00192	EQU	*
	FCC	" + CURSORS    "
	FCB	0
S00193	EQU	*
	FCC	" + JOYSTICK1  "
	FCB	0
S00194	EQU	*
	FCC	"  =DRAGON 2=  "
	FCB	0
S00195	EQU	*
	FCC	" i ROTATE     "
	FCB	0
S00196	EQU	*
	FCC	" k DROP       "
	FCB	0
S00197	EQU	*
	FCC	" j MOVE LEFT  "
	FCB	0
S00198	EQU	*
	FCC	" l MOVE RIGHT "
	FCB	0
S00199	EQU	*
	FCC	" + JOYSTICK2  "
	FCB	0
S00200	EQU	*
	FCC	" X = CANCEL/RETURN TO MAIN MENU "
	FCB	0
S00201	EQU	*
	FCC	" H = PAUSE THE GAME             "
	FCB	0
S00202	EQU	*
	FCC	"   PRESS ANY KEY TO CONTINUE!   "
	FCB	0
S00203	EQU	*
	FCC	"                             "
	FCB	0
S00204	EQU	*
	FCC	"        = s c o r e =        "
	FCB	0
S00205	EQU	*
	FCC	" 1 LINE:  100 * LEVEL NUMBER "
	FCB	0
S00206	EQU	*
	FCC	" 2 LINES: 300 * LEVEL NUMBER "
	FCB	0
S00207	EQU	*
	FCC	" 3 LINES: 500 * LEVEL NUMBER "
	FCB	0
S00208	EQU	*
	FCC	" 4 LINES: 800 * LEVEL NUMBER "
	FCB	0
S00209	EQU	*
	FCC	"  SOFT DROP:  1 POINT * ROW  "
	FCB	0
S00210	EQU	*
	FCC	"EMPTY BACKGROUND:"
	FCB	0
S00211	EQU	*
	FCC	"MUTED:"
	FCB	0
S00212	EQU	*
	FCC	"BACK"
	FCB	0
S00213	EQU	*
	FCC	"SELECT OPTION (CURSOR/ENTER)"
	FCB	0
S00214	EQU	*
	FCC	"on "
	FCB	0
S00215	EQU	*
	FCC	"off"
	FCB	0
S00216	EQU	*
	FCC	"1 DRAGON GAME"
	FCB	0
S00217	EQU	*
	FCC	"2 DRAGONS GAME"
	FCB	0
S00218	EQU	*
	FCC	"HIGH SCORES"
	FCB	0
S00219	EQU	*
	FCC	"OPTIONS"
	FCB	0
S00220	EQU	*
	FCC	"HELP"
	FCB	0
S00221	EQU	*
	FCC	"EXIT"
	FCB	0
S00222	EQU	*
	FCC	"THANKS FOR PLAYING DRAGONTET!"
	FCB	$0A
	FCB	0
S00223	EQU	*
	FCC	" PLEASE "
	FCB	0
S00224	EQU	*
	FCC	"  WAIT  "
	FCB	0
S00225	EQU	*
	FCC	" DRAGON "
	FCB	0
S00226	EQU	*
	FCC	"   2!   "
	FCB	0
S00227	EQU	*
	FCC	"*** %u ***"
	FCB	0
S00228	EQU	*
	FCC	"GOOD SCORE DRAGON %d"
	FCB	0
S00229	EQU	*
	FCC	"NAME?: "
	FCB	0
S00230	EQU	*
	FCC	"?"
	FCB	0
string_literals_end	EQU	*


*******************************************************************************

* READ-ONLY GLOBAL VARIABLES
_pitLeft	EQU	*		pitLeft: const unsigned char[]
* Element 0 of array, of type const unsigned char
	FCB	$00		decimal 0
* Element 1 of array, of type const unsigned char
	FCB	$16		decimal 22
_backgroundCharList	EQU	*		backgroundCharList: const unsigned char[]
* Element 0 of array, of type const unsigned char
	FCB	$2A		decimal 42
* Element 1 of array, of type const unsigned char
	FCB	$2B		decimal 43
* Element 2 of array, of type const unsigned char
	FCB	$27		decimal 39
* Element 3 of array, of type const unsigned char
	FCB	$23		decimal 35
* Element 4 of array, of type const unsigned char
	FCB	$1C		decimal 28
* Element 5 of array, of type const unsigned char
	FCB	$2C		decimal 44
* Element 6 of array, of type const unsigned char
	FCB	$2F		decimal 47
* Element 7 of array, of type const unsigned char
	FCB	$2E		decimal 46
_tune1Notes	EQU	*		tune1Notes: const unsigned char[]
* Element 0 of array, of type const unsigned char
	FCB	$C9		decimal 201
* Element 1 of array, of type const unsigned char
	FCB	$C9		decimal 201
* Element 2 of array, of type const unsigned char
	FCB	$C9		decimal 201
* Element 3 of array, of type const unsigned char
	FCB	$D0		decimal 208
* Element 4 of array, of type const unsigned char
	FCB	$C3		decimal 195
* Element 5 of array, of type const unsigned char
	FCB	$D2		decimal 210
* Element 6 of array, of type const unsigned char
	FCB	$DA		decimal 218
_tune1Durations	EQU	*		tune1Durations: const unsigned char[]
* Element 0 of array, of type const unsigned char
	FCB	$04		decimal 4
* Element 1 of array, of type const unsigned char
	FCB	$02		decimal 2
* Element 2 of array, of type const unsigned char
	FCB	$02		decimal 2
* Element 3 of array, of type const unsigned char
	FCB	$03		decimal 3
* Element 4 of array, of type const unsigned char
	FCB	$03		decimal 3
* Element 5 of array, of type const unsigned char
	FCB	$03		decimal 3
* Element 6 of array, of type const unsigned char
	FCB	$07		decimal 7
_tune2Notes	EQU	*		tune2Notes: const unsigned char[]
* Element 0 of array, of type const unsigned char
	FCB	$BF		decimal 191
* Element 1 of array, of type const unsigned char
	FCB	$C8		decimal 200
* Element 2 of array, of type const unsigned char
	FCB	$D2		decimal 210
* Element 3 of array, of type const unsigned char
	FCB	$D8		decimal 216
* Element 4 of array, of type const unsigned char
	FCB	$C8		decimal 200
* Element 5 of array, of type const unsigned char
	FCB	$B4		decimal 180
* Element 6 of array, of type const unsigned char
	FCB	$BE		decimal 190
* Element 7 of array, of type const unsigned char
	FCB	$C8		decimal 200
_tune2Durations	EQU	*		tune2Durations: const unsigned char[]
* Element 0 of array, of type const unsigned char
	FCB	$02		decimal 2
* Element 1 of array, of type const unsigned char
	FCB	$02		decimal 2
* Element 2 of array, of type const unsigned char
	FCB	$02		decimal 2
* Element 3 of array, of type const unsigned char
	FCB	$02		decimal 2
* Element 4 of array, of type const unsigned char
	FCB	$04		decimal 4
* Element 5 of array, of type const unsigned char
	FCB	$02		decimal 2
* Element 6 of array, of type const unsigned char
	FCB	$02		decimal 2
* Element 7 of array, of type const unsigned char
	FCB	$04		decimal 4
_tune3Notes	EQU	*		tune3Notes: const unsigned char[]
* Element 0 of array, of type const unsigned char
	FCB	$A5		decimal 165
* Element 1 of array, of type const unsigned char
	FCB	$8C		decimal 140
* Element 2 of array, of type const unsigned char
	FCB	$9B		decimal 155
* Element 3 of array, of type const unsigned char
	FCB	$87		decimal 135
* Element 4 of array, of type const unsigned char
	FCB	$96		decimal 150
* Element 5 of array, of type const unsigned char
	FCB	$82		decimal 130
* Element 6 of array, of type const unsigned char
	FCB	$8C		decimal 140
* Element 7 of array, of type const unsigned char
	FCB	$78		decimal 120
* Element 8 of array, of type const unsigned char
	FCB	$6E		decimal 110
* Element 9 of array, of type const unsigned char
	FCB	$64		decimal 100
_tune3Durations	EQU	*		tune3Durations: const unsigned char[]
* Element 0 of array, of type const unsigned char
	FCB	$03		decimal 3
* Element 1 of array, of type const unsigned char
	FCB	$01		decimal 1
* Element 2 of array, of type const unsigned char
	FCB	$03		decimal 3
* Element 3 of array, of type const unsigned char
	FCB	$01		decimal 1
* Element 4 of array, of type const unsigned char
	FCB	$03		decimal 3
* Element 5 of array, of type const unsigned char
	FCB	$01		decimal 1
* Element 6 of array, of type const unsigned char
	FCB	$02		decimal 2
* Element 7 of array, of type const unsigned char
	FCB	$01		decimal 1
* Element 8 of array, of type const unsigned char
	FCB	$02		decimal 2
* Element 9 of array, of type const unsigned char
	FCB	$04		decimal 4


	ENDSECTION




	SECTION	rwdata


* Statically-initialized global variables
_key	EQU	*		key: char: dtet.c:81
	FCB	$00		decimal 0
_newScore	EQU	*		newScore: unsigned char[]
* Element 0 of array, of type unsigned char
	FCB	$00		decimal 0
* Element 1 of array, of type unsigned char
	FCB	$00		decimal 0
_gameOver	EQU	*		gameOver: unsigned char[]
* Element 0 of array, of type unsigned char
	FCB	$00		decimal 0
* Element 1 of array, of type unsigned char
	FCB	$00		decimal 0
_dropRate	EQU	*		dropRate: int[]
* Element 0 of array, of type int
	FDB	$00		decimal 0
* Element 1 of array, of type int
	FDB	$00		decimal 0
_startTime	EQU	*		startTime: int[]
* Element 0 of array, of type int
	FDB	$00		decimal 0
* Element 1 of array, of type int
	FDB	$00		decimal 0
_level	EQU	*		level: unsigned char[]
* Element 0 of array, of type unsigned char
	FCB	$01		decimal 1
* Element 1 of array, of type unsigned char
	FCB	$01		decimal 1
_lines	EQU	*		lines: int[]
* Element 0 of array, of type int
	FDB	$00		decimal 0
* Element 1 of array, of type int
	FDB	$00		decimal 0
_shape	EQU	*		shape: unsigned char[]
* Element 0 of array, of type unsigned char
	FCB	$FF		decimal 255
* Element 1 of array, of type unsigned char
	FCB	$FF		decimal 255
_nextShape	EQU	*		nextShape: unsigned char[]
* Element 0 of array, of type unsigned char
	FCB	$FF		decimal 255
* Element 1 of array, of type unsigned char
	FCB	$FF		decimal 255
_shapeAngle	EQU	*		shapeAngle: unsigned char[]
* Element 0 of array, of type unsigned char
	FCB	$00		decimal 0
* Element 1 of array, of type unsigned char
	FCB	$00		decimal 0
_shapeX	EQU	*		shapeX: int[]
* Element 0 of array, of type int
	FDB	$00		decimal 0
* Element 1 of array, of type int
	FDB	$00		decimal 0
_shapeY	EQU	*		shapeY: int[]
* Element 0 of array, of type int
	FDB	$00		decimal 0
* Element 1 of array, of type int
	FDB	$00		decimal 0
_colourShift	EQU	*		colourShift: unsigned char: dtet.c:98
	FCB	$00		decimal 0
_emptyBackground	EQU	*		emptyBackground: unsigned char: dtet.c:99
	FCB	$00		decimal 0
_muted	EQU	*		muted: unsigned char: dtet.c:100
	FCB	$00		decimal 0
_cancelled	EQU	*		cancelled: unsigned char: dtet.c:101
	FCB	$00		decimal 0
_names	EQU	*		names: char[][] (array of string literals)
	FCC	"DRAGON"
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCC	"DRAGON"
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCC	"DRAGON"
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCC	"DRAGON"
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCC	"DRAGON"
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCC	"DRAGON"
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
	FCB	$00
_scores	EQU	*		scores: unsigned int[]
* Element 0 of array, of type unsigned int
	FDB	$07D0		decimal 2000
* Element 1 of array, of type unsigned int
	FDB	$0708		decimal 1800
* Element 2 of array, of type unsigned int
	FDB	$0640		decimal 1600
* Element 3 of array, of type unsigned int
	FDB	$0578		decimal 1400
* Element 4 of array, of type unsigned int
	FDB	$04B0		decimal 1200
* Element 5 of array, of type unsigned int
	FDB	$03E8		decimal 1000
* Element 6 of array, of type unsigned int
	FDB	$00		decimal 0
* Element 7 of array, of type unsigned int
	FDB	$00		decimal 0
* Statically-initialized local static variables


	ENDSECTION




	SECTION	bss


bss_start	EQU	*
* Uninitialized global variables
_numPlayers	EQU	*
	RMB	1		numPlayers: unsigned char: dtet.c:82
_pit	EQU	*
	RMB	320		pit: char[][]: dtet.c:87
_shapeMap	EQU	*
	RMB	32		shapeMap: char[][]: dtet.c:95
_nextShapeMap	EQU	*
	RMB	32		nextShapeMap: char[][]: dtet.c:96
_rotatedMap	EQU	*
	RMB	32		rotatedMap: char[][]: dtet.c:97
_lastLines	EQU	*
	RMB	1		lastLines: unsigned char: dtet.c:102
_lastPoints	EQU	*
	RMB	2		lastPoints: unsigned int: dtet.c:103
_backgroundChar	EQU	*
	RMB	2		backgroundChar: unsigned char[]: dtet.c:104
_lastInputTime	EQU	*
	RMB	12		lastInputTime: unsigned int[][]: dtet.c:106
_linesPiecesPlayed	EQU	*
	RMB	2		linesPiecesPlayed: unsigned char[]: dtet.c:107
_previousLevel	EQU	*
	RMB	2		previousLevel: unsigned char[]: dtet.c:108
* Uninitialized local static variables
.local.static.getShapeMap.shapeMaps.initialized	EQU	*
	RMB	1
.local.static.getShapeMap.shapeMaps	EQU	*
	RMB	14		shapeMaps: const char *[]: dtet.c:278
bss_end	EQU	*


	ENDSECTION




	SECTION	initgl_end


	RTS			end of global variable initialization


	ENDSECTION




*******************************************************************************



	SECTION	program_end


program_end	EXPORT
program_end	EQU	*


	ENDSECTION




*******************************************************************************

* Importing 25 utility routine(s).
DIV8	IMPORT
DIV8BY7	IMPORT
MUL16	IMPORT
MUL168	IMPORT
MUL16BY10	IMPORT
SDIV16	IMPORT
_cls	IMPORT
_delay	IMPORT
_exit	IMPORT
_inkey	IMPORT
_isKeyPressed	IMPORT
_locate	IMPORT
_memcpy	IMPORT
_memset	IMPORT
_printf	IMPORT
_rand	IMPORT
_readJoystickPositions	IMPORT
_readline	IMPORT
_screen	IMPORT
_sound	IMPORT
_srand	IMPORT
_strncpy	IMPORT
_waitkey	IMPORT
signedJumpTableSwitch	IMPORT
tfrZtoB	IMPORT


*******************************************************************************

	END
